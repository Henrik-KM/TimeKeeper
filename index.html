<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TimeKeeper Pro â€“ Offline</title>
    <!-- Chart.js for graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="sidebar">
      <div class="logo">TimeTracker&nbsp;Pro</div>
      <ul id="navList">
        <li class="active" data-section="dashboard">Dashboard</li>
        <li data-section="timer">Timer</li>
        <li data-section="projects">Projects</li>
        <li data-section="entries">Entries</li>
        <li data-section="importExport">Import/Export</li>
        <li data-section="todo">Todo</li>
      </ul>
    </div>
    <div class="content">
      <!-- Dashboard Section -->
      <section id="dashboard" class="section active">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Dashboard</h2>
        <div class="stats-grid" id="statsGrid"></div>
        <div id="projectOverview"></div>
        <div id="detailedBreakdown"></div>

        <!-- Recommendations Section: dynamically populated with suggested projects to work on -->


        <!-- Scatter charts for project progress -->
        <div class="card" id="weeklyScatterCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Progress â€“ Weekly (Expected vs Actual)</h3>
          <canvas id="weeklyScatter" height="200"></canvas>
        </div>
        <div class="card" id="monthlyScatterCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Progress â€“ Monthly (Expected vs Actual)</h3>
          <canvas id="monthlyScatter" height="200"></canvas>
        </div>
      </section>
      <!-- Timer Section -->
      <section id="timer" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Timer</h2>
        <div id="runningTimerPro" class="card" style="display:none;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Running Timer</h3>
          <p><strong>Project:</strong> <span id="runningProjectNamePro"></span></p>
          <p><strong>Started:</strong> <span id="runningStartTimePro"></span></p>
          <p><strong>Elapsed:</strong> <span id="runningElapsedPro"></span></p>
          <button id="stopTimerBtnPro" class="btn danger">Stop</button>
        </div>
        <div id="startTimerPro" class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Start Timer</h3>
          <label for="timerProjectPro" style="margin-bottom:0.25rem; font-weight:500;">Project</label>
          <select id="timerProjectPro" style="padding:0.5rem; margin-bottom:0.5rem; width:100%; border:1px solid #cbd5e1; border-radius:0.375rem;"></select>
          <label for="timerInitialPro" style="margin-bottom:0.25rem; font-weight:500;">Hours already spent (optional)</label>
          <input id="timerInitialPro" type="number" min="0" step="0.1" style="padding:0.5rem; margin-bottom:0.5rem; width:100%; border:1px solid #cbd5e1; border-radius:0.375rem;" placeholder="e.g. 0.5" />
          <button id="startTimerBtnPro" class="btn primary" disabled style="padding:0.75rem 1.5rem; font-size:1rem;">Start</button>
        </div>
      </section>
      <!-- Projects Section -->
      <section id="projects" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Projects</h2>
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">New Project</h3>
          <form id="projectFormPro" style="display:flex; flex-direction:column; gap:0.5rem;">
            <label for="projectNamePro" style="font-weight:500;">Project Name</label>
            <input id="projectNamePro" type="text" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectClientPro" style="font-weight:500;">Client (optional)</label>
            <input id="projectClientPro" type="text" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectBudgetPro" style="font-weight:500;">Budget Hours</label>
            <input id="projectBudgetPro" type="number" min="0" step="0.1" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectRatePro" style="font-weight:500;">Hourly Rate</label>
            <input id="projectRatePro" type="number" min="0" step="0.01" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectDeadlinePro" style="font-weight:500;">Deadline</label>
            <input id="projectDeadlinePro" type="date" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <button type="submit" class="btn primary" style="align-self:flex-start;">Add Project</button>
          </form>
        </div>
        <div id="projectsPageList"></div>
      </section>
      <!-- Entries Section -->
      <section id="entries" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Time Entries</h2>
        <div class="card">
          <div style="margin-bottom:0.5rem; display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; font-size:1.1rem; font-weight:600;">Entries</h3>
            <button id="addManualEntryBtnPro" class="btn secondary">Add Manual Entry</button>
          </div>
          <div id="manualEntryFormPro" class="hidden" style="margin-top:1rem;">
            <h4 style="margin:0 0 0.5rem 0; font-size:1rem; font-weight:600;">New Manual Entry</h4>
            <form id="manualFormPro" style="display:flex; flex-direction:column; gap:0.5rem;">
              <label for="manualProjectPro" style="font-weight:500;">Project</label>
              <select id="manualProjectPro" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;"></select>
              <label for="manualDescriptionPro" style="font-weight:500;">Description (optional)</label>
              <input id="manualDescriptionPro" type="text" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
              <label for="manualHoursPro" style="font-weight:500;">Hours</label>
              <input id="manualHoursPro" type="number" min="0" step="0.1" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" placeholder="e.g. 2" />
              <button type="submit" class="btn primary" style="align-self:flex-start;">Save Entry</button>
              <button type="button" id="cancelManualBtnPro" class="btn secondary" style="align-self:flex-start;">Cancel</button>
            </form>
          </div>
          <div style="overflow-x:auto;">
            <table>
              <thead>
                <tr>
                  <th>Project</th>
                  <th>Description</th>
                  <th>Start</th>
                  <th>End</th>
                  <th>Duration</th>
                  <th>Total</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="entriesTableBodyPro"></tbody>
            </table>
          </div>
        </div>
      </section>
      <!-- Import/Export Section -->
      <section id="importExport" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Import / Export</h2>
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Export Data</h3>
          <button id="exportBtnPro" class="btn primary">Export JSON</button>
        </div>
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Import Data</h3>
          <input id="importInputPro" type="file" accept="application/json" />
        </div>

        <!-- Auto Sync card: allows toggling automatic periodic export of data -->
        <div class="card" style="margin-top:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Auto Data Sync</h3>
          <label style="display:flex; align-items:center; gap:0.5rem; cursor:pointer;">
            <input type="checkbox" id="autoSyncToggle" />
            <span>Enable auto sync to local file</span>
          </label>
          <p id="autoSyncStatus" style="font-size:0.8rem; color:#64748b; margin-top:0.5rem;"></p>
        <!-- Button to choose backup directory when enabling auto sync -->
        <button id="chooseBackupDirBtn" class="btn secondary" style="margin-top:0.5rem;">Set Backup Folder</button>
        </div>
      </section>

      <!-- Todo Section -->
      <section id="todo" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Todo</h2>
        <!-- Form to add new todo item -->
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Add Task</h3>
          <form id="todoForm" style="display:flex; gap:0.5rem; flex-wrap:wrap;">
            <input id="todoName" type="text" required placeholder="Task name" style="flex:1; padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <button type="submit" class="btn primary">Add</button>
          </form>
        </div>
        <!-- List of tasks -->
        <div class="card" id="todoListContainer">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Tasks</h3>
          <ul id="todoList" style="list-style:none; padding:0; margin:0;"></ul>
        </div>
      </section>
    </div>
    <script>
      (function() {
        // Simple UUID generator
        function uuid() {
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
          });
        }
        // Load and save data
        function loadData() {
          const raw = localStorage.getItem('timekeeperDataPro');
          if (!raw) return { projects: [], entries: [], todos: [] };
          try {
            const parsed = JSON.parse(raw);
            return {
              projects: Array.isArray(parsed.projects) ? parsed.projects : [],
              entries: Array.isArray(parsed.entries) ? parsed.entries : [],
              todos: Array.isArray(parsed.todos) ? parsed.todos : []
            };
          } catch (err) {
            return { projects: [], entries: [], todos: [] };
          }
        }
        function saveData() {
          localStorage.setItem('timekeeperDataPro', JSON.stringify(data));
          // Mark data as needing backup
          needsBackup = true;
        }

        // Compute concurrency factor based on the number of active timers.
        // Factor decreases as more timers run simultaneously: for example, 1 timer=1.0, 2 timers=0.75, 3 timers=0.6.
        function computeConcurrencyFactor(n) {
          if (n <= 1) return 1;
          return 1 / (1 + (n - 1) / 3);
        }
        let data = loadData();
        // Reset todo checkboxes each Monday. If the stored reset date is not for the current Monday,
        // mark all tasks as unchecked and update the reset date in localStorage. This ensures
        // todos remain persistent week-to-week but are reset at the start of each new week.
        function resetTodosIfNeeded() {
          const today = new Date();
          // Determine the Monday of this week
          const monday = new Date(today);
          const dow = monday.getDay();
          const diffToMonday = (dow + 6) % 7;
          monday.setDate(monday.getDate() - diffToMonday);
          const mondayStr = monday.toDateString();
          const lastReset = localStorage.getItem('todoResetDatePro');
          if (lastReset !== mondayStr) {
            // Reset checked state on all todos
            if (Array.isArray(data.todos)) {
              data.todos.forEach(t => {
                t.checked = false;
              });
            }
            localStorage.setItem('todoResetDatePro', mondayStr);
            saveData();
          }
        }
        // Perform initial todo reset check
        resetTodosIfNeeded();
        // Ensure every project has a color and that colors are unique when possible.
        (function assignProjectColors() {
          const used = new Set();
          let assigned = false;
          data.projects.forEach(p => {
            // If project has a color but it has already been used by a previous project, treat as missing
            if (!p.color || used.has(p.color)) {
              p.color = getUniqueColor();
              assigned = true;
            }
            used.add(p.color);
          });
          if (assigned) {
            saveData();
          }
        })();
        // Global variables to track recommended projects (by id)
        let currentRecommendedWeeklyId = null;
        let currentRecommendedMonthlyId = null;
        // Flag indicating whether data changed since last backup
        let needsBackup = false;

        // Auto data sync flag. Determines whether data is automatically exported (downloaded) on changes.
        let autoSyncEnabled = false;
        // Handle to the directory chosen by the user for backups (File System Access API). This
        // will be set when the user picks a folder via the "Set Backup Folder" button. It is
        // kept in-memory for the current session; due to browser security restrictions,
        // directory handles cannot be serialized to localStorage for reuse across sessions.
        let backupDirHandle = null;
        // Load persisted auto sync preference
        const autoSyncPref = localStorage.getItem('autoSyncEnabledPro');
        if (autoSyncPref !== null) {
          autoSyncEnabled = autoSyncPref === 'true';
        }

        // -------------------------------------------------------------------------
        //  Webhook support and Todo functionality
        //
        //  These constants define the webhook endpoints that should be called when
        //  timers start and stop. They are used to toggle focus modes on the user's
        //  Android and Windows devices. When the first timer starts, the start
        //  webhooks are invoked; when all timers stop, the stop webhooks are invoked.
        const START_WEBHOOKS = ['http://127.0.0.1:8766/focus/start'];
        const STOP_WEBHOOKS = ['http://127.0.0.1:8766/focus/stop'];

        // Send a ping to each URL in the list. Uses navigator.sendBeacon where
        // available to avoid blocking the page; falls back to fetch otherwise.
        function triggerWebhooks(urls) {
          urls.forEach(u => {
            try {
              navigator.sendBeacon(u);
            } catch (err) {
              // sendBeacon may not support GET-only endpoints; fallback to fetch
              fetch(u, { method: 'GET', mode: 'no-cors' }).catch(() => {});
            }
          });
        }

        // Convenience wrappers to trigger start/stop webhooks.
        function triggerFocusStart() {
          triggerWebhooks(START_WEBHOOKS);
        }
        function triggerFocusStop() {
          triggerWebhooks(STOP_WEBHOOKS);
        }

        // Update the Todo section UI based on the current data.todos array. Each
        // todo displays a checkbox reflecting its checked state and a delete
        // button. Changing the checkbox updates the corresponding task and
        // persists to localStorage.
        function updateTodoSection() {
          const listEl = document.getElementById('todoList');
          if (!listEl) return;
          listEl.innerHTML = '';
          const todos = Array.isArray(data.todos) ? data.todos : [];
          todos.forEach((todo, index) => {
            const li = document.createElement('li');
            li.style.display = 'flex';
            li.style.alignItems = 'center';
            li.style.justifyContent = 'space-between';
            li.style.padding = '0.25rem 0';
            // Label containing checkbox and name
            const label = document.createElement('label');
            label.style.display = 'flex';
            label.style.alignItems = 'center';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = !!todo.checked;
            checkbox.addEventListener('change', () => {
              todo.checked = checkbox.checked;
              saveData();
            });
            const span = document.createElement('span');
            span.textContent = todo.name || '';
            span.style.marginLeft = '0.5rem';
            label.appendChild(checkbox);
            label.appendChild(span);
            li.appendChild(label);
            // Delete button to remove the task
            const delBtn = document.createElement('button');
            delBtn.className = 'btn danger';
            delBtn.textContent = 'Delete';
            delBtn.style.fontSize = '0.7rem';
            delBtn.addEventListener('click', () => {
              // Remove the todo at this index and re-render
              data.todos.splice(index, 1);
              saveData();
              updateTodoSection();
            });
            li.appendChild(delBtn);
            listEl.appendChild(li);
          });
        }

        // Attach submit handler to the Todo form. When submitted, a new task is
        // added to data.todos with a unique ID. The list is then re-rendered.
        const todoForm = document.getElementById('todoForm');
        if (todoForm) {
          todoForm.addEventListener('submit', e => {
            e.preventDefault();
            const nameInput = document.getElementById('todoName');
            const name = nameInput.value.trim();
            if (!name) return;
            if (!Array.isArray(data.todos)) {
              data.todos = [];
            }
            data.todos.push({ id: uuid(), name: name, checked: false });
            saveData();
            updateTodoSection();
            nameInput.value = '';
          });
        }

        // Render the todo list once on load so that tasks persist across
        // navigation between sections.
        updateTodoSection();

        // Download the current data to a JSON file. Uses the same filename
        // each time so the browser can overwrite older backups.
        function downloadData() {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'timekeeper-offline-data.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        // Save the current data to the user-selected backup directory. If no directory
        // has been chosen yet, this function silently does nothing. When called,
        // it writes the entire data object to a file named `timekeeper-data.json` in
        // the chosen folder using the File System Access API.
        async function saveBackupToDir() {
          try {
            if (!backupDirHandle) return;
            // Request permission to write. Some browsers may prompt the user here.
            const fileHandle = await backupDirHandle.getFileHandle('timekeeper-data.json', { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(JSON.stringify(data, null, 2));
            await writable.close();
            // After successful backup, clear the needsBackup flag
            needsBackup = false;
          } catch (err) {
            console.error('Saving backup failed:', err);
          }
        }

        // Prompt the user to choose a backup directory using the File System Access API. When
        // the directory is selected, set it as the backupDirHandle and enable auto sync.
        async function chooseBackupDir() {
          try {
            const dirHandle = await window.showDirectoryPicker();
            backupDirHandle = dirHandle;
            // Enable auto sync once a folder is chosen
            autoSyncEnabled = true;
            localStorage.setItem('autoSyncEnabledPro', 'true');
            // Reflect UI state if toggle exists
            const toggle = document.getElementById('autoSyncToggle');
            if (toggle) toggle.checked = true;
            updateAutoSyncStatus();
            // Immediately save a backup now that the directory is chosen
            await saveBackupToDir();
          } catch (err) {
            console.error('Backup folder not selected:', err);
          }
        }

        // Periodically export data if there have been changes.
        // Runs every 10 minutes (600000 ms). Adjust interval as needed.
        setInterval(() => {
          // Only perform automatic backups when auto sync is enabled. When a backup directory
          // is selected, data will be written to the file; otherwise, nothing happens.
          if (autoSyncEnabled && needsBackup) {
            saveBackupToDir().catch(err => {
              console.error('Auto backup failed:', err);
            });
          }
        }, 600000);

        // Navigation
        const navList = document.getElementById('navList');
        navList.querySelectorAll('li').forEach(li => {
          li.addEventListener('click', () => {
            navList.querySelectorAll('li').forEach(item => item.classList.remove('active'));
            li.classList.add('active');
            const sectionId = li.getAttribute('data-section');
            document.querySelectorAll('.section').forEach(sec => {
              sec.style.display = 'none';
            });
            document.getElementById(sectionId).style.display = 'block';
            // update content if needed
            if (sectionId === 'dashboard') {
              updateDashboard();
            } else if (sectionId === 'projects') {
              updateProjectsPage();
            } else if (sectionId === 'entries') {
              updateEntriesTable();
            } else if (sectionId === 'timer') {
              updateTimerSection();
            } else if (sectionId === 'todo') {
              updateTodoSection();
            }
          });
        });

        // Helper functions for formatting
        function formatDateTime(dateStr) {
          const dt = new Date(dateStr);
          return isNaN(dt) ? '' : dt.toLocaleString();
        }
        function formatDate(dateStr) {
          const dt = new Date(dateStr);
          return isNaN(dt) ? '' : dt.toLocaleDateString();
        }
        function formatCurrency(num) {
          // Format currency as Swedish Krona. Place 'kr' after the amount.
          return num.toFixed(2) + ' kr';
        }
        function formatDuration(seconds) {
          const hrs = Math.floor(seconds / 3600);
          const mins = Math.floor((seconds % 3600) / 60);
          const secs = Math.floor(seconds % 60);
          const parts = [];
          if (hrs > 0) parts.push(hrs + 'h');
          if (mins > 0 || hrs > 0) parts.push(mins + 'm');
          parts.push(secs + 's');
          return parts.join(' ');
        }

        // Helper function: Count the number of working days (Mon-Fri) between two dates.
        // The start date is inclusive and the end date is exclusive. If start >= end, returns 0.
        function countWorkdays(startDate, endDate) {
          const start = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
          const end = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
          if (end <= start) return 0;
          let count = 0;
          let current = new Date(start);
          while (current < end) {
            const day = current.getDay();
            // 1-5 are Monday to Friday (0=Sunday, 6=Saturday)
            if (day >= 1 && day <= 5) count++;
            current.setDate(current.getDate() + 1);
          }
          return count;
        }

        // Compute statistics per project
        function computeProjectStats(project) {
          const now = new Date();
          const entries = data.entries.filter(e => e.projectId === project.id && !e.isRunning);
          const totalSeconds = entries.reduce((sum, e) => sum + (e.duration || 0), 0);
          const totalHours = totalSeconds / 3600;
          const remainingHours = project.budgetHours - totalHours;
          const created = new Date(project.createdAt);
          const deadline = new Date(project.deadline);
          const daysPassed = Math.max(1, Math.round((now - created) / (1000 * 60 * 60 * 24)));
          const daysLeft = Math.max(0, Math.round((deadline - now) / (1000 * 60 * 60 * 24)));
          const avgDailyBurn = totalHours / daysPassed;
          const daysToExhaust = avgDailyBurn > 0 ? remainingHours / avgDailyBurn : Infinity;
          // Determine a more descriptive status for the project based on budget consumption and schedule
          // Calculate expected used hours based on how far through the project we are
          const totalProjectDays = daysPassed + daysLeft;
          const expectedUsed = totalProjectDays > 0 ? project.budgetHours * (daysPassed / totalProjectDays) : totalHours;
          let status = 'on-track';
          let statusColor = 'green';
          let reason = '';
          // If total hours already exceed expected usage at this point in the schedule, mark as over budget
          if (totalHours > expectedUsed) {
            status = 'over-budget';
            statusColor = 'red';
            reason = 'Projected to exceed budget before deadline.';
          // If days to exhaust at current burn rate is less than days left, the project will finish late (behind schedule)
          } else if (daysToExhaust < daysLeft) {
            status = 'behind-schedule';
            statusColor = 'red';
            reason = 'Not enough days left at current pace.';
          // If days to exhaust and days left are very close (within three days), label as tight schedule
          } else if (Math.abs(daysToExhaust - daysLeft) <= 3) {
            status = 'tight';
            statusColor = 'amber';
            reason = 'On track but very little margin.';
          } else {
            status = 'on-track';
            statusColor = 'green';
            reason = 'On track.';
          }
          // Weekly and monthly expected hours
          let weeklyExpected = 0;
          let monthlyExpected = 0;
          // Calculate expected (target) hours to date for this week and this month.
          // We base the daily budget on the total calendar days between project creation and deadline.
          // This yields a more realistic expected-to-date value than strictly using working days, which can
          // produce very small denominators when projects span long periods.
          const totalDays = Math.ceil((deadline - created) / (1000 * 60 * 60 * 24)) || 1;
          const dailyBudget = project.budgetHours / totalDays;
          // Determine the start of the current week (Monday) and the start of the current month
          const startOfWeek = new Date(now);
          const dow = startOfWeek.getDay();
          const diffToMonday = (dow + 6) % 7;
          startOfWeek.setDate(startOfWeek.getDate() - diffToMonday);
          const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
          // Compute calendar day counts relative to project creation date
          const daysTillNow = Math.max(0, Math.ceil((now - created) / (1000 * 60 * 60 * 24)));
          const daysTillStartOfWeekCal = Math.max(0, Math.ceil((startOfWeek - created) / (1000 * 60 * 60 * 24)));
          const daysTillStartOfMonthCal = Math.max(0, Math.ceil((startOfMonth - created) / (1000 * 60 * 60 * 24)));
          weeklyExpected = Math.max(0, dailyBudget * (daysTillNow - daysTillStartOfWeekCal));
          monthlyExpected = Math.max(0, dailyBudget * (daysTillNow - daysTillStartOfMonthCal));
          // Clamp expected values so they do not exceed the project's total budget hours
          if (weeklyExpected > project.budgetHours) weeklyExpected = project.budgetHours;
          if (monthlyExpected > project.budgetHours) monthlyExpected = project.budgetHours;
          // Weekly and last week hours
          const weekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 6);
          const lastWeekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 13);
          const lastWeekEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7);
          const weeklySeconds = entries
            .filter(e => new Date(e.startTime) >= weekStart)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const weeklyHours = weeklySeconds / 3600;
          const lastWeekSeconds = entries
            .filter(e => new Date(e.startTime) >= lastWeekStart && new Date(e.startTime) < lastWeekEnd)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const lastWeekHours = lastWeekSeconds / 3600;
          // Monthly hours and last month hours
          const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
          const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
          const monthlySeconds = entries.filter(e => new Date(e.startTime) >= monthStart)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const monthlyHours = monthlySeconds / 3600;
          const lastMonthSeconds = entries.filter(e => new Date(e.startTime) >= lastMonthStart && new Date(e.startTime) < lastMonthEnd)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const lastMonthHours = lastMonthSeconds / 3600;
          // Revenue
          const revenue = totalHours * project.hourlyRate;
          const weeklyRevenue = weeklyHours * project.hourlyRate;
          const lastWeekRevenue = lastWeekHours * project.hourlyRate;
          const monthlyRevenue = monthlyHours * project.hourlyRate;
          const lastMonthRevenue = lastMonthHours * project.hourlyRate;
          // Calculate constant weekly and monthly targets for this project. These targets are derived by
          // spreading the total budget evenly across the total number of weeks and months between
          // the project start and its deadline. We use calendar weeks (7â€‘day chunks) and calendar
          // months (30â€‘day chunks) rather than working days so that targets are intuitive and stable.
          // At least one week and one month are assumed to avoid division by zero.
          const totalProjectDaysConst = Math.max(1, Math.ceil((deadline - created) / (1000 * 60 * 60 * 24)));
          const totalWeeksConst = Math.max(1, Math.ceil(totalProjectDaysConst / 7));
          const totalMonthsConst = Math.max(1, Math.ceil(totalProjectDaysConst / 30));
          const weeklyTargetConst = project.budgetHours / totalWeeksConst;
          const monthlyTargetConst = project.budgetHours / totalMonthsConst;
          return {
            totalHours,
            remainingHours,
            usedPct: project.budgetHours > 0 ? (totalHours / project.budgetHours) * 100 : 0,
            daysLeft,
            daysPassed,
            status,
            statusColor,
            reason,
            weeklyExpected,
            monthlyExpected,
            weeklyHours,
            lastWeekHours,
            monthlyHours,
            lastMonthHours,
            revenue,
            weeklyRevenue,
            lastWeekRevenue,
            monthlyRevenue,
            lastMonthRevenue,
            weeklyTargetConst,
            monthlyTargetConst
          };
        }

        // Compute global statistics
        function computeGlobalStats() {
          const now = new Date();
          const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          const yesterdayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
          const weekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 6);
          const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
          const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
          let todaySeconds = 0;
          let yesterdaySeconds = 0;
          let weekSeconds = 0;
          let monthSeconds = 0;
          let lastMonthSeconds = 0;
          let totalRevenue = 0;
          let monthlyRevenue = 0;
          let lastMonthRevenue = 0;
          // Constant weekly and monthly targets for all projects. Each project's budget is spread evenly across
          // its total duration in weeks and months (using calendar weeks of 7 days and months of 30 days). The
          // sum of these perâ€‘project targets represents the number of hours you should aim to work this week
          // and this month across all projects.
          let weeklyTarget = 0;
          let monthTarget = 0;
          data.projects.forEach(project => {
            const created = new Date(project.createdAt);
            const deadline = new Date(project.deadline);
            const totalProjectDaysConst = Math.max(1, Math.ceil((deadline - created) / (1000 * 60 * 60 * 24)));
            const totalWeeksConst = Math.max(1, Math.ceil(totalProjectDaysConst / 7));
            const totalMonthsConst = Math.max(1, Math.ceil(totalProjectDaysConst / 30));
            weeklyTarget += project.budgetHours / totalWeeksConst;
            monthTarget += project.budgetHours / totalMonthsConst;
          });
          data.entries.forEach(entry => {
            if (entry.isRunning || !entry.duration) return;
            const start = new Date(entry.startTime);
            const project = data.projects.find(p => p.id === entry.projectId);
            const hours = entry.duration / 3600;
            if (!project) return;
            if (start >= todayStart) {
              todaySeconds += entry.duration;
            }
            if (start >= yesterdayStart && start < todayStart) {
              yesterdaySeconds += entry.duration;
            }
            if (start >= weekStart) {
              weekSeconds += entry.duration;
            }
            if (start >= monthStart) {
              monthSeconds += entry.duration;
              monthlyRevenue += hours * project.hourlyRate;
            } else if (start >= lastMonthStart && start < lastMonthEnd) {
              lastMonthSeconds += entry.duration;
              lastMonthRevenue += hours * project.hourlyRate;
            }
            totalRevenue += hours * project.hourlyRate;
          });
          const todayHours = todaySeconds / 3600;
          const yesterdayHours = yesterdaySeconds / 3600;
          const weekHours = weekSeconds / 3600;
          const monthHours = monthSeconds / 3600;
          const lastMonthHours = lastMonthSeconds / 3600;
          const weeklyProgress = weeklyTarget > 0 ? (weekHours / weeklyTarget) * 100 : 0;
          const revenueChange = lastMonthRevenue > 0 ? ((monthlyRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : null;
          const todayChange = yesterdayHours > 0 ? ((todayHours - yesterdayHours) / yesterdayHours) * 100 : null;
          const activeProjects = data.projects.length;
          const dueThisWeek = data.projects.filter(p => {
            const d = new Date(p.deadline);
            const diffDays = Math.round((d - now) / (1000 * 60 * 60 * 24));
            return diffDays >= 0 && diffDays <= 7;
          }).length;
          const monthProgress = monthTarget > 0 ? (monthHours / monthTarget) * 100 : 0;
          return {
            todayHours,
            yesterdayHours,
            weekHours,
            weekTarget: weeklyTarget,
            weeklyProgress,
            monthHours,
            monthTarget,
            monthProgress,
            monthRevenue: monthlyRevenue,
            lastMonthRevenue,
            revenueChange,
            todayChange,
            activeProjects,
            dueThisWeek,
            totalRevenue
          };
        }

        // Dashboard rendering
        function updateDashboard() {
          const stats = computeGlobalStats();
          // Determine recommended projects before building cards and assign global identifiers
          let maxWeeklyDeficitCard = -Infinity;
          let maxMonthlyDeficitCard = -Infinity;
          let recommendedWeeklyProject = null;
          let recommendedMonthlyProject = null;
          if (data.projects.length > 0) {
            data.projects.forEach(project => {
              const sp = computeProjectStats(project);
              const weeklyDeficit = (sp.weeklyExpected || 0) - (sp.weeklyHours || 0);
              if (weeklyDeficit > maxWeeklyDeficitCard) {
                maxWeeklyDeficitCard = weeklyDeficit;
                recommendedWeeklyProject = project;
              }
              const monthlyDeficit = (sp.monthlyExpected || 0) - (sp.monthlyHours || 0);
              if (monthlyDeficit > maxMonthlyDeficitCard) {
                maxMonthlyDeficitCard = monthlyDeficit;
                recommendedMonthlyProject = project;
              }
            });
          }
          // Update global identifiers so other sections know which projects are recommended
          currentRecommendedWeeklyId = recommendedWeeklyProject ? recommendedWeeklyProject.id : null;
          currentRecommendedMonthlyId = recommendedMonthlyProject ? recommendedMonthlyProject.id : null;
          // Precompute per-project stats once for use in cards and recommendations. This avoids
          // recalculating computeProjectStats multiple times during rendering.
          const perProjectStats = data.projects.map(p => {
            return { project: p, stats: computeProjectStats(p) };
          });
          // Stats cards data; integrate recommended project suggestions in week and month cards
          const cards = [
            {
              title: "Today's Hours",
              value: stats.todayHours.toFixed(1) + 'h',
              change: stats.todayChange,
              icon: 'â±',
              changeLabel: 'vs yesterday'
            },
            {
              title: 'This Week',
              value: stats.weekHours.toFixed(1) + ' / ' + (stats.weekTarget ? stats.weekTarget.toFixed(1) : '0') + 'h',
              progress: stats.weeklyProgress,
              icon: 'ðŸ“…',
              // Weekly progress shows how much of the constant weekly target has been completed.
              progressLabel: (stats.weeklyProgress || 0).toFixed(1) + '% of weekly target' + (recommendedWeeklyProject ? ' Â· Work on ' + recommendedWeeklyProject.name : '')
            },
            {
              title: 'This Month',
              value: stats.monthHours.toFixed(1) + ' / ' + (stats.monthTarget ? stats.monthTarget.toFixed(1) : '0') + 'h',
              progress: stats.monthProgress,
              icon: 'ðŸ—“',
              // Monthly progress shows how much of the constant monthly target has been completed.
              progressLabel: (stats.monthProgress || 0).toFixed(1) + '% of monthly target' + (recommendedMonthlyProject ? ' Â· Work on ' + recommendedMonthlyProject.name : '')
            },
            {
              title: 'Active Projects',
              value: stats.activeProjects.toString(),
              changeLabel: stats.dueThisWeek + ' due this week',
              change: null,
              icon: 'ðŸ“'
            },
            {
              title: 'Revenue',
              value: formatCurrency(stats.monthRevenue),
              change: stats.revenueChange,
              changeLabel: 'this month',
              icon: 'ðŸ’°'
            }
          ];
          const statsGrid = document.getElementById('statsGrid');
          statsGrid.innerHTML = '';
          cards.forEach(card => {
            const div = document.createElement('div');
            div.className = 'stat-card';
            // icon
            const iconDiv = document.createElement('div');
            iconDiv.className = 'stat-icon';
            iconDiv.textContent = card.icon;
            div.appendChild(iconDiv);
            // title
            const titleDiv = document.createElement('div');
            titleDiv.className = 'stat-title';
            titleDiv.textContent = card.title;
            div.appendChild(titleDiv);
            // value
            const valueDiv = document.createElement('div');
            valueDiv.className = 'stat-value';
            valueDiv.textContent = card.value;
            div.appendChild(valueDiv);
            // progress or change
            if (card.progress !== undefined) {
              // progress bar and label
              const progressBar = document.createElement('div');
              progressBar.className = 'progress-bar';
              const fill = document.createElement('div');
              fill.className = 'fill';
              fill.style.width = Math.min(100, card.progress).toFixed(1) + '%';
              progressBar.appendChild(fill);
              div.appendChild(progressBar);
              const pLabel = document.createElement('div');
              pLabel.className = 'stat-change';
              pLabel.textContent = card.progressLabel || '';
              pLabel.style.color = '#475569';
              div.appendChild(pLabel);
            } else {
              const changeDiv = document.createElement('div');
              changeDiv.className = 'stat-change';
              if (card.change === null || card.change === undefined) {
                changeDiv.textContent = card.changeLabel || '';
                changeDiv.style.color = '#475569';
              } else {
                const change = card.change;
                const prefix = change >= 0 ? '+' : '';
                changeDiv.textContent = prefix + change.toFixed(0) + '% ' + card.changeLabel;
                changeDiv.classList.add(change >= 0 ? 'positive' : 'negative');
              }
              div.appendChild(changeDiv);
            }
            // If this card represents weekly or monthly totals, append per-project breakdowns underneath
            if (card.title === 'This Week' || card.title === 'This Month') {
              const targetList = document.createElement('div');
              targetList.style.marginTop = '0.5rem';
              perProjectStats.forEach(item => {
                const row = document.createElement('div');
                row.style.fontSize = '0.75rem';
                row.style.color = '#475569';
                if (card.title === 'This Week') {
                  row.textContent = `${item.project.name}: ${item.stats.weeklyHours.toFixed(1)} / ${item.stats.weeklyTargetConst.toFixed(1)}h`;
                } else {
                  row.textContent = `${item.project.name}: ${item.stats.monthlyHours.toFixed(1)} / ${item.stats.monthlyTargetConst.toFixed(1)}h`;
                }
                targetList.appendChild(row);
              });
              div.appendChild(targetList);
            }
            statsGrid.appendChild(div);
          });
          // Project status overview and detailed breakdown
          renderProjectOverview();
          renderDetailedBreakdown();
          // Previously there was a separate Recommendations card here. It has been removed in favor of integrating suggestions directly into other sections.

          // Prepare data for weekly and monthly scatter charts
          const weeklyDatasets = [];
          const monthlyDatasets = [];
          // Track the maximum expected/actual values to draw an ideal x=y line
          let maxWeeklyVal = 0;
          let maxMonthlyVal = 0;
          data.projects.forEach(project => {
            const statsP = computeProjectStats(project);
            const color = project.color || '#3b82f6';
            weeklyDatasets.push({
              label: project.name,
              data: [{ x: statsP.weeklyExpected, y: statsP.weeklyHours }],
              // Use project color for point appearance
              pointBackgroundColor: color,
              pointBorderColor: color,
              backgroundColor: color,
              borderColor: color,
              pointRadius: 5,
              pointHoverRadius: 7,
              showLine: false
            });
            monthlyDatasets.push({
              label: project.name,
              data: [{ x: statsP.monthlyExpected, y: statsP.monthlyHours }],
              // Use project color for point appearance
              pointBackgroundColor: color,
              pointBorderColor: color,
              backgroundColor: color,
              borderColor: color,
              pointRadius: 5,
              pointHoverRadius: 7,
              showLine: false
            });
            // Update max values for diagonal line
            maxWeeklyVal = Math.max(maxWeeklyVal, statsP.weeklyExpected, statsP.weeklyHours);
            maxMonthlyVal = Math.max(maxMonthlyVal, statsP.monthlyExpected, statsP.monthlyHours);
          });
          // Add diagonal x=y guide line datasets to both charts
          if (weeklyDatasets.length > 0) {
            weeklyDatasets.unshift({
              label: 'Ideal (x=y)',
              data: [
                { x: 0, y: 0 },
                { x: maxWeeklyVal, y: maxWeeklyVal }
              ],
              borderColor: '#94a3b8',
              borderDash: [5, 5],
              showLine: true,
              fill: false,
              pointRadius: 0
            });
          }
          if (monthlyDatasets.length > 0) {
            monthlyDatasets.unshift({
              label: 'Ideal (x=y)',
              data: [
                { x: 0, y: 0 },
                { x: maxMonthlyVal, y: maxMonthlyVal }
              ],
              borderColor: '#94a3b8',
              borderDash: [5, 5],
              showLine: true,
              fill: false,
              pointRadius: 0
            });
          }
          // Weekly scatter chart
          const weeklyCanvas = document.getElementById('weeklyScatter');
          if (weeklyCanvas) {
            if (!weeklyScatterChart) {
              const ctx = weeklyCanvas.getContext('2d');
              weeklyScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: weeklyDatasets },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: { display: true, position: 'bottom', labels: { boxWidth: 12 } },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          const label = context.dataset.label || '';
                          const xVal = context.parsed.x;
                          const yVal = context.parsed.y;
                          return label + ': Expected ' + xVal.toFixed(1) + 'h, Actual ' + yVal.toFixed(1) + 'h';
                        }
                      }
                    },
                    title: { display: false }
                  },
                  scales: {
                    x: { title: { display: true, text: 'Expected Hours' }, beginAtZero: true },
                    y: { title: { display: true, text: 'Actual Hours' }, beginAtZero: true }
                  }
                }
              });
            } else {
              weeklyScatterChart.data.datasets = weeklyDatasets;
              weeklyScatterChart.update();
            }
          }
          // Monthly scatter chart
          const monthlyCanvas = document.getElementById('monthlyScatter');
          if (monthlyCanvas) {
            if (!monthlyScatterChart) {
              const ctx2 = monthlyCanvas.getContext('2d');
              monthlyScatterChart = new Chart(ctx2, {
                type: 'scatter',
                data: { datasets: monthlyDatasets },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: { display: true, position: 'bottom', labels: { boxWidth: 12 } },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          const label = context.dataset.label || '';
                          const xVal = context.parsed.x;
                          const yVal = context.parsed.y;
                          return label + ': Expected ' + xVal.toFixed(1) + 'h, Actual ' + yVal.toFixed(1) + 'h';
                        }
                      }
                    },
                    title: { display: false }
                  },
                  scales: {
                    x: { title: { display: true, text: 'Expected Hours' }, beginAtZero: true },
                    y: { title: { display: true, text: 'Actual Hours' }, beginAtZero: true }
                  }
                }
              });
            } else {
              monthlyScatterChart.data.datasets = monthlyDatasets;
              monthlyScatterChart.update();
            }
          }
        }

        // Render project overview list
        function renderProjectOverview() {
          const container = document.getElementById('projectOverview');
          container.innerHTML = '';
          if (data.projects.length === 0) return;
          const wrapper = document.createElement('div');
          wrapper.className = 'project-list';
          const header = document.createElement('div');
          header.className = 'project-list-header';
          header.textContent = 'Project Status Overview';
          wrapper.appendChild(header);
          data.projects.forEach(project => {
            const stats = computeProjectStats(project);
            const item = document.createElement('div');
            item.className = 'project-item';
            // info section
            const info = document.createElement('div');
            info.className = 'project-info';
            const dot = document.createElement('div');
            dot.className = 'dot';
            dot.style.backgroundColor = project.color || '#3b82f6';
            info.appendChild(dot);
            const nameDiv = document.createElement('div');
            nameDiv.style.fontWeight = '600';
            nameDiv.style.fontSize = '0.9rem';
            nameDiv.textContent = project.name;
            // Add star markers for recommended projects
            if (project.id === currentRecommendedWeeklyId) {
              const starW = document.createElement('span');
              starW.textContent = 'â˜…';
              starW.style.color = '#ef4444';
              starW.style.marginLeft = '0.25rem';
              starW.title = 'Recommended this week';
              nameDiv.appendChild(starW);
            }
            if (project.id === currentRecommendedMonthlyId) {
              const starM = document.createElement('span');
              starM.textContent = 'â˜…';
              starM.style.color = '#f97316';
              starM.style.marginLeft = '0.25rem';
              starM.title = 'Recommended this month';
              nameDiv.appendChild(starM);
            }
            info.appendChild(nameDiv);
            const hoursDiv = document.createElement('div');
            hoursDiv.style.fontSize = '0.8rem';
            hoursDiv.style.color = '#64748b';
            hoursDiv.textContent = stats.totalHours.toFixed(1) + 'h / ' + project.budgetHours.toFixed(1) + 'h';
            info.appendChild(hoursDiv);
            item.appendChild(info);
            // progress bar container
            const progressContainer = document.createElement('div');
            progressContainer.style.flex = '1';
            progressContainer.style.margin = '0 1rem';
            const bar = document.createElement('div');
            bar.className = 'progress-bar';
            const fill = document.createElement('div');
            fill.className = 'fill';
            fill.style.width = Math.min(100, stats.usedPct).toFixed(1) + '%';
            bar.appendChild(fill);
            progressContainer.appendChild(bar);
            item.appendChild(progressContainer);
            // status badge with descriptive text and tooltip
            const status = document.createElement('span');
            status.className = 'status-badge ' + (stats.statusColor || 'green');
            // Determine human-friendly label
            let statusLabel;
            if (stats.status === 'over-budget') statusLabel = 'Over Budget';
            else if (stats.status === 'behind-schedule') statusLabel = 'Behind Schedule';
            else if (stats.status === 'tight') statusLabel = 'Tight';
            else statusLabel = 'On Track';
            status.textContent = statusLabel;
            // Tooltip explaining the reason
            if (stats.reason) {
              status.title = stats.reason;
            }
            item.appendChild(status);
            wrapper.appendChild(item);
          });
          container.appendChild(wrapper);
        }

        // Render detailed project breakdown table
        function renderDetailedBreakdown() {
          const container = document.getElementById('detailedBreakdown');
          container.innerHTML = '';
          if (data.projects.length === 0) return;
          const card = document.createElement('div');
          card.className = 'card';
          const heading = document.createElement('h3');
          heading.textContent = 'Detailed Project Breakdown';
          heading.style.margin = '0 0 0.5rem 0';
          heading.style.fontSize = '1.1rem';
          heading.style.fontWeight = '600';
          card.appendChild(heading);
          const table = document.createElement('table');
          const thead = document.createElement('thead');
          thead.innerHTML = '<tr><th>Project</th><th>Client</th><th>Hours</th><th>Budget</th><th>Status</th><th>This Week</th><th>Last Week</th><th>This Month</th><th>Revenue</th></tr>';
          table.appendChild(thead);
          const tbody = document.createElement('tbody');
          data.projects.forEach(project => {
            const stats = computeProjectStats(project);
            const isRecommendedWeekly = (project.id === currentRecommendedWeeklyId);
            const isRecommendedMonthly = (project.id === currentRecommendedMonthlyId);
            const tr = document.createElement('tr');
            // Determine human-friendly label and color for status
            let statusLabel;
            if (stats.status === 'over-budget') statusLabel = 'Over Budget';
            else if (stats.status === 'behind-schedule') statusLabel = 'Behind Schedule';
            else if (stats.status === 'tight') statusLabel = 'Tight';
            else statusLabel = 'On Track';
            tr.innerHTML = `
              <td>${project.name}</td>
              <td>${project.client || '-'}</td>
              <td>${stats.totalHours.toFixed(1)}h</td>
              <td>${project.budgetHours.toFixed(1)}h</td>
              <td><span class="status-badge ${stats.statusColor}"${stats.reason ? ` title="${stats.reason}"` : ''}>${statusLabel}</span></td>
              <td>${stats.weeklyHours.toFixed(1)} / ${stats.weeklyExpected.toFixed(1)}h${isRecommendedWeekly ? ' (Recommended)' : ''} (target to date)</td>
              <td>${stats.lastWeekHours.toFixed(1)}h</td>
              <td>${stats.monthlyHours.toFixed(1)} / ${stats.monthlyExpected.toFixed(1)}h${isRecommendedMonthly ? ' (Recommended)' : ''} (target to date)</td>
              <td>${formatCurrency(stats.revenue)}</td>
            `;
            tbody.appendChild(tr);
          });
          table.appendChild(tbody);
          card.appendChild(table);
          container.appendChild(card);
        }

        // Projects page rendering
        function updateProjectsPage() {
          updateProjectSelects();
          renderProjectsPageList();
        }
        function renderProjectsPageList() {
          const container = document.getElementById('projectsPageList');
          container.innerHTML = '';
          if (data.projects.length === 0) {
            const p = document.createElement('p');
            p.textContent = 'No projects yet.';
            container.appendChild(p);
            return;
          }
          data.projects.forEach(project => {
            const stats = computeProjectStats(project);
            // Determine if this project is the recommended one for this week or month
            const isRecommendedWeekly = (project.id === currentRecommendedWeeklyId);
            const isRecommendedMonthly = (project.id === currentRecommendedMonthlyId);
            // Determine a human-friendly status label and color
            let statusLabel;
            if (stats.status === 'over-budget') statusLabel = 'Over Budget';
            else if (stats.status === 'behind-schedule') statusLabel = 'Behind Schedule';
            else if (stats.status === 'tight') statusLabel = 'Tight';
            else statusLabel = 'On Track';
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `
              <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">${project.name}</h3>
              <p style="margin:0 0 0.25rem 0;"><strong>Client:</strong> ${project.client || '-'}</p>
              <p style="margin:0 0 0.25rem 0;"><strong>Budget:</strong> ${project.budgetHours.toFixed(1)}h @ ${formatCurrency(project.hourlyRate)}</p>
              <div style="margin:0.5rem 0;">
                <div class="progress-bar" style="margin-bottom:0.25rem;"><div class="fill" style="width:${Math.min(100, stats.usedPct).toFixed(1)}%;"></div></div>
                <small>${stats.totalHours.toFixed(1)}h used (${stats.usedPct.toFixed(1)}%), ${stats.remainingHours.toFixed(1)}h left</small>
              </div>
              <div style="margin:0.5rem 0;">
                <div class="progress-bar" style="margin-bottom:0.25rem;"><div class="fill" style="width:${stats.weeklyHours / (stats.weeklyExpected || 1) * 100}%"></div></div>
                <small>This week: ${stats.weeklyHours.toFixed(1)} / ${stats.weeklyExpected.toFixed(1)}h${isRecommendedWeekly ? ' (Recommended)' : ''} (target to date)</small>
              </div>
              <div style="margin:0.5rem 0;">
                <div class="progress-bar" style="margin-bottom:0.25rem;"><div class="fill" style="width:${stats.monthlyHours / (stats.monthlyExpected || 1) * 100}%"></div></div>
                <small>This month: ${stats.monthlyHours.toFixed(1)} / ${stats.monthlyExpected.toFixed(1)}h${isRecommendedMonthly ? ' (Recommended)' : ''} (target to date)</small>
              </div>
              <p style="margin:0.25rem 0;"><strong>Deadline:</strong> ${formatDate(project.deadline)}</p>
              <p style="margin:0.25rem 0;"><strong>Status:</strong> <span class="status-badge ${stats.statusColor || 'green'}"${stats.reason ? ` title="${stats.reason}"` : ''}>${statusLabel}</span></p>
              <div style="display:flex; gap:0.5rem; margin-top:0.5rem;">
                <button class="btn secondary edit-btn" data-id="${project.id}">Edit</button>
                <button class="btn danger delete-btn" data-id="${project.id}">Delete</button>
              </div>
            `;
            // Edit button handler
            const editBtn = card.querySelector('.edit-btn');
            editBtn.addEventListener('click', () => {
              // Prompt the user for new project details
              const newName = prompt('Project Name:', project.name);
              if (!newName) return;
              const newClient = prompt('Client (optional):', project.client || '');
              const newBudgetStr = prompt('Budget Hours:', project.budgetHours.toFixed(1));
              const newBudget = parseFloat(newBudgetStr);
              if (isNaN(newBudget)) return;
              const newRateStr = prompt('Hourly Rate:', project.hourlyRate.toFixed(2));
              const newRate = parseFloat(newRateStr);
              if (isNaN(newRate)) return;
              const newDeadline = prompt('Deadline (YYYY-MM-DD):', project.deadline);
              if (!newDeadline) return;
              // Update project fields
              project.name = newName.trim();
              project.client = newClient ? newClient.trim() : null;
              project.budgetHours = newBudget;
              project.hourlyRate = newRate;
              project.deadline = newDeadline;
              saveData();
              updateProjectsPage();
              updateProjectSelects();
              updateDashboard();
            });
            // Delete button handler
            const deleteBtn = card.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', () => {
              if (confirm('Delete this project and its entries?')) {
                data.projects = data.projects.filter(p => p.id !== project.id);
                data.entries = data.entries.filter(e => e.projectId !== project.id);
                saveData();
                updateProjectsPage();
                updateDashboard();
              }
            });
            container.appendChild(card);
          });
        }

        // Create new project
        document.getElementById('projectFormPro').addEventListener('submit', (e) => {
          e.preventDefault();
          const name = document.getElementById('projectNamePro').value.trim();
          const client = document.getElementById('projectClientPro').value.trim();
          const budget = parseFloat(document.getElementById('projectBudgetPro').value);
          const rate = parseFloat(document.getElementById('projectRatePro').value);
          const deadline = document.getElementById('projectDeadlinePro').value;
          if (!name || !deadline) return;
          const newProject = {
            id: uuid(),
            name,
            client: client || null,
            budgetHours: budget,
            hourlyRate: rate,
            deadline,
            createdAt: new Date().toISOString(),
            color: getUniqueColor(),
            isActive: true
          };
          data.projects.push(newProject);
          saveData();
          e.target.reset();
          updateProjectsPage();
          updateProjectSelects();
          updateDashboard();
        });

        // Color generator for project dots. Ensures uniqueness by selecting an unused color when possible.
        function getRandomColor() {
          const palette = ['#2563eb', '#dc2626', '#10b981', '#8b5cf6', '#f59e0b', '#ec4899'];
          return palette[Math.floor(Math.random() * palette.length)];
        }

        function getUniqueColor() {
          const palette = ['#2563eb', '#dc2626', '#10b981', '#8b5cf6', '#f59e0b', '#ec4899'];
          // Collect colors already used by existing projects
          const used = new Set(data.projects.map(p => p.color).filter(c => c));
          // Find a color not used yet
          for (const col of palette) {
            if (!used.has(col)) {
              return col;
            }
          }
          // If all colors are used, return a random one
          return palette[Math.floor(Math.random() * palette.length)];
        }

        // Timer section functions (reuse from previous implementation but adjust IDs)
        function getRunningEntries() {
          // Return an array of all entries that are currently running
          return data.entries.filter(e => e.isRunning);
        }
        function updateTimerSection() {
          const runningEntries = getRunningEntries();
          const runningDiv = document.getElementById('runningTimerPro');
          const startDiv = document.getElementById('startTimerPro');
          // Clear any previous interval that updated timers
          clearInterval(timerInterval);
          if (runningEntries.length > 0) {
            // Show the running timers section
            runningDiv.style.display = '';
            // Keep the start form visible to allow starting additional timers
            startDiv.style.display = '';
            // Clear and rebuild the running timers list
            runningDiv.innerHTML = '';
            // Heading for running timers
            const heading = document.createElement('h3');
            heading.textContent = 'Running Timers';
            heading.style.margin = '0 0 0.5rem 0';
            heading.style.fontSize = '1.1rem';
            heading.style.fontWeight = '600';
            runningDiv.appendChild(heading);
            // Render each running entry
            runningEntries.forEach(entry => {
              const project = data.projects.find(p => p.id === entry.projectId);
              const row = document.createElement('div');
              row.style.marginBottom = '0.75rem';
              // Project name
              const nameP = document.createElement('p');
              nameP.innerHTML = '<strong>Project:</strong> ' + (project ? project.name : '');
              row.appendChild(nameP);
              // Started time
              const startP = document.createElement('p');
              startP.innerHTML = '<strong>Started:</strong> ' + formatDateTime(entry.startTime);
              row.appendChild(startP);
              // Elapsed time
              const elapsedP = document.createElement('p');
              elapsedP.innerHTML = '<strong>Elapsed:</strong> ';
              const elapsedSpan = document.createElement('span');
              elapsedSpan.id = 'runningElapsed-' + entry.id;
              elapsedSpan.textContent = '';
              elapsedP.appendChild(elapsedSpan);
              row.appendChild(elapsedP);
              // Factor display (e.g. 100%, 75%)
              const factorP = document.createElement('p');
              factorP.innerHTML = '<strong>Factor:</strong> ';
              const factorSpan = document.createElement('span');
              factorSpan.id = 'runningFactor-' + entry.id;
              factorSpan.textContent = '';
              factorP.appendChild(factorSpan);
              row.appendChild(factorP);
              // Stop button
              const stopBtn = document.createElement('button');
              stopBtn.className = 'btn danger';
              stopBtn.textContent = 'Stop';
              stopBtn.addEventListener('click', () => {
                stopSingleTimer(entry.id);
              });
              row.appendChild(stopBtn);
              runningDiv.appendChild(row);
            });
            // Start an interval that updates all running timers every second
            const tick = () => {
              const now = new Date();
              runningEntries.forEach(entry => {
                // Compute effective elapsed time: accumulate effectiveSeconds plus time since last update times current factor
                const last = entry.lastUpdateTime ? new Date(entry.lastUpdateTime) : new Date(entry.startTime);
                const prev = entry.effectiveSeconds || 0;
                const factor = entry.factor || computeConcurrencyFactor(runningEntries.length);
                const extra = (now - last) / 1000 * factor;
                const effective = prev + extra;
                // Update elapsed display
                const elapsedSpan = document.getElementById('runningElapsed-' + entry.id);
                if (elapsedSpan) elapsedSpan.textContent = formatDuration(Math.floor(effective));
                // Update factor display as percentage
                const factorSpan = document.getElementById('runningFactor-' + entry.id);
                if (factorSpan) factorSpan.textContent = Math.round(factor * 100) + '%';
              });
            };
            tick();
            timerInterval = setInterval(tick, 1000);
          } else {
            // No running entries: hide running timer section and show start form
            runningDiv.style.display = 'none';
            runningDiv.innerHTML = '';
            startDiv.style.display = '';
          }
          // update project selects
          updateProjectSelects();
        }

        // Stop a single running timer by id
        function stopSingleTimer(entryId) {
          const toStop = data.entries.find(e => e.id === entryId && e.isRunning);
          if (!toStop) return;
          const now = new Date();
          // Gather all running entries including the one to stop
          const runningEntries = getRunningEntries();
          const n = runningEntries.length;
          // First update effective seconds for all running entries using their current factor
          runningEntries.forEach(e => {
            const last = e.lastUpdateTime ? new Date(e.lastUpdateTime) : new Date(e.startTime);
            const elapsedSec = (now - last) / 1000;
            const prevFactor = e.factor || computeConcurrencyFactor(n);
            e.effectiveSeconds = (e.effectiveSeconds || 0) + elapsedSec * prevFactor;
            e.lastUpdateTime = now.toISOString();
          });
          // Finalize the stopped entry
          const finalSeconds = toStop.effectiveSeconds || 0;
          toStop.endTime = now.toISOString();
          toStop.duration = Math.floor(finalSeconds);
          toStop.isRunning = false;
          // Cleanup weighted fields (optional)
          delete toStop.effectiveSeconds;
          delete toStop.lastUpdateTime;
          delete toStop.factor;
          // Compute new concurrency factor for remaining running timers after removal
          const remaining = runningEntries.filter(e => e.id !== entryId);
          const newCount = remaining.length;
          const newFactor = computeConcurrencyFactor(newCount);
          // Update remaining running entries: set new factor and lastUpdateTime
          remaining.forEach(e => {
            e.factor = newFactor;
            e.lastUpdateTime = now.toISOString();
          });
          // Persist and refresh
          saveData();
          updateTimerSection();
          updateDashboard();
          updateEntriesTable();
          // If auto sync is enabled, perform an immediate backup after stopping a timer
          if (autoSyncEnabled) {
            saveBackupToDir();
          }
          // If there are no more running timers after this stop, trigger focus stop hooks
          if (getRunningEntries().length === 0) {
            triggerFocusStop();
          }
        }
        let timerInterval = null;
        // Chart instances for weekly and monthly scatter plots
        let weeklyScatterChart = null;
        let monthlyScatterChart = null;
        document.getElementById('startTimerBtnPro').addEventListener('click', () => {
          const projectId = document.getElementById('timerProjectPro').value;
          // Hours already spent when starting the timer (pre-filled time)
          const initialHours = parseFloat(document.getElementById('timerInitialPro').value) || 0;
          if (!projectId) return;
          // Check if there's already a running timer for this project
          const runningEntries = getRunningEntries();
          // Prevent starting multiple timers for the same project. Compare string representations of IDs to avoid mismatches.
          if (runningEntries.some(e => String(e.projectId) === String(projectId))) {
            alert('A timer is already running for this project. You cannot start another timer for the same project.');
            return;
          }
          // Trigger focus start if no timers were running previously
          if (runningEntries.length === 0) {
            triggerFocusStart();
          }
          const now = new Date();
          // Update all existing running entries: accumulate effective seconds and set new factor
          const newConcurrencyCount = runningEntries.length + 1;
          const newFactor = computeConcurrencyFactor(newConcurrencyCount);
          runningEntries.forEach(e => {
            // Update effective seconds for elapsed time since last update
            const last = e.lastUpdateTime ? new Date(e.lastUpdateTime) : new Date(e.startTime);
            const elapsedSec = (now - last) / 1000;
            const prevFactor = e.factor || computeConcurrencyFactor(runningEntries.length);
            e.effectiveSeconds = (e.effectiveSeconds || 0) + elapsedSec * prevFactor;
            e.lastUpdateTime = now.toISOString();
            // Assign new factor for all running entries
            e.factor = newFactor;
          });
          // Create new entry for the selected project
          // Set real start time by subtracting initial hours so the start time reflects the past
          const realStart = new Date(now.getTime() - initialHours * 3600 * 1000);
          const newEntry = {
            id: uuid(),
            projectId,
            description: '',
            startTime: realStart.toISOString(),
            endTime: null,
            duration: null,
            isRunning: true,
            createdAt: now.toISOString(),
            // Track weighted timing fields
            effectiveSeconds: initialHours * 3600,
            lastUpdateTime: now.toISOString(),
            factor: newFactor
          };
          data.entries.push(newEntry);
          // Reset initial input
          document.getElementById('timerInitialPro').value = '';
          saveData();
          // Update selects so the started project is disabled
          updateProjectSelects();
          updateTimerSection();
          updateDashboard();
        });
        document.getElementById('stopTimerBtnPro').addEventListener('click', () => {
          stopAllTimers();
        });

        // Stop all running timers at once, updating their weighted durations consistently
        function stopAllTimers() {
          const runningList = getRunningEntries();
          if (runningList.length === 0) return;
          const now = new Date();
          const n = runningList.length;
          // Update effective seconds for all entries using their current factors
          runningList.forEach(e => {
            const last = e.lastUpdateTime ? new Date(e.lastUpdateTime) : new Date(e.startTime);
            const elapsedSec = (now - last) / 1000;
            const prevFactor = e.factor || computeConcurrencyFactor(n);
            e.effectiveSeconds = (e.effectiveSeconds || 0) + elapsedSec * prevFactor;
            e.lastUpdateTime = now.toISOString();
          });
          // Finalize each entry: set duration, endTime, isRunning
          runningList.forEach(e => {
            e.duration = Math.floor(e.effectiveSeconds || 0);
            e.endTime = now.toISOString();
            e.isRunning = false;
            delete e.effectiveSeconds;
            delete e.lastUpdateTime;
            delete e.factor;
          });
          saveData();
          updateTimerSection();
          updateDashboard();
          updateEntriesTable();
          // Immediate backup when stopping all timers if auto sync is enabled
          if (autoSyncEnabled) {
            saveBackupToDir();
          }
          // If there are no more running timers after this stop, trigger focus stop hooks
          if (getRunningEntries().length === 0) {
            triggerFocusStop();
          }
        }

        // Update project selects for timer and manual forms
        function updateProjectSelects() {
          const timerSelect = document.getElementById('timerProjectPro');
          const manualSelect = document.getElementById('manualProjectPro');
          timerSelect.innerHTML = '';
          manualSelect.innerHTML = '';
          if (data.projects.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = '-- no projects --';
            timerSelect.appendChild(opt);
            manualSelect.appendChild(opt.cloneNode(true));
            document.getElementById('startTimerBtnPro').disabled = true;
            return;
          }
          data.projects.forEach(project => {
            const o1 = document.createElement('option');
            o1.value = project.id;
            o1.textContent = project.name;
            timerSelect.appendChild(o1);
            const o2 = document.createElement('option');
            o2.value = project.id;
            o2.textContent = project.name;
            manualSelect.appendChild(o2);
          });
          // Disable timer options for projects that already have a running timer
          const runningProjects = getRunningEntries().map(e => e.projectId);
          timerSelect.querySelectorAll('option').forEach(opt => {
            const shouldDisable = runningProjects.some(id => String(id) === String(opt.value));
            opt.disabled = shouldDisable;
          });
          document.getElementById('startTimerBtnPro').disabled = false;
        }
        // Manual entry add/cancel
        document.getElementById('addManualEntryBtnPro').addEventListener('click', () => {
          document.getElementById('manualEntryFormPro').classList.remove('hidden');
        });
        document.getElementById('cancelManualBtnPro').addEventListener('click', () => {
          document.getElementById('manualEntryFormPro').classList.add('hidden');
          document.getElementById('manualFormPro').reset();
        });
        document.getElementById('manualFormPro').addEventListener('submit', (e) => {
          e.preventDefault();
          const projectId = document.getElementById('manualProjectPro').value;
          const description = document.getElementById('manualDescriptionPro').value.trim();
          const hoursVal = parseFloat(document.getElementById('manualHoursPro').value);
          if (!projectId || isNaN(hoursVal) || hoursVal <= 0) return;
          const now = new Date();
          const durationSeconds = Math.floor(hoursVal * 3600);
          // start time is computed as end time minus duration
          const startTime = new Date(now.getTime() - durationSeconds * 1000);
          const newEntry = {
            id: uuid(),
            projectId,
            description,
            startTime: startTime.toISOString(),
            endTime: now.toISOString(),
            duration: durationSeconds,
            isRunning: false,
            createdAt: now.toISOString()
          };
          data.entries.push(newEntry);
          saveData();
          e.target.reset();
          document.getElementById('manualEntryFormPro').classList.add('hidden');
          updateEntriesTable();
          updateDashboard();
          updateProjectsPage();
        });

        // Delete entry
        function deleteEntry(id) {
          data.entries = data.entries.filter(e => e.id !== id);
          saveData();
          updateEntriesTable();
          updateDashboard();
          updateProjectsPage();
        }

        // Entries table
        function updateEntriesTable() {
          const tbody = document.getElementById('entriesTableBodyPro');
          tbody.innerHTML = '';
          if (data.entries.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 7;
            td.textContent = 'No entries yet.';
            td.style.textAlign = 'center';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
          }
          // sort by start time desc
          const sorted = [...data.entries].sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
          sorted.forEach(entry => {
            const tr = document.createElement('tr');
            const project = data.projects.find(p => p.id === entry.projectId);
            const hours = entry.duration ? entry.duration / 3600 : 0;
            const total = project ? hours * project.hourlyRate : 0;
            tr.innerHTML = `
              <td>${project ? project.name : ''}</td>
              <td>${entry.description || ''}</td>
              <td>${formatDateTime(entry.startTime)}</td>
              <td>${entry.endTime ? formatDateTime(entry.endTime) : (entry.isRunning ? 'â€”' : '')}</td>
              <td>${entry.duration ? formatDuration(entry.duration) : (entry.isRunning ? 'Runningâ€¦' : '')}</td>
              <td>${formatCurrency(total)}</td>
              <td><button class="btn danger" data-id="${entry.id}" style="padding:0.25rem 0.5rem; font-size:0.75rem;">Delete</button></td>
            `;
            tr.querySelector('button').addEventListener('click', () => {
              if (confirm('Delete this entry?')) deleteEntry(entry.id);
            });
            tbody.appendChild(tr);
          });
        }

        // Export / Import
        document.getElementById('exportBtnPro').addEventListener('click', () => {
          // Use shared downloadData function for exports
          downloadData();
        });
        document.getElementById('importInputPro').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const text = await file.text();
          try {
            const imported = JSON.parse(text);
            if (!Array.isArray(imported.projects) || !Array.isArray(imported.entries)) {
              alert('Invalid data format');
              return;
            }
            data = imported;
            // Remove any transient timer fields (effectiveSeconds, lastUpdateTime, factor) from imported entries
            data.entries.forEach(entry => {
              delete entry.effectiveSeconds;
              delete entry.lastUpdateTime;
              delete entry.factor;
            });
            // Assign colors to projects without color and ensure uniqueness
            let colorChanged = false;
            data.projects.forEach(p => {
              if (!p.color) {
                p.color = getUniqueColor();
                colorChanged = true;
              }
            });
            if (colorChanged) {
              saveData();
            } else {
              // Save imported data even if colors did not change
              saveData();
            }
            // Refresh UI
            updateDashboard();
            updateProjectsPage();
            updateEntriesTable();
            updateTimerSection();
            alert('Data imported successfully');
          } catch (err) {
            alert('Failed to import: ' + err.message);
          }
        });

        // Initial render
        updateProjectSelects();
        updateEntriesTable();
        updateProjectsPage();
        updateDashboard();
        updateTimerSection();

        // Initialize auto sync toggle and status message
        const autoSyncToggle = document.getElementById('autoSyncToggle');
        const autoSyncStatusElem = document.getElementById('autoSyncStatus');
        function updateAutoSyncStatus() {
          if (!autoSyncStatusElem) return;
          if (autoSyncEnabled) {
            autoSyncStatusElem.textContent = 'Auto sync is ON. Data will be exported automatically.';
          } else {
            autoSyncStatusElem.textContent = 'Auto sync is OFF.';
          }
        }
        if (autoSyncToggle) {
          autoSyncToggle.checked = autoSyncEnabled;
          updateAutoSyncStatus();
          autoSyncToggle.addEventListener('change', () => {
            autoSyncEnabled = autoSyncToggle.checked;
            localStorage.setItem('autoSyncEnabledPro', autoSyncEnabled);
            updateAutoSyncStatus();
            // If user just enabled auto sync but no backup folder is set, prompt them to choose one.
            if (autoSyncEnabled && !backupDirHandle) {
              chooseBackupDir();
            }
          });
        }

        // Set Backup Folder button: prompts the user to pick a directory for backups. When
        // auto sync is enabled and no directory is selected, clicking this button
        // will call chooseBackupDir(). If auto sync is disabled, this button remains
        // functional to allow the user to preselect a folder before enabling auto sync.
        const chooseBtn = document.getElementById('chooseBackupDirBtn');
        if (chooseBtn) {
          chooseBtn.addEventListener('click', () => {
            chooseBackupDir();
          });
        }
      })();
    </script>
  </body>
</html>