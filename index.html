<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TimeKeeper Pro – Offline</title>
    <!-- Chart.js for graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="sidebar">
      <div class="logo">TimeTracker&nbsp;Pro</div>
      <ul id="navList">
        <!-- Set Dashboard tab without active class; we will programmatically activate the Timer tab on load -->
        <li data-section="dashboard" class="active">Dashboard</li>
        <li data-section="timer">Timer</li>
        <li data-section="projects">Projects</li>
        <li data-section="entries">Entries</li>
        <li data-section="importExport">Import/Export</li>
        <li data-section="analytics">Reports</li>
        <li data-section="todo">Todo</li>
      </ul>
    </div>
    <div class="content">
      <!-- Dashboard Section -->
      <section id="dashboard" class="section">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Dashboard</h2>
        <div class="stats-grid" id="statsGrid"></div>
        <div id="projectOverview"></div>
        <div id="detailedBreakdown"></div>

        <!-- Recommendations Section: dynamically populated with suggested projects to work on -->


        <!-- Scatter charts for project progress -->
        <div class="card" id="weeklyScatterCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Progress – Weekly (Expected vs Actual)</h3>
          <canvas id="weeklyScatter" height="200"></canvas>
        </div>
        <div class="card" id="monthlyScatterCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Progress – Monthly (Expected vs Actual)</h3>
          <canvas id="monthlyScatter" height="200"></canvas>
        </div>

        <!-- Daily Hours Heatmap -->
        <div class="card" id="heatmapCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Daily Hours Heatmap</h3>
          <div id="heatmap" style="overflow-x:auto;"></div>
        </div>
        <!-- Project Burndown Chart -->
        <div class="card" id="burndownCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Burndown</h3>
          <div style="margin-bottom:0.5rem;">
            <label for="burndownProjectSelect" style="font-size:0.9rem; font-weight:500;">Select Project:</label>
            <select id="burndownProjectSelect" style="margin-left:0.5rem; padding:0.25rem; border:1px solid #cbd5e1; border-radius:0.375rem;"></select>
          </div>
          <canvas id="burndownChart" height="200"></canvas>
        </div>
      </section>
      <!-- Timer Section -->
      <section id="timer" class="section">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Timer</h2>
        <div id="runningTimerPro" class="card" style="display:none;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Running Timer</h3>
          <p><strong>Project:</strong> <span id="runningProjectNamePro"></span></p>
          <p><strong>Started:</strong> <span id="runningStartTimePro"></span></p>
          <p><strong>Elapsed:</strong> <span id="runningElapsedPro"></span></p>
          <button id="stopTimerBtnPro" class="btn danger">Stop</button>
        </div>
        <div id="startTimerPro" class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Start Timer</h3>
          <label for="timerProjectPro" style="margin-bottom:0.25rem; font-weight:500;">Project</label>
          <select id="timerProjectPro" style="padding:0.5rem; margin-bottom:0.5rem; width:100%; border:1px solid #cbd5e1; border-radius:0.375rem;"></select>
          <label for="timerInitialPro" style="margin-bottom:0.25rem; font-weight:500;">Hours already spent (optional)</label>
          <input id="timerInitialPro" type="number" min="0" step="0.1" style="padding:0.5rem; margin-bottom:0.5rem; width:100%; border:1px solid #cbd5e1; border-radius:0.375rem;" placeholder="e.g. 0.5" />
          <!-- Allow the user to choose the initial focus factor when starting a timer -->
          <label for="startFactorPro" style="margin-bottom:0.25rem; font-weight:500;">Focus factor</label>
          <select id="startFactorPro" style="padding:0.5rem; margin-bottom:0.5rem; width:100%; border:1px solid #cbd5e1; border-radius:0.375rem;">
            <option value="">Auto</option>
            <option value="1">100%</option>
            <option value="0.75">75%</option>
            <option value="0.5">50%</option>
            <option value="0.25">25%</option>
          </select>
          <button id="startTimerBtnPro" class="btn primary" disabled style="padding:0.75rem 1.5rem; font-size:1rem;">Start</button>
        </div>
      </section>
      <!-- Projects Section -->
      <section id="projects" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Projects</h2>
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">New Project</h3>
          <form id="projectFormPro" style="display:flex; flex-direction:column; gap:0.5rem;">
            <label for="projectNamePro" style="font-weight:500;">Project Name</label>
            <input id="projectNamePro" type="text" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectClientPro" style="font-weight:500;">Client (optional)</label>
            <input id="projectClientPro" type="text" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectBudgetPro" style="font-weight:500;">Budget Hours</label>
            <input id="projectBudgetPro" type="number" min="0" step="0.1" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectRatePro" style="font-weight:500;">Hourly Rate</label>
            <input id="projectRatePro" type="number" min="0" step="0.01" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />

            <!-- Rounding selection: allow user to choose rounding interval for entries in minutes -->
            <label for="projectRoundingPro" style="font-weight:500;">Rounding (minutes)</label>
            <select id="projectRoundingPro" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;">
              <option value="0">None</option>
              <option value="5">5</option>
              <option value="10">10</option>
              <option value="15">15</option>
            </select>
            <label for="projectDeadlinePro" style="font-weight:500;">Deadline</label>
            <input id="projectDeadlinePro" type="date" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <button type="submit" class="btn primary" style="align-self:flex-start;">Add Project</button>
          </form>
        </div>
        <div id="projectsPageList"></div>
      </section>
      <!-- Entries Section -->
      <section id="entries" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Time Entries</h2>
        <div class="card">
          <div style="margin-bottom:0.5rem; display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; font-size:1.1rem; font-weight:600;">Entries</h3>
            <div style="display:flex; gap:0.5rem;">
              <button id="addManualEntryBtnPro" class="btn secondary">Add Manual Entry</button>
              <!-- Toggle button to switch between showing recent entries and all entries -->
              <button id="toggleEntriesViewBtn" class="btn secondary">Show Recent</button>
            </div>
          </div>
          <div id="manualEntryFormPro" class="hidden" style="margin-top:1rem;">
            <h4 style="margin:0 0 0.5rem 0; font-size:1rem; font-weight:600;">New Manual Entry</h4>
            <form id="manualFormPro" style="display:flex; flex-direction:column; gap:0.5rem;">
              <label for="manualProjectPro" style="font-weight:500;">Project</label>
              <select id="manualProjectPro" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;"></select>
              <label for="manualDescriptionPro" style="font-weight:500;">Description (optional)</label>
              <input id="manualDescriptionPro" type="text" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
              <label for="manualHoursPro" style="font-weight:500;">Hours</label>
              <!-- Hours input with nudge buttons for ±5 minutes -->
              <div style="display:flex; align-items:center; gap:0.5rem;">
                <input id="manualHoursPro" type="number" min="0" step="0.1" style="flex:1; padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" placeholder="e.g. 2" />
                <button type="button" id="manualMinus5Btn" class="btn secondary" style="padding:0.25rem 0.5rem; font-size:0.75rem;">-5m</button>
                <button type="button" id="manualPlus5Btn" class="btn secondary" style="padding:0.25rem 0.5rem; font-size:0.75rem;">+5m</button>
              </div>
              <button type="submit" class="btn primary" style="align-self:flex-start;">Save Entry</button>
              <button type="button" id="cancelManualBtnPro" class="btn secondary" style="align-self:flex-start;">Cancel</button>
            </form>
          </div>
          <div style="overflow-x:auto;">
            <table>
              <thead>
                <tr>
                  <th>Project</th>
                  <th>Description</th>
                  <th>Start</th>
                  <th>End</th>
                  <th>Duration</th>
                  <th>Total</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="entriesTableBodyPro"></tbody>
            </table>
          </div>
        </div>
      </section>
      <!-- Import/Export Section -->
      <section id="importExport" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Import / Export</h2>
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Export Data</h3>
          <button id="exportBtnPro" class="btn primary">Export JSON</button>
        </div>
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Import Data</h3>
          <input id="importInputPro" type="file" accept="application/json" />
        </div>

        <!-- Auto Sync card: allows toggling automatic periodic export of data -->
        <div class="card" style="margin-top:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Auto Data Sync</h3>
          <label style="display:flex; align-items:center; gap:0.5rem; cursor:pointer;">
            <input type="checkbox" id="autoSyncToggle" />
            <span>Enable auto sync to local file</span>
          </label>
          <p id="autoSyncStatus" style="font-size:0.8rem; color:#64748b; margin-top:0.5rem;"></p>
        <!-- Button to choose backup directory when enabling auto sync -->
        <button id="chooseBackupDirBtn" class="btn secondary" style="margin-top:0.5rem;">Set Backup Folder</button>
        </div>
      </section>

      <!-- Todo Section -->
      <section id="todo" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Todo</h2>
        <!-- Form to add new todo item -->
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Add Task</h3>
          <form id="todoForm" style="display:flex; gap:0.5rem; flex-wrap:wrap;">
            <input id="todoName" type="text" required placeholder="Task name" style="flex:1; padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <button type="submit" class="btn primary">Add</button>
          </form>
        </div>
        <!-- List of tasks -->
        <div class="card" id="todoListContainer">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Tasks</h3>
          <ul id="todoList" style="list-style:none; padding:0; margin:0;"></ul>
        </div>
      </section>

      <!-- Analytics/Reports Section -->
      <section id="analytics" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Reports</h2>
        <!-- Heatmap card -->
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Monthly Heatmap</h3>
          <div id="heatmapContainer"></div>
        </div>
        <!-- Burndown charts card -->
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Burndown Charts</h3>
          <div id="burndownContainer"></div>
        </div>
        <!-- Hours by Project bar chart -->
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Hours by Project (Month)</h3>
          <canvas id="hoursByProjectChart" height="200"></canvas>
        </div>
      </section>
    </div>
    <script>
      (function() {
        // Simple UUID generator
        function uuid() {
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
          });
        }
        // Load and save data
        function loadData() {
          const raw = localStorage.getItem('timekeeperDataPro');
          if (!raw) return { projects: [], entries: [], todos: [] };
          try {
            const parsed = JSON.parse(raw);
            return {
              projects: Array.isArray(parsed.projects) ? parsed.projects : [],
              entries: Array.isArray(parsed.entries) ? parsed.entries : [],
              todos: Array.isArray(parsed.todos) ? parsed.todos : [],
              // Preserve additional persisted properties like backupDirName if present in saved data
              backupDirName: parsed.backupDirName || null
            };
          } catch (err) {
            return { projects: [], entries: [], todos: [], backupDirName: null };
          }
        }
        function saveData() {
          localStorage.setItem('timekeeperDataPro', JSON.stringify(data));
          // Mark data as needing backup
          needsBackup = true;
        }

        // Compute concurrency factor based on the number of active timers.
        // Factor decreases as more timers run simultaneously: for example, 1 timer=1.0, 2 timers=0.75, 3 timers=0.6.
        function computeConcurrencyFactor(n) {
          if (n <= 1) return 1;
          return 1 / (1 + (n - 1) / 3);
        }
        let data = loadData();
        // Initialize backup and sync flags before they are referenced in saveData().
        // needsBackup tracks whether the data has changed and needs to be exported.
        // autoSyncEnabled indicates whether automatic export is enabled.
        // backupDirHandle holds the selected directory for backups via the File System Access API.
        let needsBackup = false;
        let autoSyncEnabled = false;
        let backupDirHandle = null;
        // Flag to track whether to show all entries or only recent ones. If false,
        // entries older than approximately one month are hidden by default to keep
        // the list manageable. This can be toggled via a button in the Entries section.
        let showAllEntries = false;

        // -------------------------------------------------------------------------
        //  Haptic feedback and simple audio cues
        //
        //  provideHaptic() triggers vibration on devices that support the
        //  Vibration API. If a 'beep' type is requested, it plays a short tone via
        //  the Web Audio API. These feedback cues enhance the feeling of
        //  interaction when starting/stopping timers or adjusting entry durations.
        function provideHaptic(type) {
          // Trigger a short vibration where supported
          if (navigator && 'vibrate' in navigator) {
            if (type === 'long') navigator.vibrate([50, 50, 50]);
            else navigator.vibrate(40);
          }
          // Play a simple beep for auditory feedback
          if (type === 'beep') {
            try {
              if (!window._beepAudioCtx) {
                window._beepAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
              }
              const ctx = window._beepAudioCtx;
              const osc = ctx.createOscillator();
              osc.type = 'sine';
              osc.frequency.value = 440;
              osc.connect(ctx.destination);
              osc.start();
              osc.stop(ctx.currentTime + 0.05);
            } catch (err) {
              // Audio may fail if the page is not interacted with yet
            }
          }
        }

        // -------------------------------------------------------------------------
        //  IndexedDB persistence for backup directory handle
        //
        //  Persisting the selected backup folder across sessions requires storing
        //  the FileSystemDirectoryHandle in IndexedDB. Handles are structured
        //  cloneable and can be retrieved on subsequent page loads. These
        //  functions abstract opening the database, saving the handle, and
        //  retrieving it when the page initializes.
        function openHandleDB() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open('timekeeper-db', 1);
            request.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains('handles')) {
                db.createObjectStore('handles');
              }
            };
            request.onsuccess = (e) => resolve(e.target.result);
            request.onerror = (e) => reject(e.target.error);
          });
        }
        async function saveBackupDirHandle(handle) {
          try {
            const db = await openHandleDB();
            const tx = db.transaction('handles', 'readwrite');
            tx.objectStore('handles').put(handle, 'backupDir');
            return tx.complete;
          } catch (err) {
            console.error('Error saving backup handle:', err);
          }
        }
        async function loadBackupDirHandle() {
          try {
            const db = await openHandleDB();
            return await new Promise((resolve) => {
              const tx = db.transaction('handles', 'readonly');
              const getReq = tx.objectStore('handles').get('backupDir');
              getReq.onsuccess = () => resolve(getReq.result || null);
              getReq.onerror = () => resolve(null);
            });
          } catch (err) {
            return null;
          }
        }
        // Reset todo checkboxes each Monday. If the stored reset date is not for the current Monday,
        // mark all tasks as unchecked and update the reset date in localStorage. This ensures
        // todos remain persistent week-to-week but are reset at the start of each new week.
        function resetTodosIfNeeded() {
          const today = new Date();
          // Determine the Monday of this week
          const monday = new Date(today);
          const dow = monday.getDay();
          const diffToMonday = (dow + 6) % 7;
          monday.setDate(monday.getDate() - diffToMonday);
          const mondayStr = monday.toDateString();
          const lastReset = localStorage.getItem('todoResetDatePro');
          if (lastReset !== mondayStr) {
            // Reset checked state on all todos
            if (Array.isArray(data.todos)) {
              data.todos.forEach(t => {
                t.checked = false;
              });
            }
            localStorage.setItem('todoResetDatePro', mondayStr);
            saveData();
          }
        }
        // Perform initial todo reset check
        resetTodosIfNeeded();
        // Ensure every project has a color and that colors are unique when possible.
        (function assignProjectColors() {
          const used = new Set();
          let assigned = false;
          data.projects.forEach(p => {
            // If project has a color but it has already been used by a previous project, treat as missing
            if (!p.color || used.has(p.color)) {
              p.color = getUniqueColor();
              assigned = true;
            }
            used.add(p.color);
          });
          if (assigned) {
            saveData();
          }
        })();
        // Global variables to track recommended projects (by id)
        let currentRecommendedWeeklyId = null;
        let currentRecommendedMonthlyId = null;
        // Load persisted auto sync preference
        const autoSyncPref = localStorage.getItem('autoSyncEnabledPro');
        if (autoSyncPref !== null) {
          autoSyncEnabled = autoSyncPref === 'true';
        }

        // Attempt to restore the backup directory handle from IndexedDB on load. If
        // a handle exists, assign it to the global backupDirHandle so that auto
        // sync can operate without requiring the user to pick a folder each
        // time the page loads.
        loadBackupDirHandle().then(handle => {
          // If a handle was previously saved, restore it.
          if (handle) {
            backupDirHandle = handle;
          }
          // Update auto sync status now that we know whether a backup folder is set.
          if (typeof updateAutoSyncStatus === 'function') {
            updateAutoSyncStatus();
          }
          // After restoring the backup directory, determine if focus blocker should be active.
          updateFocusBlocker();
        });

        // -------------------------------------------------------------------------
        //  Webhook support and Todo functionality
        //
        //  These constants define the webhook endpoints that should be called when
        //  timers start and stop. They are used to toggle focus modes on the user's
        //  Android and Windows devices. When the first timer starts, the start
        //  webhooks are invoked; when all timers stop, the stop webhooks are invoked.
        const START_WEBHOOKS = ['http://127.0.0.1:8766/focus/start'];
        const STOP_WEBHOOKS = ['http://127.0.0.1:8766/focus/stop'];

        // Send a ping to each URL in the list. Uses navigator.sendBeacon where
        // available to avoid blocking the page; falls back to fetch otherwise.
        function triggerWebhooks(urls) {
          urls.forEach(u => {
            try {
              navigator.sendBeacon(u);
            } catch (err) {
              // sendBeacon may not support GET-only endpoints; fallback to fetch
              fetch(u, { method: 'GET', mode: 'no-cors' }).catch(() => {});
            }
          });
        }

        // Convenience wrappers to trigger start/stop webhooks.
        function triggerFocusStart() {
          triggerWebhooks(START_WEBHOOKS);
        }
        function triggerFocusStop() {
          triggerWebhooks(STOP_WEBHOOKS);
        }

        // Track whether the focus blocker (external MacroDroid/Windows scripts) is currently active.
        // The blocker should only be enabled when the sum of all running timer factors exceeds 0.5.
        let focusBlockerActive = false;
        function updateFocusBlocker() {
          // Sum the factors of all running timers. Use the factor property; if undefined, compute concurrency factor.
          const running = getRunningEntries();
          let total = 0;
          running.forEach(e => {
            total += e.factor || computeConcurrencyFactor(running.length);
          });
          // Activate blocker if we cross the 50% threshold, deactivate if we drop below or equal
          if (!focusBlockerActive && total > 0.5) {
            focusBlockerActive = true;
            triggerFocusStart();
          } else if (focusBlockerActive && total <= 0.5) {
            focusBlockerActive = false;
            triggerFocusStop();
          }
        }

        // Update the Todo section UI based on the current data.todos array. Each
        // todo displays a checkbox reflecting its checked state and a delete
        // button. Changing the checkbox updates the corresponding task and
        // persists to localStorage.
        function updateTodoSection() {
          const listEl = document.getElementById('todoList');
          if (!listEl) return;
          listEl.innerHTML = '';
          const todos = Array.isArray(data.todos) ? data.todos : [];
          todos.forEach((todo, index) => {
            const li = document.createElement('li');
            li.style.display = 'flex';
            li.style.alignItems = 'center';
            li.style.justifyContent = 'space-between';
            li.style.padding = '0.25rem 0';
            // Label containing checkbox and name
            const label = document.createElement('label');
            label.style.display = 'flex';
            label.style.alignItems = 'center';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = !!todo.checked;
            checkbox.addEventListener('change', () => {
              todo.checked = checkbox.checked;
              saveData();
            });
            const span = document.createElement('span');
            span.textContent = todo.name || '';
            span.style.marginLeft = '0.5rem';
            label.appendChild(checkbox);
            label.appendChild(span);
            li.appendChild(label);
            // Delete button to remove the task
            const delBtn = document.createElement('button');
            delBtn.className = 'btn danger';
            delBtn.textContent = 'Delete';
            delBtn.style.fontSize = '0.7rem';
            delBtn.addEventListener('click', () => {
              // Remove the todo at this index and re-render
              data.todos.splice(index, 1);
              saveData();
              updateTodoSection();
            });
            li.appendChild(delBtn);
            listEl.appendChild(li);
          });
        }

        // Attach submit handler to the Todo form. When submitted, a new task is
        // added to data.todos with a unique ID. The list is then re-rendered.
        const todoForm = document.getElementById('todoForm');
        if (todoForm) {
          todoForm.addEventListener('submit', e => {
            e.preventDefault();
            const nameInput = document.getElementById('todoName');
            const name = nameInput.value.trim();
            if (!name) return;
            if (!Array.isArray(data.todos)) {
              data.todos = [];
            }
            data.todos.push({ id: uuid(), name: name, checked: false });
            saveData();
            updateTodoSection();
            nameInput.value = '';
          });
        }

        // Render the todo list once on load so that tasks persist across
        // navigation between sections.
        updateTodoSection();

        // Render reports section including monthly heatmap and per-project burndown charts. This
        // function is called whenever navigating to the Reports section or when data is
        // updated (e.g., after modifying entries). It recomputes the heatmap for the
        // current month and builds burndown charts for each project using Chart.js.
        let burndownCharts = {};
        function updateAnalyticsSection() {
          const heatmapContainer = document.getElementById('heatmapContainer');
          const burndownContainer = document.getElementById('burndownContainer');
          if (!heatmapContainer || !burndownContainer) return;
          // Clear previous contents
          heatmapContainer.innerHTML = '';
          burndownContainer.innerHTML = '';
          // ---------- Build monthly heatmap ----------
          // Determine the start and end of the current month
          const now = new Date();
          const year = now.getFullYear();
          const month = now.getMonth();
          const firstDay = new Date(year, month, 1);
          const lastDay = new Date(year, month + 1, 0);
          const daysInMonth = lastDay.getDate();
          // Accumulate hours per day
          const hoursPerDay = {};
          // Initialize to zero for each day of month
          for (let d = 1; d <= daysInMonth; d++) {
            hoursPerDay[d] = 0;
          }
          data.entries.forEach(entry => {
            if (entry.isRunning || !entry.duration) return;
            const start = new Date(entry.startTime);
            if (start.getFullYear() === year && start.getMonth() === month) {
              const day = start.getDate();
              hoursPerDay[day] = (hoursPerDay[day] || 0) + entry.duration / 3600;
            }
          });
          // Compute maximum hours for scaling colors
          let maxHours = 0;
          Object.values(hoursPerDay).forEach(h => { if (h > maxHours) maxHours = h; });
          // Build a 7-column table starting on Monday (0=Monday). We will map JS getDay (0=Sunday) to Monday start.
          const heatmapTable = document.createElement('table');
          heatmapTable.style.width = '100%';
          heatmapTable.style.borderCollapse = 'collapse';
          const headerRow = document.createElement('tr');
          ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'].forEach(dName => {
            const th = document.createElement('th');
            th.textContent = dName;
            th.style.textAlign = 'center';
            th.style.padding = '0.25rem';
            th.style.fontSize = '0.75rem';
            headerRow.appendChild(th);
          });
          heatmapTable.appendChild(headerRow);
          // Determine the weekday index of the first day (0=Monday, 6=Sunday)
          const firstDow = (firstDay.getDay() + 6) % 7;
          let currentDay = 1;
          // We'll build up to 6 rows to cover all days
          for (let week = 0; week < 6; week++) {
            const tr = document.createElement('tr');
            for (let dow = 0; dow < 7; dow++) {
              const td = document.createElement('td');
              td.style.border = '1px solid #e2e8f0';
              td.style.height = '1.5rem';
              td.style.textAlign = 'center';
              td.style.fontSize = '0.7rem';
              // Determine if this cell corresponds to a valid day
              const cellIndex = week * 7 + dow;
              if (cellIndex >= firstDow && currentDay <= daysInMonth) {
                const dayNum = currentDay;
                const hours = hoursPerDay[dayNum] || 0;
                // Colour intensity based on hours
                let alpha;
                if (maxHours > 0) {
                  alpha = 0.1 + 0.8 * (hours / maxHours);
                } else {
                  alpha = 0;
                }
                td.style.backgroundColor = `rgba(59, 130, 246, ${alpha.toFixed(2)})`;
                // Display day number and hours (optional)
                const spanDay = document.createElement('div');
                spanDay.textContent = dayNum.toString();
                spanDay.style.fontWeight = '600';
                const spanHrs = document.createElement('div');
                spanHrs.textContent = hours > 0 ? hours.toFixed(1) + 'h' : '';
                spanHrs.style.fontSize = '0.6rem';
                td.appendChild(spanDay);
                td.appendChild(spanHrs);
                currentDay++;
              } else {
                td.textContent = '';
              }
              tr.appendChild(td);
            }
            heatmapTable.appendChild(tr);
            if (currentDay > daysInMonth) break;
          }
          heatmapContainer.appendChild(heatmapTable);
          // ---------- Build hours by project bar chart ----------
          // Compute total hours worked per project in the current month
          const barLabels = [];
          const barHours = [];
          const barTargets = [];
          data.projects.forEach(project => {
            const sp = computeProjectStats(project);
            barLabels.push(project.name);
            // Use monthlyHours for actual and monthlyTargetConst for target
            barHours.push(sp.monthlyHours || 0);
            barTargets.push(sp.monthlyTargetConst || 0);
          });
          if (barLabels.length > 0) {
            const barCard = document.createElement('div');
            barCard.style.marginBottom = '1rem';
            const barTitle = document.createElement('h3');
            barTitle.style.margin = '0 0 0.5rem 0';
            barTitle.style.fontSize = '1.1rem';
            barTitle.style.fontWeight = '600';
            barTitle.textContent = 'Hours by Project (This Month)';
            barCard.appendChild(barTitle);
            const barCanvas = document.createElement('canvas');
            barCanvas.height = 200;
            barCard.appendChild(barCanvas);
            heatmapContainer.appendChild(barCard);
            const ctxBar = barCanvas.getContext('2d');
            new Chart(ctxBar, {
              type: 'bar',
              data: {
                labels: barLabels,
                datasets: [
                  {
                    label: 'Hours Worked',
                    data: barHours,
                    backgroundColor: '#3b82f6',
                    borderColor: '#3b82f6',
                    borderWidth: 1
                  },
                  {
                    label: 'Target Hours',
                    data: barTargets,
                    backgroundColor: '#94a3b8',
                    borderColor: '#94a3b8',
                    borderWidth: 1
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: { display: false },
                    ticks: { autoSkip: false }
                  },
                  y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Hours' }
                  }
                },
                plugins: { legend: { display: true } }
              }
            });
          }

          // ---------- Build daily hours line chart for the current month ----------
          // This chart shows how many hours were worked each day of the current month and compares to the
          // average daily target (monthlyTargetConst / daysInMonth) aggregated across all projects.
          // Compute daily hours across all projects
          const dailyLabels = [];
          const dailyHoursData = [];
          const dailyTargetData = [];
          for (let d = 1; d <= daysInMonth; d++) {
            dailyLabels.push(d.toString());
            dailyHoursData.push(hoursPerDay[d] || 0);
            // Sum monthly targets for all projects to compute aggregate monthly target and then average per day
            const dayTarget = data.projects.reduce((sum, proj) => {
              const ps = computeProjectStats(proj);
              return sum + (ps.monthlyTargetConst || 0);
            }, 0) / daysInMonth;
            dailyTargetData.push(dayTarget);
          }
          // Only render chart if there is at least one project
          if (dailyLabels.length > 0 && data.projects.length > 0) {
            const lineCard = document.createElement('div');
            lineCard.style.marginBottom = '1rem';
            const lineTitle = document.createElement('h3');
            lineTitle.style.margin = '0 0 0.5rem 0';
            lineTitle.style.fontSize = '1.1rem';
            lineTitle.style.fontWeight = '600';
            lineTitle.textContent = 'Daily Hours Trend (This Month)';
            lineCard.appendChild(lineTitle);
            const lineCanvas = document.createElement('canvas');
            lineCanvas.height = 200;
            lineCard.appendChild(lineCanvas);
            heatmapContainer.appendChild(lineCard);
            const ctxLine = lineCanvas.getContext('2d');
            new Chart(ctxLine, {
              type: 'line',
              data: {
                labels: dailyLabels,
                datasets: [
                  {
                    label: 'Hours Worked',
                    data: dailyHoursData,
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59,130,246,0.3)',
                    fill: false,
                    tension: 0.1
                  },
                  {
                    label: 'Daily Target (avg)',
                    data: dailyTargetData,
                    borderColor: '#999999',
                    backgroundColor: 'rgba(153,153,153,0.3)',
                    borderDash: [5,5],
                    fill: false,
                    tension: 0.1
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: { title: { display: true, text: 'Day of Month' }, ticks: { autoSkip: false } },
                  y: { beginAtZero: true, title: { display: true, text: 'Hours' } }
                },
                plugins: { legend: { display: true }, tooltip: { mode: 'index', intersect: false } }
              }
            });
          }
          // ---------- Build per-project burndown charts ----------
          // Destroy existing charts to prevent memory leaks
          Object.values(burndownCharts).forEach(ch => {
            if (ch && typeof ch.destroy === 'function') ch.destroy();
          });
          burndownCharts = {};
          data.projects.forEach(project => {
            // Compute daily cumulative hours from project creation to now
            const createdAt = new Date(project.createdAt);
            const deadline = new Date(project.deadline);
            const today = new Date();
            // Determine end date for chart: use min(today, deadline)
            const endDate = today < deadline ? today : deadline;
            // Build date labels and cumulative actual hours and expected hours arrays
            const labels = [];
            const actualData = [];
            const expectedData = [];
            const totalDays = Math.ceil((endDate - createdAt) / (1000 * 60 * 60 * 24)) || 1;
            // Create a map of cumulative hours keyed by date string
            const dailyHoursMap = {};
            data.entries.forEach(entry => {
              if (entry.isRunning || !entry.duration) return;
              if (entry.projectId !== project.id) return;
              const start = new Date(entry.startTime);
              const dateStr = start.toISOString().split('T')[0];
              dailyHoursMap[dateStr] = (dailyHoursMap[dateStr] || 0) + entry.duration / 3600;
            });
            let cumulative = 0;
            for (let i = 0; i < totalDays; i++) {
              const date = new Date(createdAt.getTime());
              date.setDate(createdAt.getDate() + i);
              const dateStr = date.toISOString().split('T')[0];
              labels.push(dateStr);
              cumulative += dailyHoursMap[dateStr] || 0;
              actualData.push(cumulative);
              // Expected cumulative: linear expected burn from 0 to budget hours over total days
              expectedData.push((project.budgetHours / totalDays) * (i + 1));
            }
            // Build canvas
            const projectCard = document.createElement('div');
            projectCard.style.marginBottom = '1rem';
            const h4 = document.createElement('h4');
            h4.style.margin = '0 0 0.5rem 0';
            h4.style.fontSize = '1rem';
            h4.style.fontWeight = '600';
            h4.textContent = project.name;
            projectCard.appendChild(h4);
            const canvas = document.createElement('canvas');
            canvas.height = 150;
            projectCard.appendChild(canvas);
            burndownContainer.appendChild(projectCard);
            // Create Chart.js line chart
            const ctx = canvas.getContext('2d');
            burndownCharts[project.id] = new Chart(ctx, {
              type: 'line',
              data: {
                labels: labels,
                datasets: [
                  {
                    label: 'Cumulative Hours',
                    data: actualData,
                    borderColor: project.color || '#3b82f6',
                    backgroundColor: 'rgba(59,130,246,0.3)',
                    fill: false,
                    tension: 0.1
                  },
                  {
                    label: 'Expected Hours',
                    data: expectedData,
                    borderColor: '#999999',
                    backgroundColor: 'rgba(153,153,153,0.3)',
                    fill: false,
                    borderDash: [5,5],
                    tension: 0.1
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: { display: true, text: 'Date' },
                    ticks: { maxRotation: 90, minRotation: 45 }
                  },
                  y: {
                    title: { display: true, text: 'Hours' },
                    beginAtZero: true
                  }
                },
                plugins: {
                  legend: { display: true },
                  tooltip: { enabled: true }
                }
              }
            });
          });

          // ---------- Build Hours by Project bar chart ----------
          const hoursCanvas = document.getElementById('hoursByProjectChart');
          if (hoursCanvas) {
            // Destroy existing chart if present
            if (window.hoursByProjectChart) {
              try { window.hoursByProjectChart.destroy(); } catch (err) {}
            }
            const labels = [];
            const workedData = [];
            const targetData = [];
            data.projects.forEach(project => {
              const sp = computeProjectStats(project);
              labels.push(project.name);
              // Hours worked this month
              workedData.push(sp.monthlyHours || 0);
              // Dynamic monthly target
              targetData.push(sp.monthlyTargetConst || 0);
            });
            const ctxHours = hoursCanvas.getContext('2d');
            window.hoursByProjectChart = new Chart(ctxHours, {
              type: 'bar',
              data: {
                labels: labels,
                datasets: [
                  {
                    label: 'Hours Worked',
                    data: workedData,
                    backgroundColor: 'rgba(59,130,246,0.6)',
                    borderColor: '#3b82f6',
                    borderWidth: 1
                  },
                  {
                    label: 'Target Hours',
                    data: targetData,
                    backgroundColor: 'rgba(203,213,224,0.6)',
                    borderColor: '#94a3b8',
                    borderWidth: 1
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: { title: { display: true, text: 'Project' } },
                  y: { title: { display: true, text: 'Hours' }, beginAtZero: true }
                },
                plugins: {
                  legend: { display: true },
                  tooltip: { enabled: true }
                }
              }
            });
          }
        }

        // Download the current data to a JSON file. Uses the same filename
        // each time so the browser can overwrite older backups.
        function downloadData() {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'timekeeper-offline-data.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        // Save the current data to the user-selected backup directory. If no directory
        // has been chosen yet, this function silently does nothing. When called,
        // it writes the entire data object to a file named `timekeeper-data.json` in
        // the chosen folder using the File System Access API.
        async function saveBackupToDir() {
          try {
            if (!backupDirHandle) return;
            // Ensure we have permission to write to the directory. If not granted, abort silently.
            try {
              const perm = await backupDirHandle.requestPermission({ mode: 'readwrite' });
              if (perm !== 'granted') return;
            } catch (err) {
              // If requestPermission fails (not supported), we proceed and hope existing permission works
            }
            // Create or overwrite a file named timekeeper-data.json in the selected directory
            const fileHandle = await backupDirHandle.getFileHandle('timekeeper-data.json', { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(JSON.stringify(data, null, 2));
            await writable.close();
            // After successful backup, clear the needsBackup flag
            needsBackup = false;
          } catch (err) {
            console.error('Saving backup failed:', err);
          }
        }

        // Prompt the user to choose a backup directory using the File System Access API. When
        // the directory is selected, set it as the backupDirHandle and enable auto sync.
        async function chooseBackupDir() {
          try {
            const dirHandle = await window.showDirectoryPicker();
            backupDirHandle = dirHandle;
            // Persist the directory handle in IndexedDB so it can be restored on future visits
            await saveBackupDirHandle(dirHandle);
            // Save the directory name into our data so that it persists in JSON exports. This allows
            // us to remember which folder was chosen even when a handle cannot be restored.
            data.backupDirName = dirHandle.name;
            saveData();
            // Enable auto sync once a folder is chosen
            autoSyncEnabled = true;
            localStorage.setItem('autoSyncEnabledPro', 'true');
            // Reflect UI state if toggle exists
            const toggle = document.getElementById('autoSyncToggle');
            if (toggle) toggle.checked = true;
            updateAutoSyncStatus();
            // Immediately save a backup now that the directory is chosen
            await saveBackupToDir();
          } catch (err) {
            console.error('Backup folder not selected:', err);
          }
        }

        // Periodically export data if there have been changes.
        // Runs every 10 minutes (600000 ms). Adjust interval as needed.
        setInterval(() => {
          // Only perform automatic backups when auto sync is enabled. When a backup directory
          // is selected, data will be written to the file; otherwise, nothing happens.
          if (autoSyncEnabled && needsBackup) {
            saveBackupToDir().catch(err => {
              console.error('Auto backup failed:', err);
            });
          }
        }, 600000);

        // Navigation
        const navList = document.getElementById('navList');
        navList.querySelectorAll('li').forEach(li => {
          li.addEventListener('click', () => {
            navList.querySelectorAll('li').forEach(item => item.classList.remove('active'));
            li.classList.add('active');
            const sectionId = li.getAttribute('data-section');
            document.querySelectorAll('.section').forEach(sec => {
              sec.style.display = 'none';
            });
            document.getElementById(sectionId).style.display = 'block';
            // update content if needed
            if (sectionId === 'dashboard') {
              updateDashboard();
            } else if (sectionId === 'projects') {
              updateProjectsPage();
            } else if (sectionId === 'entries') {
              updateEntriesTable();
            } else if (sectionId === 'timer') {
              updateTimerSection();
            } else if (sectionId === 'todo') {
              updateTodoSection();
            } else if (sectionId === 'analytics') {
              updateAnalyticsSection();
            }
          });
        });

        // Helper functions for formatting
        function formatDateTime(dateStr) {
          const dt = new Date(dateStr);
          return isNaN(dt) ? '' : dt.toLocaleString();
        }
        function formatDate(dateStr) {
          const dt = new Date(dateStr);
          return isNaN(dt) ? '' : dt.toLocaleDateString();
        }
        function formatCurrency(num, decimals = 1) {
          // Format currency as Swedish Krona (kr). Allows rounding to positive or
          // negative decimal places. A negative decimal value rounds to tens,
          // hundreds, etc. For example, decimals = -1 rounds to the nearest 10,
          // decimals = -2 rounds to the nearest 100. When decimals >= 0, round
          // normally and include that many decimal places. When decimals < 0,
          // round to the specified magnitude and show no decimals. If num is
          // not finite, return an empty string.
          if (!isFinite(num)) return '';
          let rounded;
          if (decimals >= 0) {
            // Round to specified fractional places
            const factor = Math.pow(10, decimals);
            rounded = Math.round(num * factor) / factor;
            return rounded.toFixed(decimals) + ' kr';
          } else {
            // Round to tens, hundreds, etc.
            const factor = Math.pow(10, -decimals);
            rounded = Math.round(num / factor) * factor;
            return Math.round(rounded).toString() + ' kr';
          }
        }
        function formatDuration(seconds) {
          const hrs = Math.floor(seconds / 3600);
          const mins = Math.floor((seconds % 3600) / 60);
          const secs = Math.floor(seconds % 60);
          const parts = [];
          if (hrs > 0) parts.push(hrs + 'h');
          if (mins > 0 || hrs > 0) parts.push(mins + 'm');
          parts.push(secs + 's');
          return parts.join(' ');
        }

        // Helper function: Count the number of working days (Mon-Fri) between two dates.
        // The start date is inclusive and the end date is exclusive. If start >= end, returns 0.
        function countWorkdays(startDate, endDate) {
          const start = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
          const end = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
          if (end <= start) return 0;
          let count = 0;
          let current = new Date(start);
          while (current < end) {
            const day = current.getDay();
            // 1-5 are Monday to Friday (0=Sunday, 6=Saturday)
            if (day >= 1 && day <= 5) count++;
            current.setDate(current.getDate() + 1);
          }
          return count;
        }

        // Compute statistics per project
        function computeProjectStats(project) {
          const now = new Date();
          const entries = data.entries.filter(e => e.projectId === project.id && !e.isRunning);
          const totalSeconds = entries.reduce((sum, e) => sum + (e.duration || 0), 0);
          const totalHours = totalSeconds / 3600;
          const remainingHours = project.budgetHours - totalHours;
          const created = new Date(project.createdAt);
          const deadline = new Date(project.deadline);
          const daysPassed = Math.max(1, Math.round((now - created) / (1000 * 60 * 60 * 24)));
          const daysLeft = Math.max(0, Math.round((deadline - now) / (1000 * 60 * 60 * 24)));
          const avgDailyBurn = totalHours / daysPassed;
          const daysToExhaust = avgDailyBurn > 0 ? remainingHours / avgDailyBurn : Infinity;
          // Determine a more descriptive status for the project based on budget consumption and schedule
          // Calculate expected used hours based on how far through the project we are
          const totalProjectDays = daysPassed + daysLeft;
          const expectedUsed = totalProjectDays > 0 ? project.budgetHours * (daysPassed / totalProjectDays) : totalHours;
          let status = 'on-track';
          let statusColor = 'green';
          let reason = '';
          // If total hours already exceed expected usage at this point in the schedule, mark as over budget
          if (totalHours > expectedUsed) {
            status = 'over-budget';
            statusColor = 'red';
            reason = 'Projected to exceed budget before deadline.';
          // If days to exhaust at current burn rate is less than days left, the project will finish late (behind schedule)
          } else if (daysToExhaust < daysLeft) {
            status = 'behind-schedule';
            statusColor = 'red';
            reason = 'Not enough days left at current pace.';
          // If days to exhaust and days left are very close (within three days), label as tight schedule
          } else if (Math.abs(daysToExhaust - daysLeft) <= 3) {
            status = 'tight';
            statusColor = 'amber';
            reason = 'On track but very little margin.';
          } else {
            status = 'on-track';
            statusColor = 'green';
            reason = 'On track.';
          }
          // Weekly and monthly expected hours
          let weeklyExpected = 0;
          let monthlyExpected = 0;
          // Calculate expected (target) hours to date for this week and this month.
          // We base the daily budget on the total calendar days between project creation and deadline.
          // This yields a more realistic expected-to-date value than strictly using working days, which can
          // produce very small denominators when projects span long periods.
          const totalDays = Math.ceil((deadline - created) / (1000 * 60 * 60 * 24)) || 1;
          const dailyBudget = project.budgetHours / totalDays;
          // Determine the start of the current week (Monday) and the start of the current month
          const startOfWeek = new Date(now);
          const dow = startOfWeek.getDay();
          const diffToMonday = (dow + 6) % 7;
          startOfWeek.setDate(startOfWeek.getDate() - diffToMonday);
          const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
          // Compute calendar day counts relative to project creation date
          const daysTillNow = Math.max(0, (now - created) / (1000 * 60 * 60 * 24));
          const daysTillStartOfWeekCal = Math.max(0, (startOfWeek - created) / (1000 * 60 * 60 * 24));
          const daysTillStartOfMonthCal = Math.max(0, (startOfMonth - created) / (1000 * 60 * 60 * 24));
          // Include fractional day for weekly expected by using floating point difference (time-of-day) rather than rounded days.
          weeklyExpected = Math.max(0, dailyBudget * (daysTillNow - daysTillStartOfWeekCal));
          monthlyExpected = Math.max(0, dailyBudget * (daysTillNow - daysTillStartOfMonthCal));
          // Clamp expected values so they do not exceed the project's total budget hours
          if (weeklyExpected > project.budgetHours) weeklyExpected = project.budgetHours;
          if (monthlyExpected > project.budgetHours) monthlyExpected = project.budgetHours;
          // Weekly and last week hours
          // Determine the start of the current week (Monday 00:00). We calculate how many
          // days have passed since Monday and subtract that from today's date. This ensures
          // weekly statistics reset at the beginning of each week.
          const dayOfWeek = now.getDay();
          const diffToMondayWeek = (dayOfWeek + 6) % 7;
          const weekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - diffToMondayWeek);
          weekStart.setHours(0, 0, 0, 0);
          // Last week spans the 7 days prior to weekStart
          const lastWeekStart = new Date(weekStart);
          lastWeekStart.setDate(weekStart.getDate() - 7);
          const lastWeekEnd = new Date(weekStart);
          const weeklySeconds = entries
            .filter(e => new Date(e.startTime) >= weekStart)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const weeklyHours = weeklySeconds / 3600;
          const lastWeekSeconds = entries
            .filter(e => new Date(e.startTime) >= lastWeekStart && new Date(e.startTime) < lastWeekEnd)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const lastWeekHours = lastWeekSeconds / 3600;
          // Monthly hours and last month hours
          const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
          const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
          const monthlySeconds = entries.filter(e => new Date(e.startTime) >= monthStart)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const monthlyHours = monthlySeconds / 3600;
          const lastMonthSeconds = entries.filter(e => new Date(e.startTime) >= lastMonthStart && new Date(e.startTime) < lastMonthEnd)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const lastMonthHours = lastMonthSeconds / 3600;
          // Revenue
          const revenue = totalHours * project.hourlyRate;
          const weeklyRevenue = weeklyHours * project.hourlyRate;
          const lastWeekRevenue = lastWeekHours * project.hourlyRate;
          const monthlyRevenue = monthlyHours * project.hourlyRate;
          const lastMonthRevenue = lastMonthHours * project.hourlyRate;
          // Calculate dynamic weekly and monthly targets for this project. The dynamic targets
          // spread the remaining hours evenly across the remaining time. For the weekly target,
          // we divide the remaining hours by the number of calendar weeks left (rounded up).
          // For the monthly target, we divide the remaining hours by the number of calendar
          // months left. If there are no remaining days (past deadline), we treat the count as
          // at least one to avoid division by zero.
          const remaining = Math.max(0, remainingHours);
          // Compute the number of calendar weeks remaining until the project deadline. Previously this was
          // used to spread remaining hours evenly, but to align the weekly target with the monthly plan we
          // instead derive it from the monthly deficit and the number of working weeks left in the current
          // calendar month. We still keep the generic weeksLeft calculation for reference.
          const weeksLeft = Math.max(1, Math.ceil(daysLeft / 7));
          // Determine total months between project creation and deadline (inclusive) for constant monthly targets
          const startMonthIndex = created.getFullYear() * 12 + created.getMonth();
          const deadlineMonthIndex = deadline.getFullYear() * 12 + deadline.getMonth();
          const totalMonths = Math.max(1, (deadlineMonthIndex - startMonthIndex + 1));
          const monthTargetOriginal = project.budgetHours / totalMonths;
          // Determine number of full months before the current month (elapsed months) for carry‑over calculations
          const currentMonthIndex = now.getFullYear() * 12 + now.getMonth();
          const monthsElapsed = Math.max(0, currentMonthIndex - startMonthIndex);
          // Compute expected hours for all months prior to the current month
          const expectedBefore = monthTargetOriginal * monthsElapsed;
          // Compute actual hours for months prior to the current month
          const firstDayOfThisMonth = new Date(now.getFullYear(), now.getMonth(), 1);
          const secondsBeforeThisMonth = entries
            .filter(e => new Date(e.startTime) < firstDayOfThisMonth)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const actualBefore = secondsBeforeThisMonth / 3600;
          // Adjust the monthly target for the current month based on surplus or deficit from previous months
          let monthlyTargetConst = monthTargetOriginal + (expectedBefore - actualBefore);
          // If the adjusted monthly target is negative, clamp to zero. This may occur if past months consumed
          // more than expected and the deficit eats into the current month.
          if (monthlyTargetConst < 0) monthlyTargetConst = 0;
          // Compute months left from current date to deadline. This is used for carry‑over logic but
          // not directly for weekly target calculations.
          const monthsLeft = Math.max(1, deadlineMonthIndex - currentMonthIndex + 1);
          // Determine how many working days remain in the current month (from now until the first of next month)
          const startNextMonthWork = new Date(now.getFullYear(), now.getMonth() + 1, 1);
          const workDaysLeftInMonth = countWorkdays(now, startNextMonthWork);
          // Convert remaining working days into remaining working weeks (5 working days per week). At least 1.
          const workingWeeksLeftInMonth = Math.max(1, Math.ceil(workDaysLeftInMonth / 5));
          // Compute remaining monthly hours (deficit or surplus). This is the hours still needed to meet the
          // adjusted monthly target. If negative, treat as zero (no deficit). This is used to set the weekly
          // target so that the remaining monthly hours are spread evenly over the remaining working weeks.
          const monthlyRemaining = Math.max(0, monthlyTargetConst - monthlyHours);
          // Derive the weekly target from the monthly remaining hours divided by the working weeks left. If
          // there is no monthly target (0), the weekly target will also be 0.
          const weeklyTargetConst = workingWeeksLeftInMonth > 0 ? monthlyRemaining / workingWeeksLeftInMonth : 0;
          return {
            totalHours,
            remainingHours,
            usedPct: project.budgetHours > 0 ? (totalHours / project.budgetHours) * 100 : 0,
            daysLeft,
            daysPassed,
            status,
            statusColor,
            reason,
            weeklyExpected,
            monthlyExpected,
            weeklyHours,
            lastWeekHours,
            monthlyHours,
            lastMonthHours,
            revenue,
            weeklyRevenue,
            lastWeekRevenue,
            monthlyRevenue,
            lastMonthRevenue,
            weeklyTargetConst,
            monthlyTargetConst
          };
        }

        // Compute global statistics
        function computeGlobalStats() {
          const now = new Date();
          const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          const yesterdayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
          // Start of this week (Monday 00:00) – the weekly period resets on Mondays. We calculate
          // the date of Monday in the current week and use it to accumulate weekly hours
          // and revenue. If today is Monday, weekStart will be today; if today is Tuesday,
          // weekStart will be yesterday, and so on.
          const day = now.getDay();
          const diffToMonday = (day + 6) % 7;
          const weekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - diffToMonday);
          weekStart.setHours(0, 0, 0, 0);
          // Define last week's date range for revenue calculation (the week before the current week).
          // We subtract 7 days from weekStart to get the start of the previous week and use weekStart
          // itself as the end of last week.
          const lastWeekStart = new Date(weekStart);
          lastWeekStart.setDate(weekStart.getDate() - 7);
          const lastWeekEnd = new Date(weekStart);
          const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
          const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
          let todaySeconds = 0;
          let yesterdaySeconds = 0;
          let weekSeconds = 0;
          // Track weekly seconds accrued before today so the daily target can be
          // calculated based on the week's remaining hours at the start of the day.
          let weekSecondsStartOfDay = 0;
          let monthSeconds = 0;
          let lastMonthSeconds = 0;
          let totalRevenue = 0;
          let monthlyRevenue = 0;
          let lastMonthRevenue = 0;
          // Revenue totals for today and this week (across all projects)
          let todayRevenue = 0;
          let yesterdayRevenue = 0;
          let weekRevenue = 0;
          let lastWeekRevenue = 0;
          // Dynamic weekly and monthly targets for all projects. We recalculate each project's
          // weekly and monthly targets based on remaining hours and remaining time until
          // deadline. The sum of these per‑project targets represents the number of hours
          // you should aim to work this week and this month across all projects.
          let weeklyTarget = 0;
          let monthTarget = 0;
          // We'll compute dailyTarget based on remaining monthly hours later
          let dailyTarget = 0;
          data.projects.forEach(project => {
            const sp = computeProjectStats(project);
            weeklyTarget += sp.weeklyTargetConst || 0;
            monthTarget += sp.monthlyTargetConst || 0;
          });
          // Daily target will be computed later once monthHours is known.
          data.entries.forEach(entry => {
            if (entry.isRunning || !entry.duration) return;
            const start = new Date(entry.startTime);
            const project = data.projects.find(p => p.id === entry.projectId);
            const hours = entry.duration / 3600;
            if (!project) return;
            if (start >= todayStart) {
              todaySeconds += entry.duration;
              todayRevenue += hours * project.hourlyRate;
            }
            if (start >= yesterdayStart && start < todayStart) {
              yesterdaySeconds += entry.duration;
              yesterdayRevenue += hours * project.hourlyRate;
            }
            if (start >= weekStart) {
              weekSeconds += entry.duration;
              weekRevenue += hours * project.hourlyRate;
              // Count weekly seconds before today separately for computing the daily target.
              if (start < todayStart) {
                weekSecondsStartOfDay += entry.duration;
              }
            }
            if (start >= monthStart) {
              monthSeconds += entry.duration;
              monthlyRevenue += hours * project.hourlyRate;
            } else if (start >= lastMonthStart && start < lastMonthEnd) {
              lastMonthSeconds += entry.duration;
              lastMonthRevenue += hours * project.hourlyRate;
            }
            totalRevenue += hours * project.hourlyRate;
            // Accumulate revenue for last week (previous 7 days before the current week)
            if (start >= lastWeekStart && start < lastWeekEnd) {
              lastWeekRevenue += hours * project.hourlyRate;
            }
          });
          const todayHours = todaySeconds / 3600;
          const yesterdayHours = yesterdaySeconds / 3600;
          const weekHours = weekSeconds / 3600;
          const monthHours = monthSeconds / 3600;
          const lastMonthHours = lastMonthSeconds / 3600;
          const weeklyProgress = weeklyTarget > 0 ? (weekHours / weeklyTarget) * 100 : 0;
          const revenueChange = lastMonthRevenue > 0 ? ((monthlyRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : null;
          const todayChange = yesterdayHours > 0 ? ((todayHours - yesterdayHours) / yesterdayHours) * 100 : null;
          const activeProjects = data.projects.length;
          const dueThisWeek = data.projects.filter(p => {
            const d = new Date(p.deadline);
            const diffDays = Math.round((d - now) / (1000 * 60 * 60 * 24));
            return diffDays >= 0 && diffDays <= 7;
          }).length;
          const monthProgress = monthTarget > 0 ? (monthHours / monthTarget) * 100 : 0;
          // Weekly revenue change relative to last week. lastWeekRevenue was
          // accumulated in the main entry loop above using the lastWeekStart
          // and lastWeekEnd constants defined earlier in this function.
          const weekRevenueChange = lastWeekRevenue > 0 ? ((weekRevenue - lastWeekRevenue) / lastWeekRevenue) * 100 : null;
          const todayRevenueChange = yesterdayRevenue > 0 ? ((todayRevenue - yesterdayRevenue) / yesterdayRevenue) * 100 : null;

          // Now that monthHours and weekHours are known, compute the daily target based on remaining
          // weekly hours and remaining working days in the current week. The weekly target is itself
          // derived from the remaining monthly budget and the number of working weeks left in the month.
          // We want the daily target to reflect how much work remains this week rather than spreading
          // monthly remaining hours evenly across all days of the month. If the weekly target has
          // already been met or there are no workdays left this week, the daily target is zero.
          // Use the week's remaining hours at the start of the day rather than the current
          // remaining hours. This keeps the daily target constant throughout the day. If you
          // work additional hours later in the day, it should not reduce your target until
          // the next day. Compute weeklyRemainingStart from hours worked before today.
          const weekHoursStartOfDay = weekSecondsStartOfDay / 3600;
          const weeklyRemaining = weeklyTarget - weekHoursStartOfDay;
          // Determine the start of next week (Monday at 00:00) by adding 7 days to this week's start.
          const startNextWeekDT = new Date(weekStart.getTime() + 7 * 24 * 60 * 60 * 1000);
          // Count how many working days remain from now (inclusive) until the start of next week.
          const workDaysLeftInWeekDT = countWorkdays(now, startNextWeekDT);
          let computedDailyTarget = 0;
          if (weeklyRemaining > 0 && workDaysLeftInWeekDT > 0) {
            computedDailyTarget = weeklyRemaining / workDaysLeftInWeekDT;
          }
          // Assign to dailyTarget so it can be returned under the same name
          dailyTarget = computedDailyTarget;
          return {
            todayHours,
            yesterdayHours,
            weekHours,
            weekTarget: weeklyTarget,
            weeklyProgress,
            monthHours,
            monthTarget,
            monthProgress,
            monthRevenue: monthlyRevenue,
            lastMonthRevenue,
            revenueChange,
            todayChange,
            // revenue today and this week
            todayRevenue,
            weekRevenue,
            todayRevenueChange,
            weekRevenueChange,
            activeProjects,
            dueThisWeek,
            totalRevenue,
            dailyTarget
          };
        }

        // Dashboard rendering
        function updateDashboard() {
          const stats = computeGlobalStats();
          // Determine recommended projects before building cards and assign global identifiers
          let maxWeeklyDeficitCard = -Infinity;
          let maxMonthlyDeficitCard = -Infinity;
          let recommendedWeeklyProject = null;
          let recommendedMonthlyProject = null;
          if (data.projects.length > 0) {
            data.projects.forEach(project => {
              const sp = computeProjectStats(project);
              const weeklyDeficit = (sp.weeklyExpected || 0) - (sp.weeklyHours || 0);
              if (weeklyDeficit > maxWeeklyDeficitCard) {
                maxWeeklyDeficitCard = weeklyDeficit;
                recommendedWeeklyProject = project;
              }
              const monthlyDeficit = (sp.monthlyExpected || 0) - (sp.monthlyHours || 0);
              if (monthlyDeficit > maxMonthlyDeficitCard) {
                maxMonthlyDeficitCard = monthlyDeficit;
                recommendedMonthlyProject = project;
              }
            });
          }
          // Update global identifiers so other sections know which projects are recommended
          currentRecommendedWeeklyId = recommendedWeeklyProject ? recommendedWeeklyProject.id : null;
          currentRecommendedMonthlyId = recommendedMonthlyProject ? recommendedMonthlyProject.id : null;
          // Precompute per-project stats once for use in cards and recommendations. This avoids
          // recalculating computeProjectStats multiple times during rendering.
          const perProjectStats = data.projects.map(p => {
            return { project: p, stats: computeProjectStats(p) };
          });
          // Calculate time progress for the current week and month. Instead of using only
          // whole working days, include the fraction of the day that has elapsed. For
          // weekly progress, Monday 00:00 marks the start and Friday 23:59 marks the
          // end (5 days). For monthly progress, the first day of the month marks
          // the start and the first day of the following month marks the end.
          const nowTime = new Date();
          // Define the start of today so we can compute today's hours for each project when building
          // the per‑project breakdown lists. We'll reuse todayStart in the card rendering below.
          const todayStart = new Date(nowTime.getFullYear(), nowTime.getMonth(), nowTime.getDate());
          // Weekly time progress: compute fraction of the 5-day work week that has elapsed.
          // Precompute start of week (Monday 00:00) outside the branch so it can be reused later.
          const dayOfWeek = nowTime.getDay();
          const diffToMonday = (dayOfWeek + 6) % 7;
          const startWeek = new Date(nowTime);
          startWeek.setDate(startWeek.getDate() - diffToMonday);
          startWeek.setHours(0, 0, 0, 0);
          let weeklyTimeProgress;
          if (dayOfWeek === 0 || dayOfWeek === 6) {
            weeklyTimeProgress = 100;
          } else {
            // Compute elapsed time since start of work week and scale over 5 working days
            const diffMs = nowTime - startWeek;
            const totalMs = 5 * 24 * 60 * 60 * 1000;
            weeklyTimeProgress = Math.min((diffMs / totalMs) * 100, 100);
          }
          // Monthly time progress: compute fraction of working days elapsed in the current month. We count
          // only Monday–Friday as working days. Use countWorkdays() to determine the total number of
          // working days in the month and how many have elapsed so far. Weekends contribute nothing.
          const startMonth = new Date(nowTime.getFullYear(), nowTime.getMonth(), 1);
          const startNextMonth = new Date(nowTime.getFullYear(), nowTime.getMonth() + 1, 1);
          const workDaysTotalMonth = countWorkdays(startMonth, startNextMonth);
          const workDaysElapsedMonth = countWorkdays(startMonth, nowTime);
          let monthlyTimeProgress = workDaysTotalMonth > 0 ? (workDaysElapsedMonth / workDaysTotalMonth) * 100 : 0;
          if (monthlyTimeProgress > 100) monthlyTimeProgress = 100;
          // Precompute how many working days remain in the current month and current week. The value
          // for the month is used for monthly recommendations elsewhere; the weekly value is used
          // for calculating the recommended daily hours per project. If the result is zero, all
          // remaining work is effectively overdue.
          const workDaysLeftInMonth = countWorkdays(nowTime, startNextMonth);
          // Start of next week (Monday at 00:00) for computing remaining workdays this week
          const startNextWeek = new Date(startWeek.getTime() + 7 * 24 * 60 * 60 * 1000);
          const workDaysLeftInWeek = countWorkdays(nowTime, startNextWeek);

          // Determine schedule status for weekly and monthly progress by comparing hours progress
          // to time progress. If the hours progress (worked/target) exceeds time progress, the user is ahead.
          const weekHoursProgress = stats.weekTarget > 0 ? (stats.weekHours / stats.weekTarget) * 100 : 0;
          const monthHoursProgress = stats.monthTarget > 0 ? (stats.monthHours / stats.monthTarget) * 100 : 0;
          const weekScheduleDiff = weekHoursProgress - weeklyTimeProgress;
          const monthScheduleDiff = monthHoursProgress - monthlyTimeProgress;
          const weekScheduleLabel = weekScheduleDiff > 5 ? 'Ahead of schedule' : (weekScheduleDiff < -5 ? 'Behind schedule' : 'On schedule');
          const monthScheduleLabel = monthScheduleDiff > 5 ? 'Ahead of schedule' : (monthScheduleDiff < -5 ? 'Behind schedule' : 'On schedule');

          // Stats cards data; integrate recommendations and revenue into relevant cards. Cards with
          // progress also include timeProgress and scheduleLabel for additional context.
          // Build the dashboard cards. We merge revenue into the relevant cards rather than
          // using a separate Revenue card. A multi progress bar visualises both how far
          // through the period we are (expected progress) and how much of the target has
          // been worked. The expected progress (timeProgress) will be rendered as a dark
          // overlay and the actual hours progress as the blue overlay. No textual
          // schedule label is displayed; instead the bar visualises whether you are ahead
          // or behind schedule.
          // Build the dashboard cards. Each card includes a value, progress bar(s), and labels.  
          // For the weekly and monthly cards we include both the percentage of target worked and the percentage of the period elapsed.  
          const cards = [
            {
              title: "Today's Hours",
              // Show today's hours against the daily target
              value: stats.todayHours.toFixed(1) + ' / ' + (stats.dailyTarget ? stats.dailyTarget.toFixed(1) : '0') + 'h',
              // Remove change label and comparison to yesterday per user request
              icon: '⏱',
              // Revenue for today shown on this card
              revenue: stats.todayRevenue || 0
            },
            {
              title: 'This Week',
              value: stats.weekHours.toFixed(1) + ' / ' + (stats.weekTarget ? stats.weekTarget.toFixed(1) : '0') + 'h',
              progress: stats.weeklyProgress,
              // Expected progress based on working days in the week
              timeProgress: weeklyTimeProgress,
              icon: '📅',
              // Progress label expresses hours progress relative to target and time progress relative to the week
              progressLabel: (stats.weeklyProgress || 0).toFixed(1) + '% of weekly target in ' + weeklyTimeProgress.toFixed(1) + '% of the week',
              // Schedule label indicates whether the user is ahead, behind, or on schedule this week
              scheduleLabel: weekScheduleLabel,
              // Show revenue earned this week on the same card
              revenue: stats.weekRevenue || 0
            },
            {
              title: 'This Month',
              value: stats.monthHours.toFixed(1) + ' / ' + (stats.monthTarget ? stats.monthTarget.toFixed(1) : '0') + 'h',
              progress: stats.monthProgress,
              // Expected progress based on working days in the month
              timeProgress: monthlyTimeProgress,
              icon: '🗓',
              progressLabel: (stats.monthProgress || 0).toFixed(1) + '% of monthly target in ' + monthlyTimeProgress.toFixed(1) + '% of the month',
              scheduleLabel: monthScheduleLabel,
              // Integrate monthly revenue into this card
              revenue: stats.monthRevenue || 0
            }
          ]; // Active Projects card removed per user request
          const statsGrid = document.getElementById('statsGrid');
          statsGrid.innerHTML = '';
          cards.forEach(card => {
            const div = document.createElement('div');
            div.className = 'stat-card';
            // icon
            const iconDiv = document.createElement('div');
            iconDiv.className = 'stat-icon';
            iconDiv.textContent = card.icon;
            div.appendChild(iconDiv);
            // title
            const titleDiv = document.createElement('div');
            titleDiv.className = 'stat-title';
            titleDiv.textContent = card.title;
            div.appendChild(titleDiv);
            // value
            const valueDiv = document.createElement('div');
            valueDiv.className = 'stat-value';
            valueDiv.textContent = card.value;
            div.appendChild(valueDiv);
            // progress or change
            if (card.progress !== undefined) {
              // Use a multi progress bar if timeProgress is provided, otherwise fallback to a single bar.
              if (card.timeProgress !== undefined) {
                // Create a container for two stacked progress bars: one for expected progress (black) and one for actual hours (blue).
                const barContainer = document.createElement('div');
                barContainer.style.display = 'flex';
                barContainer.style.flexDirection = 'column';
                barContainer.style.gap = '0.2rem';
                // Actual hours worked bar (blue) shown on top
                const hoursBar = document.createElement('div');
                hoursBar.className = 'progress-bar';
                const hoursFill = document.createElement('div');
                hoursFill.className = 'fill';
                hoursFill.style.width = Math.min(100, card.progress).toFixed(1) + '%';
                hoursBar.appendChild(hoursFill);
                barContainer.appendChild(hoursBar);
                // Expected progress bar (black) shown beneath
                const expectedBar = document.createElement('div');
                expectedBar.className = 'progress-bar';
                const expectedFill = document.createElement('div');
                expectedFill.className = 'fill';
                // Override background color to black for expected progress
                expectedFill.style.backgroundColor = '#000000';
                expectedFill.style.width = Math.min(100, card.timeProgress).toFixed(1) + '%';
                expectedBar.appendChild(expectedFill);
                barContainer.appendChild(expectedBar);
                div.appendChild(barContainer);
              } else {
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                const fill = document.createElement('div');
                fill.className = 'fill';
                fill.style.width = Math.min(100, card.progress).toFixed(1) + '%';
                progressBar.appendChild(fill);
                div.appendChild(progressBar);
              }
              // Label describing work progress relative to target and time progress
              const pLabel = document.createElement('div');
              pLabel.className = 'stat-change';
              pLabel.textContent = card.progressLabel || '';
              pLabel.style.color = '#475569';
              div.appendChild(pLabel);
              // If the card contains a schedule label (ahead/behind/on), add a second line with colour coding
              if (card.scheduleLabel) {
                const sched = document.createElement('div');
                sched.className = 'stat-change';
                sched.textContent = card.scheduleLabel;
                // Colour code the schedule: green for ahead, red for behind, amber for on schedule
                const text = card.scheduleLabel.toLowerCase();
                if (text.includes('ahead')) sched.style.color = '#15803d';
                else if (text.includes('behind')) sched.style.color = '#b91c1c';
                else sched.style.color = '#92400e';
                div.appendChild(sched);
              }
            } else {
              // Change or change label for cards without progress
              const changeDiv = document.createElement('div');
              changeDiv.className = 'stat-change';
              if (card.change === null || card.change === undefined) {
                changeDiv.textContent = card.changeLabel || '';
                changeDiv.style.color = '#475569';
              } else {
                const change = card.change;
                const prefix = change >= 0 ? '+' : '';
                changeDiv.textContent = prefix + change.toFixed(0) + '% ' + card.changeLabel;
                changeDiv.classList.add(change >= 0 ? 'positive' : 'negative');
              }
              div.appendChild(changeDiv);
            }
            // Append revenue information if provided on the card
            if (card.revenue !== undefined) {
              const revenueDiv = document.createElement('div');
              revenueDiv.className = 'stat-change';
              // Round revenue to the nearest 10 (use decimals = -1) for dashboard display
              revenueDiv.textContent = 'Revenue: ' + formatCurrency(card.revenue, -1);
              revenueDiv.style.color = '#475569';
              div.appendChild(revenueDiv);
            }
            // Append per‑project breakdowns underneath each card. For Today, display today's hours
            // against the recommended daily hours for each project. For Week and Month, display
            // actual versus target hours and colour code based on whether the project is ahead
            // (green) or behind (red) relative to the expected progress so far.
            if (card.title === "Today's Hours" || card.title === 'This Week' || card.title === 'This Month') {
              const list = document.createElement('div');
              list.style.marginTop = '0.5rem';
              perProjectStats.forEach(item => {
                const row = document.createElement('div');
                row.style.fontSize = '0.75rem';
                // Determine today, weekly and monthly metrics
                // Compute today's hours for this project
                let projectTodaySeconds = 0;
                data.entries.forEach(entry => {
                  if (!entry.isRunning && entry.projectId === item.project.id) {
                    const s = new Date(entry.startTime);
                    if (s >= todayStart && s < new Date(todayStart.getTime() + 24 * 60 * 60 * 1000)) {
                      projectTodaySeconds += entry.duration || 0;
                    }
                  }
                });
                const projectTodayHours = projectTodaySeconds / 3600;
                // Calculate recommended daily hours based on remaining weekly target at the start of today
                // and the number of working days left in the week. We compute the hours worked for this
                // project before today and subtract them from the weekly target so the daily target stays
                // constant throughout the day. Clamp negative values to zero.
                let projectWeekSecondsStartOfDay = 0;
                data.entries.forEach(e => {
                  if (!e.isRunning && e.projectId === item.project.id) {
                    const s = new Date(e.startTime);
                    if (s >= startWeek && s < todayStart) {
                      projectWeekSecondsStartOfDay += e.duration || 0;
                    }
                  }
                });
                const projectWeekHoursStart = projectWeekSecondsStartOfDay / 3600;
                const remainingWeekly = Math.max(0, item.stats.weeklyTargetConst - projectWeekHoursStart);
                const projectDailyTarget = workDaysLeftInWeek > 0 ? (remainingWeekly / workDaysLeftInWeek) : 0;
                // For weekly and monthly expected to date, compute expected hours based on time progress
                const expectedWeekSoFar = item.stats.weeklyTargetConst * (weeklyTimeProgress / 100);
                const expectedMonthSoFar = item.stats.monthlyTargetConst * (monthlyTimeProgress / 100);
                if (card.title === "Today's Hours") {
                  // For daily: show hours worked and daily target, colour green if on or ahead, else red
                  row.textContent = `${item.project.name}: ${projectTodayHours.toFixed(1)} / ${projectDailyTarget.toFixed(1)}h`;
                  row.style.color = projectTodayHours >= projectDailyTarget ? '#15803d' : '#b91c1c';
                } else if (card.title === 'This Week') {
                  row.textContent = `${item.project.name}: ${item.stats.weeklyHours.toFixed(1)} / ${item.stats.weeklyTargetConst.toFixed(1)}h`;
                  // Colour code: green if actual hours exceed expected progress so far, red otherwise
                  const onTrack = item.stats.weeklyHours >= expectedWeekSoFar - 0.01; // small tolerance
                  row.style.color = onTrack ? '#15803d' : '#b91c1c';
                } else {
                  // Month
                  row.textContent = `${item.project.name}: ${item.stats.monthlyHours.toFixed(1)} / ${item.stats.monthlyTargetConst.toFixed(1)}h`;
                  const onTrack = item.stats.monthlyHours >= expectedMonthSoFar - 0.01;
                  row.style.color = onTrack ? '#15803d' : '#b91c1c';
                }
                list.appendChild(row);
              });
              div.appendChild(list);
            }
            statsGrid.appendChild(div);
          });
          // Project status overview and detailed breakdown
          renderProjectOverview();
          renderDetailedBreakdown();
          // Render daily hours heatmap and update burndown chart
          renderHeatmap();
          updateBurndownSelect();
          // Previously there was a separate Recommendations card here. It has been removed in favor of integrating suggestions directly into other sections.

          // Prepare data for weekly and monthly scatter charts
          const weeklyDatasets = [];
          const monthlyDatasets = [];
          // Track the maximum expected/actual values to draw an ideal x=y line
          let maxWeeklyVal = 0;
          let maxMonthlyVal = 0;
          data.projects.forEach(project => {
            const statsP = computeProjectStats(project);
            const color = project.color || '#3b82f6';
            weeklyDatasets.push({
              label: project.name,
              data: [{ x: statsP.weeklyExpected, y: statsP.weeklyHours }],
              // Use project color for point appearance
              pointBackgroundColor: color,
              pointBorderColor: color,
              backgroundColor: color,
              borderColor: color,
              pointRadius: 5,
              pointHoverRadius: 7,
              showLine: false
            });
            monthlyDatasets.push({
              label: project.name,
              data: [{ x: statsP.monthlyExpected, y: statsP.monthlyHours }],
              // Use project color for point appearance
              pointBackgroundColor: color,
              pointBorderColor: color,
              backgroundColor: color,
              borderColor: color,
              pointRadius: 5,
              pointHoverRadius: 7,
              showLine: false
            });
            // Update max values for diagonal line
            maxWeeklyVal = Math.max(maxWeeklyVal, statsP.weeklyExpected, statsP.weeklyHours);
            maxMonthlyVal = Math.max(maxMonthlyVal, statsP.monthlyExpected, statsP.monthlyHours);
          });
          // Add diagonal x=y guide line datasets to both charts
          if (weeklyDatasets.length > 0) {
            weeklyDatasets.unshift({
              label: 'Ideal (x=y)',
              data: [
                { x: 0, y: 0 },
                { x: maxWeeklyVal, y: maxWeeklyVal }
              ],
              borderColor: '#94a3b8',
              borderDash: [5, 5],
              showLine: true,
              fill: false,
              pointRadius: 0
            });
          }
          if (monthlyDatasets.length > 0) {
            monthlyDatasets.unshift({
              label: 'Ideal (x=y)',
              data: [
                { x: 0, y: 0 },
                { x: maxMonthlyVal, y: maxMonthlyVal }
              ],
              borderColor: '#94a3b8',
              borderDash: [5, 5],
              showLine: true,
              fill: false,
              pointRadius: 0
            });
          }
          // Weekly scatter chart
          const weeklyCanvas = document.getElementById('weeklyScatter');
          if (weeklyCanvas) {
            if (!weeklyScatterChart) {
              const ctx = weeklyCanvas.getContext('2d');
              weeklyScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: weeklyDatasets },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: { display: true, position: 'bottom', labels: { boxWidth: 12 } },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          const label = context.dataset.label || '';
                          const xVal = context.parsed.x;
                          const yVal = context.parsed.y;
                          return label + ': Expected ' + xVal.toFixed(1) + 'h, Actual ' + yVal.toFixed(1) + 'h';
                        }
                      }
                    },
                    title: { display: false }
                  },
                  scales: {
                    x: { title: { display: true, text: 'Expected Hours' }, beginAtZero: true },
                    y: { title: { display: true, text: 'Actual Hours' }, beginAtZero: true }
                  }
                }
              });
            } else {
              weeklyScatterChart.data.datasets = weeklyDatasets;
              weeklyScatterChart.update();
            }
          }
          // Monthly scatter chart
          const monthlyCanvas = document.getElementById('monthlyScatter');
          if (monthlyCanvas) {
            if (!monthlyScatterChart) {
              const ctx2 = monthlyCanvas.getContext('2d');
              monthlyScatterChart = new Chart(ctx2, {
                type: 'scatter',
                data: { datasets: monthlyDatasets },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: { display: true, position: 'bottom', labels: { boxWidth: 12 } },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          const label = context.dataset.label || '';
                          const xVal = context.parsed.x;
                          const yVal = context.parsed.y;
                          return label + ': Expected ' + xVal.toFixed(1) + 'h, Actual ' + yVal.toFixed(1) + 'h';
                        }
                      }
                    },
                    title: { display: false }
                  },
                  scales: {
                    x: { title: { display: true, text: 'Expected Hours' }, beginAtZero: true },
                    y: { title: { display: true, text: 'Actual Hours' }, beginAtZero: true }
                  }
                }
              });
            } else {
              monthlyScatterChart.data.datasets = monthlyDatasets;
              monthlyScatterChart.update();
            }
          }
        }

        // Render project overview list
        function renderProjectOverview() {
          const container = document.getElementById('projectOverview');
          container.innerHTML = '';
          if (data.projects.length === 0) return;
          const wrapper = document.createElement('div');
          wrapper.className = 'project-list';
          const header = document.createElement('div');
          header.className = 'project-list-header';
          header.textContent = 'Project Status Overview';
          wrapper.appendChild(header);
          data.projects.forEach(project => {
            const stats = computeProjectStats(project);
            const item = document.createElement('div');
            item.className = 'project-item';
            // info section
            const info = document.createElement('div');
            info.className = 'project-info';
            const dot = document.createElement('div');
            dot.className = 'dot';
            dot.style.backgroundColor = project.color || '#3b82f6';
            info.appendChild(dot);
            const nameDiv = document.createElement('div');
            nameDiv.style.fontWeight = '600';
            nameDiv.style.fontSize = '0.9rem';
            nameDiv.textContent = project.name;
            // Add a star marker only for the monthly recommended project
            if (project.id === currentRecommendedMonthlyId) {
              const starM = document.createElement('span');
              starM.textContent = '★';
              starM.style.color = '#f97316';
              starM.style.marginLeft = '0.25rem';
              starM.title = 'Recommended this month';
              nameDiv.appendChild(starM);
            }
            info.appendChild(nameDiv);
            const hoursDiv = document.createElement('div');
            hoursDiv.style.fontSize = '0.8rem';
            hoursDiv.style.color = '#64748b';
            hoursDiv.textContent = stats.totalHours.toFixed(1) + 'h / ' + project.budgetHours.toFixed(1) + 'h';
            info.appendChild(hoursDiv);
            item.appendChild(info);
            // progress bar container showing expected progress (black) and hours worked (blue) as two stacked bars
            const progressContainer = document.createElement('div');
            progressContainer.style.flex = '1';
            progressContainer.style.margin = '0 1rem';
            progressContainer.style.display = 'flex';
            progressContainer.style.flexDirection = 'column';
            progressContainer.style.gap = '0.2rem';
            // Calculate expected progress through the project (days passed / total days)
            const totalProjectDaysProg = stats.daysPassed + stats.daysLeft;
            const timeProg = totalProjectDaysProg > 0 ? (stats.daysPassed / totalProjectDaysProg) * 100 : 0;
            const usedProg = stats.usedPct;
            // Hours worked progress bar (blue) shown on top
            const hoursBar = document.createElement('div');
            hoursBar.className = 'progress-bar';
            const hoursFill = document.createElement('div');
            hoursFill.className = 'fill';
            hoursFill.style.width = Math.min(100, usedProg).toFixed(1) + '%';
            hoursBar.appendChild(hoursFill);
            progressContainer.appendChild(hoursBar);
            // Expected progress bar (black) shown beneath
            const expectedBar = document.createElement('div');
            expectedBar.className = 'progress-bar';
            const expectedFill = document.createElement('div');
            expectedFill.className = 'fill';
            expectedFill.style.backgroundColor = '#000000';
            expectedFill.style.width = Math.min(100, timeProg).toFixed(1) + '%';
            expectedBar.appendChild(expectedFill);
            progressContainer.appendChild(expectedBar);
            // Determine schedule status for this project by comparing used percent to time progress
            const scheduleDiffProj = usedProg - timeProg;
            let scheduleTextProj;
            if (scheduleDiffProj > 5) scheduleTextProj = 'Ahead of schedule';
            else if (scheduleDiffProj < -5) scheduleTextProj = 'Behind schedule';
            else scheduleTextProj = 'On schedule';
            // Create a small label below the bars to indicate schedule status
            const schedDivProj = document.createElement('div');
            schedDivProj.style.fontSize = '0.7rem';
            schedDivProj.style.marginTop = '0.25rem';
            // Colour code: green ahead, red behind, amber for on schedule
            if (scheduleDiffProj > 5) schedDivProj.style.color = '#15803d';
            else if (scheduleDiffProj < -5) schedDivProj.style.color = '#b91c1c';
            else schedDivProj.style.color = '#92400e';
            schedDivProj.textContent = scheduleTextProj;
            progressContainer.appendChild(schedDivProj);
            item.appendChild(progressContainer);
            // Add schedule text comment after bars
            // Note: status badge with descriptive text and tooltip will still be appended below
            // status badge with descriptive text and tooltip
            const status = document.createElement('span');
            status.className = 'status-badge ' + (stats.statusColor || 'green');
            // Determine human-friendly label
            let statusLabel;
            if (stats.status === 'over-budget') statusLabel = 'Over Budget';
            else if (stats.status === 'behind-schedule') statusLabel = 'Behind Schedule';
            else if (stats.status === 'tight') statusLabel = 'Tight';
            else statusLabel = 'On Track';
            status.textContent = statusLabel;
            // Tooltip explaining the reason
            if (stats.reason) {
              status.title = stats.reason;
            }
            item.appendChild(status);
            wrapper.appendChild(item);
          });
          container.appendChild(wrapper);
        }

        // Render detailed project breakdown table
        function renderDetailedBreakdown() {
          const container = document.getElementById('detailedBreakdown');
          container.innerHTML = '';
          if (data.projects.length === 0) return;
          const card = document.createElement('div');
          card.className = 'card';
          const heading = document.createElement('h3');
          heading.textContent = 'Detailed Project Breakdown';
          heading.style.margin = '0 0 0.5rem 0';
          heading.style.fontSize = '1.1rem';
          heading.style.fontWeight = '600';
          card.appendChild(heading);
          const table = document.createElement('table');
          // Add responsive-table class for mobile-friendly styling
          table.classList.add('responsive-table');
          const thead = document.createElement('thead');
          thead.innerHTML = '<tr><th>Project</th><th>Client</th><th>Hours</th><th>Budget</th><th>Status</th><th>This Week</th><th>Last Week</th><th>This Month</th><th>Revenue</th></tr>';
          table.appendChild(thead);
          const tbody = document.createElement('tbody');
          data.projects.forEach(project => {
            const stats = computeProjectStats(project);
            const isRecommendedWeekly = (project.id === currentRecommendedWeeklyId);
            const isRecommendedMonthly = (project.id === currentRecommendedMonthlyId);
            const tr = document.createElement('tr');
            // Determine human-friendly label and color for status
            let statusLabel;
            if (stats.status === 'over-budget') statusLabel = 'Over Budget';
            else if (stats.status === 'behind-schedule') statusLabel = 'Behind Schedule';
            else if (stats.status === 'tight') statusLabel = 'Tight';
            else statusLabel = 'On Track';
            tr.innerHTML = `
              <td data-label="Project">${project.name}</td>
              <td data-label="Client">${project.client || '-'}</td>
              <td data-label="Hours">${stats.totalHours.toFixed(1)}h</td>
              <td data-label="Budget">${project.budgetHours.toFixed(1)}h</td>
              <td data-label="Status"><span class="status-badge ${stats.statusColor}"${stats.reason ? ` title="${stats.reason}"` : ''}>${statusLabel}</span></td>
              <td data-label="This Week">${stats.weeklyHours.toFixed(1)} / ${stats.weeklyTargetConst.toFixed(1)}h (target)</td>
              <td data-label="Last Week">${stats.lastWeekHours.toFixed(1)}h</td>
              <td data-label="This Month">${stats.monthlyHours.toFixed(1)} / ${stats.monthlyTargetConst.toFixed(1)}h${isRecommendedMonthly ? ' (Recommended)' : ''} (target)</td>
              <td data-label="Revenue">${formatCurrency(stats.revenue)}</td>
            `;
            tbody.appendChild(tr);
          });
          table.appendChild(tbody);
          // Wrap table in a scroll container to improve mobile usability
          const wrapper = document.createElement('div');
          wrapper.style.overflowX = 'auto';
          wrapper.appendChild(table);
          card.appendChild(wrapper);
          container.appendChild(card);
        }

        // Render a heatmap of hours per day for the current month. Each cell's color intensity
        // corresponds to the number of hours worked on that day. Darker colors represent more
        // hours. The heatmap table is created dynamically within the #heatmap div.
        function renderHeatmap() {
          const heatmapDiv = document.getElementById('heatmap');
          if (!heatmapDiv) return;
          heatmapDiv.innerHTML = '';
          const now = new Date();
          const year = now.getFullYear();
          const month = now.getMonth();
          const firstDay = new Date(year, month, 1);
          const daysInMonth = new Date(year, month + 1, 0).getDate();
          // Accumulate hours for each day of this month
          const dailyHours = {};
          data.entries.forEach(entry => {
            if (!entry.duration) return;
            if (entry.isRunning) return;
            const dt = new Date(entry.startTime);
            if (dt.getFullYear() === year && dt.getMonth() === month) {
              const day = dt.getDate();
              dailyHours[day] = (dailyHours[day] || 0) + (entry.duration / 3600);
            }
          });
          // Determine the maximum hours to scale colors
          let maxHours = 0;
          Object.values(dailyHours).forEach(val => {
            if (val > maxHours) maxHours = val;
          });
          // Define function to interpolate between two colors based on a factor (0 to 1)
          function interpolateColor(color1, color2, factor) {
            const c1 = parseInt(color1.slice(1), 16);
            const c2 = parseInt(color2.slice(1), 16);
            const r1 = (c1 >> 16) & 0xff;
            const g1 = (c1 >> 8) & 0xff;
            const b1 = c1 & 0xff;
            const r2 = (c2 >> 16) & 0xff;
            const g2 = (c2 >> 8) & 0xff;
            const b2 = c2 & 0xff;
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            const hex = (r << 16) | (g << 8) | b;
            return '#' + hex.toString(16).padStart(6, '0');
          }
          // Colors for low and high values
          const lowColor = '#e0e7ff';
          const highColor = '#1e40af';
          // Create table element
          const table = document.createElement('table');
          table.style.borderCollapse = 'collapse';
          table.style.width = '100%';
          const headerRow = document.createElement('tr');
          const daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
          daysOfWeek.forEach(dow => {
            const th = document.createElement('th');
            th.textContent = dow;
            th.style.fontSize = '0.8rem';
            th.style.padding = '0.25rem';
            headerRow.appendChild(th);
          });
          table.appendChild(headerRow);
          // Determine how many blank cells before the first day (Monday=0) adjusting for Sunday=6
          // In this implementation, Monday is first column; getDay() returns 0 for Sunday so convert
          let startWeekday = firstDay.getDay();
          startWeekday = (startWeekday + 6) % 7; // convert so Monday=0, Sunday=6
          let currentDay = 1;
          // Build rows until all days placed
          while (currentDay <= daysInMonth) {
            const row = document.createElement('tr');
            for (let i = 0; i < 7; i++) {
              const cell = document.createElement('td');
              cell.style.width = '14.28%';
              cell.style.height = '2rem';
              cell.style.border = '1px solid #f1f5f9';
              cell.style.textAlign = 'center';
              cell.style.fontSize = '0.75rem';
              if ((currentDay === 1 && i < startWeekday) || currentDay > daysInMonth) {
                // empty cell
                cell.textContent = '';
                cell.style.backgroundColor = '#f8fafc';
              } else {
                const hours = dailyHours[currentDay] || 0;
                // compute color intensity
                let color;
                if (hours <= 0 || maxHours === 0) {
                  color = '#f8fafc';
                } else {
                  const factor = Math.min(hours / maxHours, 1);
                  color = interpolateColor(lowColor, highColor, factor);
                }
                cell.style.backgroundColor = color;
                cell.textContent = currentDay;
                if (hours > 0) {
                  const hoursSpan = document.createElement('div');
                  hoursSpan.textContent = hours.toFixed(1) + 'h';
                  hoursSpan.style.fontSize = '0.6rem';
                  hoursSpan.style.color = '#0f172a';
                  cell.appendChild(hoursSpan);
                }
                currentDay++;
              }
              row.appendChild(cell);
            }
            table.appendChild(row);
          }
          heatmapDiv.appendChild(table);
        }

        // Populate the burndown project selector and render the initial burndown chart
        function updateBurndownSelect() {
          const select = document.getElementById('burndownProjectSelect');
          if (!select) return;
          // Prevent multiple event listeners by cloning without listeners
          const newSelect = select.cloneNode(false);
          select.parentNode.replaceChild(newSelect, select);
          data.projects.forEach(project => {
            const opt = document.createElement('option');
            opt.value = project.id;
            opt.textContent = project.name;
            newSelect.appendChild(opt);
          });
          newSelect.addEventListener('change', (e) => {
            renderBurndownChart(e.target.value);
          });
          // Render initial chart for first project (if any)
          if (data.projects.length > 0) {
            const firstId = data.projects[0].id;
            newSelect.value = firstId;
            renderBurndownChart(firstId);
          }
        }

        // Render the burndown chart for a given project ID. This charts cumulative hours worked
        // against the expected cumulative hours (linear budget burn) from project start to deadline.
        function renderBurndownChart(projectId) {
          const canvas = document.getElementById('burndownChart');
          if (!canvas || !Chart) return;
          const ctx = canvas.getContext('2d');
          // Destroy existing chart if present
          if (window.burndownChart) {
            try {
              window.burndownChart.destroy();
            } catch (err) {}
          }
          const project = data.projects.find(p => String(p.id) === String(projectId));
          if (!project) return;
          // Build date range from project start to today (or deadline, whichever is earlier)
          const startDate = new Date(project.createdAt);
          const today = new Date();
          const endDate = today < new Date(project.deadline) ? today : new Date(project.deadline);
          const days = [];
          for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
            // copy date to avoid reference issues
            days.push(new Date(d.getFullYear(), d.getMonth(), d.getDate()));
          }
          // Build labels and actual cumulative hours
          const labels = [];
          const actual = [];
          let cumulativeSeconds = 0;
          days.forEach(day => {
            labels.push(day.toISOString().slice(5, 10)); // 'MM-DD'
            // Sum durations for entries up to this day (inclusive)
            const dayEntries = data.entries.filter(e => {
              return e.projectId === projectId && !e.isRunning && new Date(e.startTime) <= day;
            });
            cumulativeSeconds = dayEntries.reduce((sum, e) => sum + (e.duration || 0), 0);
            actual.push((cumulativeSeconds / 3600));
          });
          // Expected cumulative line: linear interpolation from 0 to budget over total days until deadline
          const totalProjectDays = (new Date(project.deadline) - startDate) / (1000 * 60 * 60 * 24);
          const expected = [];
          days.forEach(day => {
            const diff = (day - startDate) / (1000 * 60 * 60 * 24);
            const ratio = totalProjectDays > 0 ? Math.min(diff / totalProjectDays, 1) : 0;
            expected.push(project.budgetHours * ratio);
          });
          // Create chart
          window.burndownChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Expected',
                  data: expected,
                  borderColor: '#64748b',
                  backgroundColor: '#64748b',
                  borderWidth: 2,
                  fill: false
                },
                {
                  label: 'Actual',
                  data: actual,
                  borderColor: project.color || '#3b82f6',
                  backgroundColor: project.color || '#3b82f6',
                  borderWidth: 2,
                  fill: false
                }
              ]
            },
            options: {
              responsive: true,
              plugins: {
                legend: {
                  display: true,
                  position: 'bottom'
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'Hours'
                  }
                },
                x: {
                  title: {
                    display: true,
                    text: 'Date'
                  }
                }
              }
            }
          });
        }

        // Projects page rendering
        function updateProjectsPage() {
          updateProjectSelects();
          renderProjectsPageList();
        }
        function renderProjectsPageList() {
          const container = document.getElementById('projectsPageList');
          container.innerHTML = '';
          if (data.projects.length === 0) {
            const p = document.createElement('p');
            p.textContent = 'No projects yet.';
            container.appendChild(p);
            return;
          }
          data.projects.forEach(project => {
            const stats = computeProjectStats(project);
            // Determine if this project is the recommended one for this week or month
            const isRecommendedWeekly = (project.id === currentRecommendedWeeklyId);
            const isRecommendedMonthly = (project.id === currentRecommendedMonthlyId);
            // Determine a human-friendly status label and color
            let statusLabel;
            if (stats.status === 'over-budget') statusLabel = 'Over Budget';
            else if (stats.status === 'behind-schedule') statusLabel = 'Behind Schedule';
            else if (stats.status === 'tight') statusLabel = 'Tight';
            else statusLabel = 'On Track';
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `
              <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">${project.name}</h3>
              <p style="margin:0 0 0.25rem 0;"><strong>Client:</strong> ${project.client || '-'}</p>
              <p style="margin:0 0 0.25rem 0;"><strong>Budget:</strong> ${project.budgetHours.toFixed(1)}h @ ${formatCurrency(project.hourlyRate)}</p>
              <div style="margin:0.5rem 0;">
                <!-- Dual progress bars showing actual hours vs expected timeline progress -->
                <div style="display:flex; flex-direction:column; gap:0.2rem; margin-bottom:0.25rem;">
                  <!-- Actual hours consumed (blue) -->
                  <div class="progress-bar"><div class="fill" style="width:${Math.min(100, stats.usedPct).toFixed(1)}%;"></div></div>
                  <!-- Expected progress based on time elapsed relative to deadline (black) -->
                  <div class="progress-bar"><div class="fill" style="width:${((stats.daysPassed + stats.daysLeft) > 0 ? (stats.daysPassed / (stats.daysPassed + stats.daysLeft)) * 100 : 0).toFixed(1)}%; background-color:#000000;"></div></div>
                </div>
                <small>${stats.totalHours.toFixed(1)}h used (${stats.usedPct.toFixed(1)}%) &bullet; Expected ${(stats.daysPassed + stats.daysLeft) > 0 ? (stats.daysPassed / (stats.daysPassed + stats.daysLeft) * 100).toFixed(1) : '0'}%</small>
              </div>
              <div style="margin:0.5rem 0;">
                <div class="progress-bar" style="margin-bottom:0.25rem;"><div class="fill" style="width:${stats.weeklyTargetConst ? (stats.weeklyHours / stats.weeklyTargetConst * 100) : 0}%"></div></div>
                <small>This week: ${stats.weeklyHours.toFixed(1)} / ${stats.weeklyTargetConst.toFixed(1)}h (target)</small>
              </div>
              <div style="margin:0.5rem 0;">
                <div class="progress-bar" style="margin-bottom:0.25rem;"><div class="fill" style="width:${stats.monthlyTargetConst ? (stats.monthlyHours / stats.monthlyTargetConst * 100) : 0}%"></div></div>
                <small>This month: ${stats.monthlyHours.toFixed(1)} / ${stats.monthlyTargetConst.toFixed(1)}h${isRecommendedMonthly ? ' (Recommended)' : ''} (target)</small>
              </div>
              <p style="margin:0.25rem 0;"><strong>Deadline:</strong> ${formatDate(project.deadline)}</p>
              <p style="margin:0.25rem 0;"><strong>Status:</strong> <span class="status-badge ${stats.statusColor || 'green'}"${stats.reason ? ` title="${stats.reason}"` : ''}>${statusLabel}</span></p>
              <div style="display:flex; gap:0.5rem; margin-top:0.5rem;">
                <button class="btn secondary edit-btn" data-id="${project.id}">Edit</button>
                <button class="btn danger delete-btn" data-id="${project.id}">Delete</button>
              </div>
            `;
            // Edit button handler
            const editBtn = card.querySelector('.edit-btn');
            editBtn.addEventListener('click', () => {
              // Prompt the user for new project details
              const newName = prompt('Project Name:', project.name);
              if (!newName) return;
              const newClient = prompt('Client (optional):', project.client || '');
              const newBudgetStr = prompt('Budget Hours:', project.budgetHours.toFixed(1));
              const newBudget = parseFloat(newBudgetStr);
              if (isNaN(newBudget)) return;
              const newRateStr = prompt('Hourly Rate:', project.hourlyRate.toFixed(2));
              const newRate = parseFloat(newRateStr);
              if (isNaN(newRate)) return;
              const newDeadline = prompt('Deadline (YYYY-MM-DD):', project.deadline);
              if (!newDeadline) return;
              // Prompt for rounding preference (minutes) and update roundingMinutes
              const newRoundingStr = prompt('Rounding (minutes – 0 for none, 5, 10, 15):', project.roundingMinutes != null ? project.roundingMinutes.toString() : '0');
              const newRoundingInt = parseInt(newRoundingStr, 10);
              // If the user cancels or enters invalid number, leave rounding unchanged
              if (!isNaN(newRoundingInt)) {
                project.roundingMinutes = newRoundingInt;
              }
              // Update project fields
              project.name = newName.trim();
              project.client = newClient ? newClient.trim() : null;
              project.budgetHours = newBudget;
              project.hourlyRate = newRate;
              project.deadline = newDeadline;
              saveData();
              updateProjectsPage();
              updateProjectSelects();
              updateDashboard();
            });
            // Delete button handler
            const deleteBtn = card.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', () => {
              if (confirm('Delete this project and its entries?')) {
                data.projects = data.projects.filter(p => p.id !== project.id);
                data.entries = data.entries.filter(e => e.projectId !== project.id);
                saveData();
                updateProjectsPage();
                updateDashboard();
              }
            });
            container.appendChild(card);
          });
        }

        // Create new project
        document.getElementById('projectFormPro').addEventListener('submit', (e) => {
          e.preventDefault();
          const name = document.getElementById('projectNamePro').value.trim();
          const client = document.getElementById('projectClientPro').value.trim();
          const budget = parseFloat(document.getElementById('projectBudgetPro').value);
          const rate = parseFloat(document.getElementById('projectRatePro').value);
          const deadline = document.getElementById('projectDeadlinePro').value;
          if (!name || !deadline) return;
          const newProject = {
            id: uuid(),
            name,
            client: client || null,
            budgetHours: budget,
            hourlyRate: rate,
            deadline,
            createdAt: new Date().toISOString(),
            color: getUniqueColor(),
            isActive: true,
            // Store rounding preference for this project; roundingMinutes is the interval in minutes (0 means no rounding)
            roundingMinutes: parseInt(document.getElementById('projectRoundingPro').value, 10) || 0
          };
          data.projects.push(newProject);
          saveData();
          e.target.reset();
          updateProjectsPage();
          updateProjectSelects();
          updateDashboard();
        });

        // Color generator for project dots. Ensures uniqueness by selecting an unused color when possible.
        function getRandomColor() {
          const palette = ['#2563eb', '#dc2626', '#10b981', '#8b5cf6', '#f59e0b', '#ec4899'];
          return palette[Math.floor(Math.random() * palette.length)];
        }

        function getUniqueColor() {
          const palette = ['#2563eb', '#dc2626', '#10b981', '#8b5cf6', '#f59e0b', '#ec4899'];
          // Collect colors already used by existing projects
          const used = new Set(data.projects.map(p => p.color).filter(c => c));
          // Find a color not used yet
          for (const col of palette) {
            if (!used.has(col)) {
              return col;
            }
          }
          // If all colors are used, return a random one
          return palette[Math.floor(Math.random() * palette.length)];
        }

        // Timer section functions (reuse from previous implementation but adjust IDs)
        function getRunningEntries() {
          // Return an array of all entries that are currently running
          return data.entries.filter(e => e.isRunning);
        }
        function updateTimerSection() {
          const runningEntries = getRunningEntries();
          const runningDiv = document.getElementById('runningTimerPro');
          const startDiv = document.getElementById('startTimerPro');
          // Clear any previous interval that updated timers
          clearInterval(timerInterval);
          if (runningEntries.length > 0) {
            // Show the running timers section
            runningDiv.style.display = '';
            // Keep the start form visible to allow starting additional timers
            startDiv.style.display = '';
            // Clear and rebuild the running timers list
            runningDiv.innerHTML = '';
            // Heading for running timers
            const heading = document.createElement('h3');
            heading.textContent = 'Running Timers';
            heading.style.margin = '0 0 0.5rem 0';
            heading.style.fontSize = '1.1rem';
            heading.style.fontWeight = '600';
            runningDiv.appendChild(heading);
            // Display total earnings for all running timers
            const totalEarnedP = document.createElement('p');
            totalEarnedP.innerHTML = '<strong>Total Earned:</strong> <span id="runningTotalEarned"></span>';
            totalEarnedP.style.marginBottom = '0.5rem';
            runningDiv.appendChild(totalEarnedP);
            // Add a "Stop All Timers" button to allow stopping all timers at once
            const stopAllBtn = document.createElement('button');
            stopAllBtn.className = 'btn danger';
            stopAllBtn.textContent = 'Stop All Timers';
            stopAllBtn.style.marginBottom = '0.75rem';
            stopAllBtn.addEventListener('click', () => {
              stopAllTimers();
            });
            runningDiv.appendChild(stopAllBtn);
            // Render each running entry
            runningEntries.forEach(entry => {
              const project = data.projects.find(p => p.id === entry.projectId);
              const row = document.createElement('div');
              row.style.marginBottom = '0.75rem';
              // Project name
              const nameP = document.createElement('p');
              nameP.innerHTML = '<strong>Project:</strong> ' + (project ? project.name : '');
              row.appendChild(nameP);
              // Started time
              const startP = document.createElement('p');
              startP.innerHTML = '<strong>Started:</strong> ' + formatDateTime(entry.startTime);
              row.appendChild(startP);
              // Elapsed time
              const elapsedP = document.createElement('p');
              elapsedP.innerHTML = '<strong>Elapsed:</strong> ';
              const elapsedSpan = document.createElement('span');
              elapsedSpan.id = 'runningElapsed-' + entry.id;
              elapsedSpan.textContent = '';
              elapsedP.appendChild(elapsedSpan);
              row.appendChild(elapsedP);
              // Factor display (e.g. 100%, 75%)
              const factorP = document.createElement('p');
              factorP.innerHTML = '<strong>Factor:</strong> ';
              const factorSpan = document.createElement('span');
              factorSpan.id = 'runningFactor-' + entry.id;
              factorSpan.textContent = '';
              factorP.appendChild(factorSpan);
              row.appendChild(factorP);
              // Factor override selector. Allows the user to override the concurrency factor
              const overrideP = document.createElement('p');
              overrideP.innerHTML = '<strong>Override:</strong> ';
              const factorSelect = document.createElement('select');
              factorSelect.style.marginLeft = '0.25rem';
              // Default option for automatic concurrency (no override)
              const optDef = document.createElement('option');
              optDef.value = '';
              optDef.textContent = 'Auto';
              factorSelect.appendChild(optDef);
              // Predefined override options
              [
                ['1', '100%'],
                ['0.75', '75%'],
                ['0.5', '50%'],
                ['0.25', '25%']
              ].forEach(([val, label]) => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.textContent = label;
                factorSelect.appendChild(opt);
              });
              // Set current selection based on manualFactor
              if (entry.manualFactor) {
                factorSelect.value = String(entry.manualFactor);
              } else {
                factorSelect.value = '';
              }
              factorSelect.addEventListener('change', () => {
                const v = factorSelect.value;
                // Before changing the factor, accumulate time elapsed since last update
                const now = new Date();
                const lastUpdate = entry.lastUpdateTime ? new Date(entry.lastUpdateTime) : new Date(entry.startTime);
                const elapsedSec = (now - lastUpdate) / 1000;
                // Use current factor (manual override or concurrency) to update effective seconds
                const currentFactor = entry.factor || computeConcurrencyFactor(getRunningEntries().length);
                entry.effectiveSeconds = (entry.effectiveSeconds || 0) + elapsedSec * currentFactor;
                // Update last update timestamp to now
                entry.lastUpdateTime = now.toISOString();
                // Apply new override or restore automatic factor
                if (!v) {
                  // Remove override: restore concurrency factor based on current running count
                  entry.manualFactor = null;
                  const count = getRunningEntries().length;
                  entry.factor = computeConcurrencyFactor(count);
                } else {
                  const fVal = parseFloat(v);
                  entry.manualFactor = fVal;
                  entry.factor = fVal;
                }
                saveData();
                // Refresh the timer section to apply the new factor
                updateTimerSection();
                // Recompute focus blocker activation in case total factor changed
                updateFocusBlocker();
              });
              overrideP.appendChild(factorSelect);
              row.appendChild(overrideP);
              // Earned display
              const earnP = document.createElement('p');
              earnP.innerHTML = '<strong>Earned:</strong> ';
              const earnSpan = document.createElement('span');
              earnSpan.id = 'runningEarned-' + entry.id;
              earnSpan.textContent = '';
              earnP.appendChild(earnSpan);
              row.appendChild(earnP);
              // Nudge controls: allow the user to adjust elapsed time in 5 minute increments
              const nudgeDiv = document.createElement('div');
              nudgeDiv.style.display = 'flex';
              nudgeDiv.style.gap = '0.25rem';
              // Minus 5 minutes button
              const minusBtn = document.createElement('button');
              minusBtn.className = 'btn secondary';
              minusBtn.textContent = '-5m';
              minusBtn.style.padding = '0.25rem 0.5rem';
              minusBtn.style.fontSize = '0.75rem';
              minusBtn.addEventListener('click', () => {
                // Compute elapsed time since last update and update effective seconds first
                const now = new Date();
                const lastUpdate = entry.lastUpdateTime ? new Date(entry.lastUpdateTime) : new Date(entry.startTime);
                const elapsedSec = (now - lastUpdate) / 1000;
                // Use current factor (manual override or concurrency) to update effective seconds
                const currentFactor = entry.manualFactor != null ? entry.manualFactor : (entry.factor || computeConcurrencyFactor(getRunningEntries().length));
                entry.effectiveSeconds = (entry.effectiveSeconds || 0) + elapsedSec * currentFactor;
                entry.lastUpdateTime = now.toISOString();
                // Subtract 5 minutes of actual time from effectiveSeconds taking into account factor
                const delta = 300 * currentFactor;
                entry.effectiveSeconds = Math.max(0, (entry.effectiveSeconds || 0) - delta);
                saveData();
                updateTimerSection();
                provideHaptic('beep');
              });
              nudgeDiv.appendChild(minusBtn);
              // Plus 5 minutes button
              const plusBtn = document.createElement('button');
              plusBtn.className = 'btn secondary';
              plusBtn.textContent = '+5m';
              plusBtn.style.padding = '0.25rem 0.5rem';
              plusBtn.style.fontSize = '0.75rem';
              plusBtn.addEventListener('click', () => {
                // Compute elapsed time since last update and update effective seconds first
                const now = new Date();
                const lastUpdate = entry.lastUpdateTime ? new Date(entry.lastUpdateTime) : new Date(entry.startTime);
                const elapsedSec = (now - lastUpdate) / 1000;
                const currentFactor = entry.manualFactor != null ? entry.manualFactor : (entry.factor || computeConcurrencyFactor(getRunningEntries().length));
                entry.effectiveSeconds = (entry.effectiveSeconds || 0) + elapsedSec * currentFactor;
                entry.lastUpdateTime = now.toISOString();
                // Add 5 minutes of actual time to effectiveSeconds, scaled by factor
                const delta = 300 * currentFactor;
                entry.effectiveSeconds = (entry.effectiveSeconds || 0) + delta;
                saveData();
                updateTimerSection();
                provideHaptic('beep');
              });
              nudgeDiv.appendChild(plusBtn);
              row.appendChild(nudgeDiv);
              // Stop button
              const stopBtn = document.createElement('button');
              stopBtn.className = 'btn danger';
              stopBtn.textContent = 'Stop';
              stopBtn.addEventListener('click', () => {
                stopSingleTimer(entry.id);
              });
              row.appendChild(stopBtn);
              runningDiv.appendChild(row);
            });
            // Start an interval that updates all running timers every second
            const tick = () => {
              const now = new Date();
              let totalEarned = 0;
              runningEntries.forEach(entry => {
                // Compute effective elapsed time: accumulate effectiveSeconds plus time since last update times current factor
                const last = entry.lastUpdateTime ? new Date(entry.lastUpdateTime) : new Date(entry.startTime);
                const prev = entry.effectiveSeconds || 0;
                const factor = entry.factor || computeConcurrencyFactor(runningEntries.length);
                const extra = (now - last) / 1000 * factor;
                const effective = prev + extra;
                // Update elapsed display
                const elapsedSpan = document.getElementById('runningElapsed-' + entry.id);
                if (elapsedSpan) elapsedSpan.textContent = formatDuration(Math.floor(effective));
                // Update factor display as percentage
                const factorSpan = document.getElementById('runningFactor-' + entry.id);
                if (factorSpan) factorSpan.textContent = Math.round(factor * 100) + '%';
                // Compute earned amount for this entry based on the project hourly rate
                const project = data.projects.find(p => p.id === entry.projectId);
                let earned = 0;
                if (project) {
                  earned = (effective / 3600) * (project.hourlyRate || 0);
                }
                const earnSpan = document.getElementById('runningEarned-' + entry.id);
                if (earnSpan) earnSpan.textContent = formatCurrency(earned, 0);
                totalEarned += earned;
              });
              // Update total earned across all running timers
              const totalSpan = document.getElementById('runningTotalEarned');
              if (totalSpan) totalSpan.textContent = formatCurrency(totalEarned, 0);
            };
            tick();
            timerInterval = setInterval(tick, 1000);
          } else {
            // No running entries: hide running timer section and show start form
            runningDiv.style.display = 'none';
            runningDiv.innerHTML = '';
            startDiv.style.display = '';
          }
          // update project selects
          updateProjectSelects();
        }

        // Stop a single running timer by id
        function stopSingleTimer(entryId) {
          const toStop = data.entries.find(e => e.id === entryId && e.isRunning);
          // Provide tactile feedback when stopping a timer
          provideHaptic('long');
          if (!toStop) return;
          const now = new Date();
          // Gather all running entries including the one to stop
          const runningEntries = getRunningEntries();
          const n = runningEntries.length;
          // First update effective seconds for all running entries using their current factor
          runningEntries.forEach(e => {
            const last = e.lastUpdateTime ? new Date(e.lastUpdateTime) : new Date(e.startTime);
            const elapsedSec = (now - last) / 1000;
            const prevFactor = e.factor || computeConcurrencyFactor(n);
            e.effectiveSeconds = (e.effectiveSeconds || 0) + elapsedSec * prevFactor;
            e.lastUpdateTime = now.toISOString();
          });
          // Finalize the stopped entry
          const finalSeconds = toStop.effectiveSeconds || 0;
          toStop.endTime = now.toISOString();
          toStop.duration = Math.floor(finalSeconds);
          toStop.isRunning = false;
          // Cleanup weighted fields (optional)
          delete toStop.effectiveSeconds;
          delete toStop.lastUpdateTime;
          delete toStop.factor;
          // Compute new concurrency factor for remaining running timers after removal
          const remaining = runningEntries.filter(e => e.id !== entryId);
          const newCount = remaining.length;
          const newFactor = computeConcurrencyFactor(newCount);
          // Update remaining running entries: assign new factor only if no manual override
          remaining.forEach(e => {
            if (!e.manualFactor) {
              e.factor = newFactor;
            }
            e.lastUpdateTime = now.toISOString();
          });
          // Persist and refresh
          saveData();
          updateTimerSection();
          updateDashboard();
          updateEntriesTable();
          // Do not immediately save backup here; periodic auto‑sync will handle exporting
          // Recompute focus blocker activation after stopping this timer. If the total
          // factor has dropped below or equal to 50%, the blocker will be disabled.
          updateFocusBlocker();
        }
        let timerInterval = null;
        // Chart instances for weekly and monthly scatter plots
        let weeklyScatterChart = null;
        let monthlyScatterChart = null;
        document.getElementById('startTimerBtnPro').addEventListener('click', () => {
          const projectId = document.getElementById('timerProjectPro').value;
          // Hours already spent when starting the timer (pre-filled time)
          const initialHours = parseFloat(document.getElementById('timerInitialPro').value) || 0;
          if (!projectId) return;
          // Check if there's already a running timer for this project
          const runningEntries = getRunningEntries();
          // Prevent starting multiple timers for the same project. Compare string representations of IDs to avoid mismatches.
          if (runningEntries.some(e => String(e.projectId) === String(projectId))) {
            alert('A timer is already running for this project. You cannot start another timer for the same project.');
            return;
          }
          // No immediate focus start here; activation of focus mode will be handled
          // by updateFocusBlocker() based on the total factor of running timers.

          // Provide tactile feedback when starting a timer
          provideHaptic('long');
          const now = new Date();
          // Determine override factor selected by the user (if any)
          const overrideVal = document.getElementById('startFactorPro').value;
          // Compute the new concurrency count including the new entry
          const newConcurrencyCount = runningEntries.length + 1;
          // Compute the concurrency factor that would apply if no override is used
          const autoFactor = computeConcurrencyFactor(newConcurrencyCount);
          // Update all existing running entries: accumulate effective seconds and set new factor
          runningEntries.forEach(e => {
            const last = e.lastUpdateTime ? new Date(e.lastUpdateTime) : new Date(e.startTime);
            const elapsedSec = (now - last) / 1000;
            const prevFactor = e.factor || computeConcurrencyFactor(runningEntries.length);
            e.effectiveSeconds = (e.effectiveSeconds || 0) + elapsedSec * prevFactor;
            e.lastUpdateTime = now.toISOString();
            // For timers without manual override, assign the new concurrency factor
            if (!e.manualFactor) {
              e.factor = autoFactor;
            }
          });
          // Create new entry for the selected project
          const realStart = new Date(now.getTime() - initialHours * 3600 * 1000);
          // Determine the factor for the new entry: manual override or auto
          let newEntryFactor;
          let newEntryManual = null;
          if (overrideVal) {
            newEntryFactor = parseFloat(overrideVal);
            newEntryManual = newEntryFactor;
          } else {
            newEntryFactor = autoFactor;
            newEntryManual = null;
          }
          const newEntry = {
            id: uuid(),
            projectId,
            description: '',
            startTime: realStart.toISOString(),
            endTime: null,
            duration: null,
            isRunning: true,
            createdAt: now.toISOString(),
            effectiveSeconds: initialHours * 3600,
            lastUpdateTime: now.toISOString(),
            factor: newEntryFactor,
            manualFactor: newEntryManual
          };
          data.entries.push(newEntry);
          // Reset initial input and focus factor selection
          document.getElementById('timerInitialPro').value = '';
          document.getElementById('startFactorPro').value = '';
          saveData();
          // Update UI and timers
          updateProjectSelects();
          updateTimerSection();
          updateDashboard();
          // After adding the new entry, update the focus blocker based on the new total factor
          updateFocusBlocker();
        });
        document.getElementById('stopTimerBtnPro').addEventListener('click', () => {
          stopAllTimers();
        });

        // Stop all running timers at once, updating their weighted durations consistently
        function stopAllTimers() {
          const runningList = getRunningEntries();
          if (runningList.length === 0) return;
          const now = new Date();
          const n = runningList.length;
          // Update effective seconds for all entries using their current factors
          runningList.forEach(e => {
            const last = e.lastUpdateTime ? new Date(e.lastUpdateTime) : new Date(e.startTime);
            const elapsedSec = (now - last) / 1000;
            const prevFactor = e.factor || computeConcurrencyFactor(n);
            e.effectiveSeconds = (e.effectiveSeconds || 0) + elapsedSec * prevFactor;
            e.lastUpdateTime = now.toISOString();
          });
          // Finalize each entry: set duration, endTime, isRunning
          runningList.forEach(e => {
            // Compute raw duration in seconds
            let rawDuration = Math.floor(e.effectiveSeconds || 0);
            // Apply rounding based on project rounding preference
            const projR = data.projects.find(p => String(p.id) === String(e.projectId));
            if (projR && projR.roundingMinutes && projR.roundingMinutes > 0) {
              const rounding = projR.roundingMinutes;
              const minutes = rawDuration / 60;
              const roundedMinutes = Math.round(minutes / rounding) * rounding;
              rawDuration = Math.floor(roundedMinutes * 60);
            }
            e.duration = rawDuration;
            e.endTime = now.toISOString();
            e.isRunning = false;
            delete e.effectiveSeconds;
            delete e.lastUpdateTime;
            delete e.factor;
          });
          saveData();
          updateTimerSection();
          updateDashboard();
          updateEntriesTable();
          // Do not immediately save backup here; periodic auto‑sync will handle exporting
          // After stopping all timers, recompute focus blocker activation based on total factor
          updateFocusBlocker();
        }

        // Update project selects for timer and manual forms
        function updateProjectSelects() {
          const timerSelect = document.getElementById('timerProjectPro');
          const manualSelect = document.getElementById('manualProjectPro');
          timerSelect.innerHTML = '';
          manualSelect.innerHTML = '';
          if (data.projects.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = '-- no projects --';
            timerSelect.appendChild(opt);
            manualSelect.appendChild(opt.cloneNode(true));
            document.getElementById('startTimerBtnPro').disabled = true;
            return;
          }
          // Sort projects based on monthly budget urgency rather than alphabetically. We compute the
          // deficit between the dynamic monthly target and the hours worked so far this month. Projects
          // with larger positive deficits (i.e., those most behind on their monthly target) are shown
          // first. Negative deficits (projects ahead of their monthly target) will appear later. If two
          // projects have the same deficit, preserve original order. After sorting, if there is a
          // recommended monthly project, move it to the top regardless of deficit.
          const sortedProjects = data.projects.slice().sort((a, b) => {
            let defA = 0; let defB = 0;
            try {
              const sa = computeProjectStats(a);
              const sb = computeProjectStats(b);
              defA = (sa.monthlyTargetConst || 0) - (sa.monthlyHours || 0);
              defB = (sb.monthlyTargetConst || 0) - (sb.monthlyHours || 0);
            } catch (err) {
              return 0;
            }
            if (defB > defA) return 1;
            if (defB < defA) return -1;
            return 0;
          });
          // If there is a recommended monthly project, ensure it appears at the top
          if (currentRecommendedMonthlyId) {
            const idx = sortedProjects.findIndex(p => p.id === currentRecommendedMonthlyId);
            if (idx > 0) {
              const [recProj] = sortedProjects.splice(idx, 1);
              sortedProjects.unshift(recProj);
            }
          }
          sortedProjects.forEach(project => {
            // First option for timer select with possible recommendation hint
            const o1 = document.createElement('option');
            o1.value = project.id;
            let label = project.name;
            // If this project is the monthly recommended project, append a hint about how many hours are needed this month
            if (project.id === currentRecommendedMonthlyId) {
              const sp = computeProjectStats(project);
              let monthlyNeeded = (sp.monthlyTargetConst || 0) - (sp.monthlyHours || 0);
              if (monthlyNeeded < 0) monthlyNeeded = 0;
              label += ' (Recommended, needs ~' + monthlyNeeded.toFixed(1) + 'h this month)';
            }
            o1.textContent = label;
            timerSelect.appendChild(o1);
            // Second option for manual entry select (no recommendation hint)
            const o2 = document.createElement('option');
            o2.value = project.id;
            o2.textContent = project.name;
            manualSelect.appendChild(o2);
          });
          // Disable timer options for projects that already have a running timer
          const runningProjects = getRunningEntries().map(e => e.projectId);
          timerSelect.querySelectorAll('option').forEach(opt => {
            const shouldDisable = runningProjects.some(id => String(id) === String(opt.value));
            opt.disabled = shouldDisable;
          });
          document.getElementById('startTimerBtnPro').disabled = false;
        }
        // Manual entry add/cancel
        document.getElementById('addManualEntryBtnPro').addEventListener('click', () => {
          document.getElementById('manualEntryFormPro').classList.remove('hidden');
        });
        document.getElementById('cancelManualBtnPro').addEventListener('click', () => {
          document.getElementById('manualEntryFormPro').classList.add('hidden');
          document.getElementById('manualFormPro').reset();
        });
        document.getElementById('manualFormPro').addEventListener('submit', (e) => {
          e.preventDefault();
          const projectId = document.getElementById('manualProjectPro').value;
          const description = document.getElementById('manualDescriptionPro').value.trim();
          const hoursVal = parseFloat(document.getElementById('manualHoursPro').value);
          if (!projectId || isNaN(hoursVal) || hoursVal <= 0) return;
          const now = new Date();
          // Apply rounding based on project preferences. If the project specifies a rounding interval (minutes),
          // we round the hours to the nearest interval before converting to seconds.
          let adjustedHours = hoursVal;
          const projForRound = data.projects.find(p => String(p.id) === String(projectId));
          if (projForRound && projForRound.roundingMinutes && projForRound.roundingMinutes > 0) {
            const rounding = projForRound.roundingMinutes;
            const minutesVal = hoursVal * 60;
            const roundedMinutes = Math.round(minutesVal / rounding) * rounding;
            adjustedHours = roundedMinutes / 60;
          }
          const durationSeconds = Math.floor(adjustedHours * 3600);
          // start time is computed as end time minus duration
          const startTime = new Date(now.getTime() - durationSeconds * 1000);
          const newEntry = {
            id: uuid(),
            projectId,
            description,
            startTime: startTime.toISOString(),
            endTime: now.toISOString(),
            duration: durationSeconds,
            isRunning: false,
            createdAt: now.toISOString()
          };
          data.entries.push(newEntry);
          saveData();
          e.target.reset();
          document.getElementById('manualEntryFormPro').classList.add('hidden');
          updateEntriesTable();
          updateDashboard();
          updateProjectsPage();
        });

        // Toggle between showing all entries and only recent entries (last 30 days). When
        // showing only recent entries, the button text reads "Show All". When
        // showing all entries, it reads "Show Recent". Clicking the button
        // toggles the view and re-renders the entries table.
        const toggleEntriesBtn = document.getElementById('toggleEntriesViewBtn');
        if (toggleEntriesBtn) {
          toggleEntriesBtn.addEventListener('click', () => {
            showAllEntries = !showAllEntries;
            toggleEntriesBtn.textContent = showAllEntries ? 'Show Recent' : 'Show All';
            updateEntriesTable();
          });
        }

        // Nudge buttons for manual entry: adjust hours by ±5 minutes
        const minusBtn = document.getElementById('manualMinus5Btn');
        const plusBtn = document.getElementById('manualPlus5Btn');
        if (minusBtn && plusBtn) {
          minusBtn.addEventListener('click', () => {
            // Provide a short beep when nudging entry time
            provideHaptic('beep');
            const hoursInput = document.getElementById('manualHoursPro');
            let current = parseFloat(hoursInput.value) || 0;
            current -= (5 / 60);
            if (current < 0) current = 0;
            hoursInput.value = current.toFixed(2);
          });
          plusBtn.addEventListener('click', () => {
            provideHaptic('beep');
            const hoursInput = document.getElementById('manualHoursPro');
            let current = parseFloat(hoursInput.value) || 0;
            current += (5 / 60);
            hoursInput.value = current.toFixed(2);
          });
        }

        // Delete entry
        function deleteEntry(id) {
          data.entries = data.entries.filter(e => e.id !== id);
          saveData();
          updateEntriesTable();
          updateDashboard();
          updateProjectsPage();
        }

        // Entries table
        function updateEntriesTable() {
          const tbody = document.getElementById('entriesTableBodyPro');
          tbody.innerHTML = '';
          if (data.entries.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 7;
            td.textContent = 'No entries yet.';
            td.style.textAlign = 'center';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
          }
          // Decide which entries to show. If showAllEntries is false, only include entries
          // whose start or end times are within the past 30 days. Otherwise include all.
          let entriesToShow = data.entries;
          if (!showAllEntries) {
            const cutoff = new Date();
            // Set cutoff to 30 days ago
            cutoff.setDate(cutoff.getDate() - 30);
            entriesToShow = data.entries.filter(e => {
              const startDate = new Date(e.startTime);
              const endDate = e.endTime ? new Date(e.endTime) : startDate;
              return startDate >= cutoff || endDate >= cutoff;
            });
          }
          // sort by start time desc
          const sorted = [...entriesToShow].sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
          sorted.forEach(entry => {
            const tr = document.createElement('tr');
            const project = data.projects.find(p => p.id === entry.projectId);
            const hours = entry.duration ? entry.duration / 3600 : 0;
            const total = project ? hours * project.hourlyRate : 0;
            tr.innerHTML = `
              <td>${project ? project.name : ''}</td>
              <td>${entry.description || ''}</td>
              <td>${formatDateTime(entry.startTime)}</td>
              <td>${entry.endTime ? formatDateTime(entry.endTime) : (entry.isRunning ? '—' : '')}</td>
              <td>${entry.duration ? formatDuration(entry.duration) : (entry.isRunning ? 'Running…' : '')}</td>
              <td>${formatCurrency(total)}</td>
              <td></td>
            `;
            // Action cell: add nudge and snap controls plus delete button
            const actionsTd = tr.lastElementChild;
            // −5m button
            const minusBtn = document.createElement('button');
            minusBtn.className = 'btn secondary';
            minusBtn.style.padding = '0.25rem 0.5rem';
            minusBtn.style.fontSize = '0.7rem';
            minusBtn.textContent = '−5m';
            minusBtn.addEventListener('click', () => {
              // Provide quick beep feedback
              provideHaptic('beep');
              // Subtract 5 minutes (300 seconds) from the entry duration
              let newDur = (entry.duration || 0) - 300;
              if (newDur < 0) newDur = 0;
              entry.duration = newDur;
              // Update endTime based on new duration
              const start = new Date(entry.startTime);
              entry.endTime = new Date(start.getTime() + newDur * 1000).toISOString();
              saveData();
              updateEntriesTable();
              updateDashboard();
              updateProjectsPage();
              updateTimerSection();
            });
            actionsTd.appendChild(minusBtn);
            // +5m button
            const plusBtn = document.createElement('button');
            plusBtn.className = 'btn secondary';
            plusBtn.style.padding = '0.25rem 0.5rem';
            plusBtn.style.fontSize = '0.7rem';
            plusBtn.style.marginLeft = '0.25rem';
            plusBtn.textContent = '+5m';
            plusBtn.addEventListener('click', () => {
              provideHaptic('beep');
              // Add 5 minutes to the duration
              let newDur = (entry.duration || 0) + 300;
              entry.duration = newDur;
              const start = new Date(entry.startTime);
              entry.endTime = new Date(start.getTime() + newDur * 1000).toISOString();
              saveData();
              updateEntriesTable();
              updateDashboard();
              updateProjectsPage();
              updateTimerSection();
            });
            actionsTd.appendChild(plusBtn);
            // Snap selector: choose nearest minutes (5,10,15)
            const snapSelect = document.createElement('select');
            snapSelect.style.marginLeft = '0.25rem';
            snapSelect.style.padding = '0.25rem';
            snapSelect.style.fontSize = '0.7rem';
            snapSelect.style.border = '1px solid #cbd5e1';
            snapSelect.style.borderRadius = '0.375rem';
            // Placeholder option
            const placeholderOption = document.createElement('option');
            placeholderOption.value = '';
            placeholderOption.textContent = 'Snap';
            snapSelect.appendChild(placeholderOption);
            [5,10,15].forEach(mins => {
              const opt = document.createElement('option');
              opt.value = String(mins);
              opt.textContent = mins + 'm';
              snapSelect.appendChild(opt);
            });
            snapSelect.addEventListener('change', () => {
              const val = parseInt(snapSelect.value);
              if (!isNaN(val) && val > 0) {
                const minutes = (entry.duration || 0) / 60;
                const snappedMinutes = Math.round(minutes / val) * val;
                entry.duration = Math.max(0, Math.floor(snappedMinutes * 60));
                const start = new Date(entry.startTime);
                entry.endTime = new Date(start.getTime() + entry.duration * 1000).toISOString();
                saveData();
                updateEntriesTable();
                updateDashboard();
                updateProjectsPage();
                updateTimerSection();
              }
              // reset to placeholder
              snapSelect.value = '';
            });
            actionsTd.appendChild(snapSelect);
            // Delete button
            const delBtn = document.createElement('button');
            delBtn.className = 'btn danger';
            delBtn.style.padding = '0.25rem 0.5rem';
            delBtn.style.fontSize = '0.7rem';
            delBtn.style.marginLeft = '0.25rem';
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', () => {
              if (confirm('Delete this entry?')) deleteEntry(entry.id);
            });
            actionsTd.appendChild(delBtn);
            tbody.appendChild(tr);
          });
        }

        // Export / Import
        document.getElementById('exportBtnPro').addEventListener('click', () => {
          // Use shared downloadData function for exports
          downloadData();
        });
        document.getElementById('importInputPro').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const text = await file.text();
          try {
            const imported = JSON.parse(text);
            if (!Array.isArray(imported.projects) || !Array.isArray(imported.entries)) {
              alert('Invalid data format');
              return;
            }
            data = imported;
            // Remove any transient timer fields (effectiveSeconds, lastUpdateTime, factor) from imported entries
            data.entries.forEach(entry => {
              delete entry.effectiveSeconds;
              delete entry.lastUpdateTime;
              delete entry.factor;
            });
            // Assign colors to projects without color and ensure uniqueness
            let colorChanged = false;
            data.projects.forEach(p => {
              if (!p.color) {
                p.color = getUniqueColor();
                colorChanged = true;
              }
            });
            if (colorChanged) {
              saveData();
            } else {
              // Save imported data even if colors did not change
              saveData();
            }
            // Refresh UI
            updateDashboard();
            updateProjectsPage();
            updateEntriesTable();
            updateTimerSection();
            alert('Data imported successfully');
          } catch (err) {
            alert('Failed to import: ' + err.message);
          }
        });

        // Initial render
        updateProjectSelects();
        updateEntriesTable();
        updateProjectsPage();
        updateDashboard();
        updateTimerSection();
        // Programmatically activate the Timer tab on first load. This ensures the Timer
        // section is displayed instead of the Dashboard when the page is opened. We
        // simulate a click on the Timer navigation item which will trigger the
        // navigation handler to set the active class and hide/show sections.
        const timerNavItem = document.querySelector('#navList li[data-section="timer"]');
        if (timerNavItem) {
          timerNavItem.click();
        }

        // Initialize auto sync toggle and status message
        const autoSyncToggle = document.getElementById('autoSyncToggle');
        const autoSyncStatusElem = document.getElementById('autoSyncStatus');
        function updateAutoSyncStatus() {
          if (!autoSyncStatusElem) return;
          if (autoSyncEnabled) {
            // If we have a handle, we can show that backup is configured. Otherwise, if a backup
            // directory name exists in our persisted data, display that name to inform the user
            // which folder was previously selected. Note: we cannot auto‑open the folder without
            // user interaction, but we can reassure the user that their selection is remembered.
            if (backupDirHandle) {
              const name = backupDirHandle.name || (data && data.backupDirName) || '';
              autoSyncStatusElem.textContent = name
                ? `Auto sync is ON. Writing to “${name}”.`
                : 'Auto sync is ON. Writing to your selected backup folder.';
            } else {
              // Fallback: use the stored backup directory name from data if available
              const name = (data && data.backupDirName) || '';
              autoSyncStatusElem.textContent = name
                ? `Auto sync is ON. Backup folder “${name}” remembered — reselect to activate.`
                : 'Auto sync is ON. Changes will be periodically saved when a backup folder is selected.';
            }
          } else {
            autoSyncStatusElem.textContent = 'Auto sync is OFF.';
          }
        }
        if (autoSyncToggle) {
          autoSyncToggle.checked = autoSyncEnabled;
          updateAutoSyncStatus();
          autoSyncToggle.addEventListener('change', () => {
            autoSyncEnabled = autoSyncToggle.checked;
            localStorage.setItem('autoSyncEnabledPro', autoSyncEnabled);
            updateAutoSyncStatus();
            // If user just enabled auto sync but no backup folder is set, prompt them to choose one.
            if (autoSyncEnabled && !backupDirHandle) {
              chooseBackupDir();
            }
          });
        }

        // Set Backup Folder button: prompts the user to pick a directory for backups. When
        // auto sync is enabled and no directory is selected, clicking this button
        // will call chooseBackupDir(). If auto sync is disabled, this button remains
        // functional to allow the user to preselect a folder before enabling auto sync.
        const chooseBtn = document.getElementById('chooseBackupDirBtn');
        if (chooseBtn) {
          chooseBtn.addEventListener('click', () => {
            chooseBackupDir();
          });
        }
      })();
    </script>
  </body>
</html>