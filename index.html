<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TimeKeeper Pro – Offline</title>
    <!-- Chart.js for graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="sidebar">
      <div class="logo">TimeTracker&nbsp;Pro</div>
      <ul id="navList">
        <!-- Set Dashboard tab without active class; we will programmatically activate the Timer tab on load -->
        <li data-section="dashboard" class="active">Dashboard</li>
        <li data-section="timer">Timer</li>
        <li data-section="projects">Projects</li>
        <li data-section="entries">Entries</li>
        <li data-section="importExport">Import/Export</li>
        <li data-section="analytics">Reports</li>
        <li data-section="todo">Workouts</li>
        <li data-section="grocery">Budgeting</li>
      </ul>
    </div>
    <div class="content">
      <!-- Dashboard Section -->
      <section id="dashboard" class="section">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Dashboard</h2>
        <div class="stats-grid" id="statsGrid"></div>
        <div id="projectOverview"></div>
        <div id="detailedBreakdown"></div>

        <!-- Recommendations Section: dynamically populated with suggested projects to work on -->


        <!-- Scatter charts for project progress -->
        <div class="card" id="weeklyScatterCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Progress – Weekly (Expected vs Actual)</h3>
          <canvas id="weeklyScatter" height="200"></canvas>
        </div>
        <div class="card" id="monthlyScatterCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Progress – Monthly (Expected vs Actual)</h3>
          <canvas id="monthlyScatter" height="200"></canvas>
        </div>

        <!-- Daily Hours Heatmap -->
        <div class="card" id="heatmapCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Daily Hours Heatmap</h3>
          <div id="heatmap" style="overflow-x:auto;"></div>
        </div>
        <!-- Project Burndown Chart -->
        <div class="card" id="burndownCard">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Burndown</h3>
          <div style="margin-bottom:0.5rem;">
            <label for="burndownProjectSelect" style="font-size:0.9rem; font-weight:500;">Select Project:</label>
            <select id="burndownProjectSelect" style="margin-left:0.5rem; padding:0.25rem; border:1px solid #cbd5e1; border-radius:0.375rem;"></select>
          </div>
          <canvas id="burndownChart" height="200"></canvas>
        </div>
      </section>
      <!-- Timer Section -->
      <section id="timer" class="section">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Timer</h2>
        <div id="runningTimerPro" class="card" style="display:none;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Running Timer</h3>
          <p><strong>Project:</strong> <span id="runningProjectNamePro"></span></p>
          <p><strong>Started:</strong> <span id="runningStartTimePro"></span></p>
          <p><strong>Elapsed:</strong> <span id="runningElapsedPro"></span></p>
          <button id="stopTimerBtnPro" class="btn danger">Stop</button>
        </div>
        <div id="startTimerPro" class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Start Timer</h3>
          <label for="timerProjectPro" style="margin-bottom:0.25rem; font-weight:500;">Project</label>
          <select id="timerProjectPro" style="padding:0.5rem; margin-bottom:0.5rem; width:100%; border:1px solid #cbd5e1; border-radius:0.375rem;"></select>
          <label for="timerInitialPro" style="margin-bottom:0.25rem; font-weight:500;">Hours already spent (optional)</label>
          <input id="timerInitialPro" type="number" min="0" step="0.1" style="padding:0.5rem; margin-bottom:0.5rem; width:100%; border:1px solid #cbd5e1; border-radius:0.375rem;" placeholder="e.g. 0.5" />
          <!-- Allow the user to choose the initial focus factor when starting a timer -->
          <label for="startFactorPro" style="margin-bottom:0.25rem; font-weight:500;">Focus factor</label>
          <select id="startFactorPro" style="padding:0.5rem; margin-bottom:0.5rem; width:100%; border:1px solid #cbd5e1; border-radius:0.375rem;">
            <option value="">Auto</option>
            <option value="1">100%</option>
            <option value="0.75">75%</option>
            <option value="0.5">50%</option>
            <option value="0.25">25%</option>
          </select>
          <button id="startTimerBtnPro" class="btn primary" disabled style="padding:0.75rem 1.5rem; font-size:1rem;">Start</button>
        </div>
      </section>
      <!-- Projects Section -->
      <section id="projects" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Projects</h2>
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">New Project</h3>
          <form id="projectFormPro" style="display:flex; flex-direction:column; gap:0.5rem;">
            <label for="projectNamePro" style="font-weight:500;">Project Name</label>
            <input id="projectNamePro" type="text" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectClientPro" style="font-weight:500;">Client (optional)</label>
            <input id="projectClientPro" type="text" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectBudgetPro" style="font-weight:500;">Budget Hours</label>
            <input id="projectBudgetPro" type="number" min="0" step="0.1" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <label for="projectRatePro" style="font-weight:500;">Hourly Rate</label>
            <input id="projectRatePro" type="number" min="0" step="0.01" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />

            <!-- Rounding selection: allow user to choose rounding interval for entries in minutes -->
            <label for="projectRoundingPro" style="font-weight:500;">Rounding (minutes)</label>
            <select id="projectRoundingPro" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;">
              <option value="0">None</option>
              <option value="5">5</option>
              <option value="10">10</option>
              <option value="15">15</option>
            </select>
            <label for="projectDeadlinePro" style="font-weight:500;">Deadline</label>
            <input id="projectDeadlinePro" type="date" required style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <button type="submit" class="btn primary" style="align-self:flex-start;">Add Project</button>
          </form>
        </div>
        <div id="projectsPageList"></div>
      </section>
      <!-- Entries Section -->
      <section id="entries" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Time Entries</h2>
        <div class="card">
          <div style="margin-bottom:0.5rem; display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; font-size:1.1rem; font-weight:600;">Entries</h3>
            <div style="display:flex; gap:0.5rem;">
              <button id="addManualEntryBtnPro" class="btn secondary">Add Manual Entry</button>
              <!-- Toggle button to switch between showing recent entries and all entries -->
              <button id="toggleEntriesViewBtn" class="btn secondary">Show Recent</button>
            </div>
          </div>
          <div id="manualEntryFormPro" class="hidden" style="margin-top:1rem;">
            <h4 style="margin:0 0 0.5rem 0; font-size:1rem; font-weight:600;">New Manual Entry</h4>
            <form id="manualFormPro" style="display:flex; flex-direction:column; gap:0.5rem;">
              <label for="manualProjectPro" style="font-weight:500;">Project</label>
              <select id="manualProjectPro" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;"></select>
              <label for="manualDescriptionPro" style="font-weight:500;">Description (optional)</label>
              <input id="manualDescriptionPro" type="text" style="padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
              <label for="manualHoursPro" style="font-weight:500;">Hours</label>
              <!-- Hours input with nudge buttons for ±5 minutes -->
              <div style="display:flex; align-items:center; gap:0.5rem;">
                <input id="manualHoursPro" type="number" min="0" step="0.1" style="flex:1; padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" placeholder="e.g. 2" />
                <button type="button" id="manualMinus5Btn" class="btn secondary" style="padding:0.25rem 0.5rem; font-size:0.75rem;">-5m</button>
                <button type="button" id="manualPlus5Btn" class="btn secondary" style="padding:0.25rem 0.5rem; font-size:0.75rem;">+5m</button>
              </div>
              <button type="submit" class="btn primary" style="align-self:flex-start;">Save Entry</button>
              <button type="button" id="cancelManualBtnPro" class="btn secondary" style="align-self:flex-start;">Cancel</button>
            </form>
          </div>
          <div style="overflow-x:auto;">
            <table>
              <thead>
                <tr>
                  <th>Project</th>
                  <th>Description</th>
                  <th>Start</th>
                  <th>End</th>
                  <th>Duration</th>
                  <th>Total</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="entriesTableBodyPro"></tbody>
            </table>
          </div>
        </div>
      </section>
      <!-- Import/Export Section -->
      <section id="importExport" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Import / Export</h2>
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Export Data</h3>
          <button id="exportBtnPro" class="btn primary">Export JSON</button>
        </div>
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Import Data</h3>
          <input id="importInputPro" type="file" accept="application/json" />
        </div>

        <!-- Auto Sync card: allows toggling automatic periodic export of data -->
        <div class="card" style="margin-top:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Auto Data Sync</h3>
          <label style="display:flex; align-items:center; gap:0.5rem; cursor:pointer;">
            <input type="checkbox" id="autoSyncToggle" />
            <span>Enable auto sync to local file</span>
          </label>
          <p id="autoSyncStatus" style="font-size:0.8rem; color:#64748b; margin-top:0.5rem;"></p>
          <p id="autoSyncWarning" class="status-warning" style="display:none;"></p>
          <p id="lastBackupStatus" class="status-muted" style="display:none;"></p>
        <!-- Button to choose backup directory when enabling auto sync -->
        <button id="chooseBackupDirBtn" class="btn secondary" style="margin-top:0.5rem;">Set Backup Folder</button>
        </div>
      </section>

      <!-- Workout Tracker Section (replaces Todo) -->
      <section id="todo" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Workouts</h2>
        <!-- Form to add a new workout -->
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Add Workout</h3>
          <form id="todoForm" style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
            <input id="todoName" type="text" required placeholder="Workout name" style="flex:2; padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <input id="todoTarget" type="number" min="1" step="1" placeholder="Weekly target" style="width:5rem; padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <button type="submit" class="btn primary">Add</button>
          </form>
        </div>
        <div class="card" id="fitnessSummaryCard" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Fitness &amp; Budget Summary</h3>
          <div id="fitnessSummaryContent" class="fitness-summary"></div>
        </div>
        <!-- List of workouts -->
        <div class="card" id="todoListContainer">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Your Workouts</h3>
          <ul id="todoList" style="list-style:none; padding:0; margin:0;"></ul>
        </div>
        <div class="card" id="fitnessSettingsCard" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Fitness Settings</h3>
          <div id="fitnessSettingsContent"></div>
        </div>
      </section>

      <!-- Grocery Section -->
      <section id="grocery" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Budgeting</h2>
        <!-- Budget summary card will be inserted here dynamically -->
        <div id="budgetSummaryContainer"></div>

        <!-- Form to add a new grocery item -->
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Add Item</h3>
          <form id="groceryForm" style="display:flex; gap:0.5rem; flex-wrap:wrap; align-items:center;">
            <input id="groceryName" type="text" required placeholder="Item name" style="flex:2; padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;" />
            <select id="groceryFreq" style="width:7rem; padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;">
              <option value="weekly">Weekly</option>
              <option value="monthly">Monthly</option>
              <option value="biannual">Biannual</option>
            </select>
            <select id="groceryCategory" style="width:7rem; padding:0.5rem; border:1px solid #cbd5e1; border-radius:0.375rem;">
              <option value="standard">Standard</option>
              <option value="treat">Treat</option>
              <option value="essential">Essential</option>
            </select>
            <button type="submit" class="btn primary">Add</button>
          </form>
        </div>
        <!-- Weekly grocery items -->
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Weekly Items</h3>
          <ul id="weeklyGroceryList" style="list-style:none; padding:0; margin:0;"></ul>
        </div>
        <!-- Monthly grocery items -->
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Monthly Items</h3>
          <ul id="monthlyGroceryList" style="list-style:none; padding:0; margin:0;"></ul>
        </div>

        <!-- Biannual grocery items -->
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Biannual Items</h3>
          <ul id="biannualGroceryList" style="list-style:none; padding:0; margin:0;"></ul>
        </div>

        <!-- Archived grocery items (purchased items with cost) -->
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Archived Purchases</h3>
          <ul id="archivedGroceryList" style="list-style:none; padding:0; margin:0;"></ul>
        </div>

        <!-- Note about excluded categories -->
        <div class="card" style="background:#f8fafc; border:1px solid #e2e8f0; margin-top:1rem;">
          <p style="margin:0; padding:0.75rem; font-size:0.85rem; color:#475569;">
            <strong>Note:</strong> All food, medicine and hygiene products (except luxury items) should be excluded from budgeting.
          </p>
        </div>
      </section>

      <!-- Analytics/Reports Section -->
      <section id="analytics" class="section" style="display:none;">
        <h2 class="mb-4" style="font-size:1.25rem; font-weight:600;">Reports</h2>
        <!-- Heatmap card -->
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Monthly Heatmap</h3>
          <div id="heatmapContainer"></div>
        </div>
        <!-- Burndown charts card -->
        <div class="card" style="margin-bottom:1rem;">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Project Burndown Charts</h3>
          <div id="burndownContainer"></div>
        </div>
        <!-- Hours by Project bar chart -->
        <div class="card">
          <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">Hours by Project (Month)</h3>
          <canvas id="hoursByProjectChart" height="200"></canvas>
        </div>
      </section>
    </div>
    <script>
      (function() {
        // Simple UUID generator
        function uuid() {
          return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            const r = Math.random() * 16 | 0;
            const v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
          });
        }
        const FITNESS_MODES = {
          gentle: { label: 'Gentle (6% / 4%)', alpha: 0.06, beta: 0.04 },
          normal: { label: 'Normal (8% / 6%)', alpha: 0.08, beta: 0.06 },
          strict: { label: 'Strict (10% / 8%)', alpha: 0.10, beta: 0.08 }
        };
        function makeDefaultFitness() {
          return {
            mode: 'normal',
            alpha: FITNESS_MODES.normal.alpha,
            beta: FITNESS_MODES.normal.beta,
            currentMultiplier: 1,
            nextMultiplier: 1,
            lastProcessedMonday: null,
            wellnessCredits: 0,
            creditsCap: 1000,
            creditSettings: {
              base: 50,
              extra: 25,
              penalty: 40,
              weeklyBonus: 50,
              streakBonus: 100
            },
            streakCount: 0,
            pausedWeeks: {},
            weekendBoostEnabled: true,
            weekendBoostPercent: 0.1,
            weekendBoostUnlockedWeek: null,
            lastWeekSummary: null
          };
        }
        function applyFitnessDefaults(obj) {
          const defaults = makeDefaultFitness();
          if (!obj || typeof obj !== 'object') return defaults;
          const merged = Object.assign({}, defaults, obj);
          merged.creditSettings = Object.assign({}, defaults.creditSettings, obj.creditSettings || {});
          merged.pausedWeeks = Object.assign({}, defaults.pausedWeeks, obj.pausedWeeks || {});
          if (typeof merged.alpha !== 'number' || !isFinite(merged.alpha)) merged.alpha = defaults.alpha;
          if (typeof merged.beta !== 'number' || !isFinite(merged.beta)) merged.beta = defaults.beta;
          if (typeof merged.currentMultiplier !== 'number' || !isFinite(merged.currentMultiplier)) merged.currentMultiplier = defaults.currentMultiplier;
          if (typeof merged.nextMultiplier !== 'number' || !isFinite(merged.nextMultiplier)) merged.nextMultiplier = defaults.nextMultiplier;
          if (typeof merged.creditsCap !== 'number' || !isFinite(merged.creditsCap)) merged.creditsCap = defaults.creditsCap;
          if (typeof merged.wellnessCredits !== 'number' || !isFinite(merged.wellnessCredits)) merged.wellnessCredits = defaults.wellnessCredits;
          if (typeof merged.weekendBoostPercent !== 'number' || !isFinite(merged.weekendBoostPercent)) merged.weekendBoostPercent = defaults.weekendBoostPercent;
          if (typeof merged.streakCount !== 'number' || !isFinite(merged.streakCount)) merged.streakCount = defaults.streakCount;
          return merged;
        }
        function ensureFitnessDefaults() {
          data.fitness = applyFitnessDefaults(data.fitness);
          return data.fitness;
        }
        function clampMultiplier(value) {
          const val = typeof value === 'number' && isFinite(value) ? value : 1;
          return Math.min(1.2, Math.max(0.9, val));
        }
        function getWeekStart(date) {
          const d = new Date(date);
          const dow = d.getDay();
          const diffToMonday = (dow + 6) % 7;
          const monday = new Date(d.getFullYear(), d.getMonth(), d.getDate() - diffToMonday);
          monday.setHours(0, 0, 0, 0);
          return monday;
        }
        function getWeekKey(date) {
          return getWeekStart(date).toISOString().split('T')[0];
        }
        function computeFitnessSummary(stats, alpha, beta) {
          let totalPenalty = 0;
          let totalOverage = 0;
          let complianceSum = 0;
          let workoutsCount = 0;
          let totalTargets = 0;
          let totalActual = 0;
          stats.forEach(stat => {
            const target = stat && typeof stat.target === 'number' ? stat.target : 0;
            const actual = stat && typeof stat.actual === 'number' ? stat.actual : 0;
            if (target <= 0) return;
            const ratio = target > 0 ? actual / target : 0;
            const compliance = Math.min(1, Math.max(0, ratio));
            const overage = Math.max(0, ratio - 1);
            const penalty = 1 - compliance;
            totalPenalty += penalty;
            totalOverage += overage;
            complianceSum += compliance;
            workoutsCount += 1;
            totalTargets += target;
            totalActual += actual;
          });
          const adjPercent = (alpha * totalOverage) - (beta * totalPenalty);
          return {
            adjPercent,
            totalPenalty,
            totalOverage,
            complianceAvg: workoutsCount > 0 ? complianceSum / workoutsCount : 1,
            workoutsCount,
            totalTargets,
            totalActual
          };
        }
        function computeCreditsDelta(stats, fitness) {
          const defaults = makeDefaultFitness();
          const settings = fitness && fitness.creditSettings ? Object.assign({}, defaults.creditSettings, fitness.creditSettings) : defaults.creditSettings;
          let baseEarned = 0;
          let extraEarned = 0;
          let penalties = 0;
          let workoutsWithTargets = 0;
          let metAll = true;
          stats.forEach(stat => {
            const target = stat && typeof stat.target === 'number' ? stat.target : 0;
            const actual = stat && typeof stat.actual === 'number' ? stat.actual : 0;
            if (target <= 0) return;
            workoutsWithTargets += 1;
            const baseSessions = Math.min(actual, target);
            const extraSessions = Math.max(0, actual - target);
            const missedSessions = Math.max(0, target - actual);
            baseEarned += baseSessions * settings.base;
            extraEarned += extraSessions * settings.extra;
            penalties += missedSessions * settings.penalty;
            if (actual < target) metAll = false;
          });
          let streakCount = fitness && typeof fitness.streakCount === 'number' ? fitness.streakCount : 0;
          let bonus = 0;
          if (metAll && workoutsWithTargets > 0) {
            bonus += settings.weeklyBonus;
            streakCount += 1;
            if (streakCount > 0 && streakCount % 4 === 0) {
              bonus += settings.streakBonus;
            }
          } else if (fitness) {
            streakCount = 0;
          }
          const rawDelta = baseEarned + extraEarned - penalties + bonus;
          const currentCredits = fitness && typeof fitness.wellnessCredits === 'number' ? fitness.wellnessCredits : 0;
          const cap = fitness && typeof fitness.creditsCap === 'number' ? fitness.creditsCap : defaults.creditsCap;
          const newCredits = Math.max(0, Math.min(cap, currentCredits + rawDelta));
          const delta = newCredits - currentCredits;
          return {
            delta,
            newCredits,
            streakCount,
            baseEarned,
            extraEarned,
            penalties,
            bonus,
            metAllTargets: metAll && workoutsWithTargets > 0,
            workoutsWithTargets
          };
        }
        function collectWorkoutStats(options = {}) {
          const start = options.start ? new Date(options.start) : getWeekStart(new Date());
          const end = options.end ? new Date(options.end) : null;
          if (isNaN(start.getTime())) {
            throw new Error('Invalid start date for workout stats');
          }
          const todos = Array.isArray(data.todos) ? data.todos : [];
          const stats = todos.map(todo => {
            if (!Array.isArray(todo.logs)) todo.logs = [];
            if (todo.carryOver === undefined) todo.carryOver = 0;
            const target = typeof todo.weeklyTarget === 'number' ? Math.max(0, todo.weeklyTarget) : 0;
            let actual = 0;
            todo.logs.forEach(log => {
              const dt = new Date(log);
              if (isNaN(dt.getTime())) return;
              if (dt >= start && (!end || dt <= end)) {
                actual += 1;
              }
            });
            return {
              id: todo.id,
              name: todo.name || '',
              target,
              actual
            };
          });
          return { stats, start, end };
        }
        function isWeekPaused(weekKey) {
          const fitness = ensureFitnessDefaults();
          return !!(fitness.pausedWeeks && fitness.pausedWeeks[weekKey]);
        }
        function setWeekPaused(weekKey, paused) {
          const fitness = ensureFitnessDefaults();
          if (!fitness.pausedWeeks) fitness.pausedWeeks = {};
          if (paused) {
            fitness.pausedWeeks[weekKey] = true;
          } else {
            delete fitness.pausedWeeks[weekKey];
          }
        }
        function finalizeFitnessWeek(weeklyStats, lastMonday, thisMonday) {
          const fitness = ensureFitnessDefaults();
          const lastMondayKey = getWeekKey(lastMonday);
          const thisMondayKey = getWeekKey(thisMonday);
          const prevNext = typeof fitness.nextMultiplier === 'number' ? fitness.nextMultiplier : 1;
          fitness.currentMultiplier = clampMultiplier(prevNext);
          const pausedWeeks = fitness.pausedWeeks || {};
          const wasPaused = !!pausedWeeks[lastMondayKey];
          if (wasPaused) {
            delete pausedWeeks[lastMondayKey];
            fitness.pausedWeeks = pausedWeeks;
          }
          const hasTargets = Array.isArray(weeklyStats) && weeklyStats.some(stat => stat.target > 0);
          if (!hasTargets) {
            fitness.nextMultiplier = fitness.currentMultiplier;
            fitness.lastWeekSummary = {
              weekStart: lastMondayKey,
              weekEnd: thisMonday.toISOString().split('T')[0],
              adjPercent: 0,
              totalPenalty: 0,
              totalOverage: 0,
              complianceAvg: 1,
              totalTargets: 0,
              totalActual: 0,
              creditsDelta: 0,
              baseCredits: 0,
              extraCredits: 0,
              penalties: 0,
              bonus: 0,
              metAllTargets: false,
              paused: wasPaused
            };
          } else if (wasPaused) {
            fitness.nextMultiplier = fitness.currentMultiplier;
            fitness.lastWeekSummary = {
              weekStart: lastMondayKey,
              weekEnd: thisMonday.toISOString().split('T')[0],
              adjPercent: 0,
              totalPenalty: 0,
              totalOverage: 0,
              complianceAvg: 1,
              totalTargets: 0,
              totalActual: 0,
              creditsDelta: 0,
              baseCredits: 0,
              extraCredits: 0,
              penalties: 0,
              bonus: 0,
              metAllTargets: false,
              paused: true
            };
          } else {
            const summary = computeFitnessSummary(weeklyStats, fitness.alpha, fitness.beta);
            const nextMultiplier = clampMultiplier(1 + summary.adjPercent);
            const creditsInfo = computeCreditsDelta(weeklyStats, fitness);
            fitness.nextMultiplier = nextMultiplier;
            fitness.wellnessCredits = creditsInfo.newCredits;
            fitness.streakCount = creditsInfo.streakCount;
            fitness.lastWeekSummary = {
              weekStart: lastMondayKey,
              weekEnd: thisMonday.toISOString().split('T')[0],
              adjPercent: summary.adjPercent,
              totalPenalty: summary.totalPenalty,
              totalOverage: summary.totalOverage,
              complianceAvg: summary.complianceAvg,
              totalTargets: summary.totalTargets,
              totalActual: summary.totalActual,
              creditsDelta: creditsInfo.delta,
              baseCredits: creditsInfo.baseEarned,
              extraCredits: creditsInfo.extraEarned,
              penalties: creditsInfo.penalties,
              bonus: creditsInfo.bonus,
              metAllTargets: creditsInfo.metAllTargets,
              paused: false
            };
          }
          fitness.weekendBoostUnlockedWeek = null;
          fitness.lastProcessedMonday = thisMondayKey;
        }
        function evaluateWeekendBoostUnlock() {
          const fitness = ensureFitnessDefaults();
          if (!fitness.weekendBoostEnabled) return false;
          const weekKey = getWeekKey(new Date());
          if (fitness.weekendBoostUnlockedWeek === weekKey) return true;
          const monday = getWeekStart(new Date());
          const fridayCutoff = new Date(monday);
          fridayCutoff.setDate(fridayCutoff.getDate() + 4);
          fridayCutoff.setHours(18, 0, 0, 0);
          const now = new Date();
          if (now < fridayCutoff) return false;
          const statsInfo = collectWorkoutStats({ start: monday, end: fridayCutoff });
          let totalTarget = 0;
          let totalActual = 0;
          statsInfo.stats.forEach(stat => {
            if (stat.target > 0) {
              totalTarget += stat.target;
              totalActual += Math.min(stat.actual, stat.target);
            }
          });
          if (totalTarget > 0 && totalActual >= totalTarget) {
            fitness.weekendBoostUnlockedWeek = weekKey;
            saveData();
            return true;
          }
          return false;
        }
        function isWeekendBoostActive() {
          const fitness = ensureFitnessDefaults();
          if (!fitness.weekendBoostEnabled) return false;
          const weekKey = getWeekKey(new Date());
          if (fitness.weekendBoostUnlockedWeek !== weekKey) {
            return evaluateWeekendBoostUnlock();
          }
          const now = new Date();
          const monday = getWeekStart(now);
          const friday = new Date(monday);
          friday.setDate(friday.getDate() + 4);
          friday.setHours(18, 0, 0, 0);
          const sunday = new Date(monday);
          sunday.setDate(sunday.getDate() + 6);
          sunday.setHours(23, 59, 59, 999);
          return now >= friday && now <= sunday;
        }
        function formatPercent(value, decimals = 1) {
          if (!isFinite(value)) return '0%';
          return (value * 100).toFixed(decimals) + '%';
        }
        function formatSignedCurrency(value, decimals = -1) {
          if (!isFinite(value) || value === 0) {
            return '0 SEK';
          }
          const formatted = formatCurrency(Math.abs(value), decimals).replace(' kr', '');
          return (value >= 0 ? '+' : '−') + formatted + ' SEK';
        }
        // Load and save data

function loadData() {
  const raw = localStorage.getItem('timekeeperDataPro');
  if (!raw) {
    return {
      projects: [],
      entries: [],
      todos: [],
      groceries: [],
      groceryBudgetWeekly: 1000,
      groceryBudgetMonthly: 4000,
      groceryBudgetBiYearly: 20000,
      groceryBudgetWeeklyCarry: 0,
      groceryBudgetMonthlyCarry: 0,
      groceryBudgetBiYearlyCarry: 0,
      groceryBudgetWeeklyCarryBaseline: 0,
      groceryBudgetMonthlyCarryBaseline: 0,
      groceryBudgetBiYearlyCarryBaseline: 0,
      groceryBudgetStartDate: null,
      backupDirName: null,
      lastBackupAt: null,
      fitness: makeDefaultFitness()
    };
  }
  try {
    const parsed = JSON.parse(raw);
    return {
      projects: Array.isArray(parsed.projects) ? parsed.projects : [],
      entries: Array.isArray(parsed.entries) ? parsed.entries : [],
      // Workouts (formerly todos). Ensure an array and attach carryOver property if missing.
      todos: Array.isArray(parsed.todos) ? parsed.todos.map(t => {
        if (t.carryOver === undefined) t.carryOver = 0;
        if (!Array.isArray(t.logs)) t.logs = [];
        return t;
      }) : [],
      // Grocery items: weekly/monthly shopping list with carryOver and purchasedCount.
      groceries: Array.isArray(parsed.groceries) ? parsed.groceries.map(g => {
        // Migrate legacy properties to new structure. Each item should have a name and frequency.
        if (!g.name) g.name = '';
        if (!g.frequency) g.frequency = 'weekly';
        if (typeof g.frequency === 'string') {
          const freq = g.frequency.toLowerCase();
          if (freq === 'weekly' || freq === 'monthly' || freq === 'biannual') {
            g.frequency = freq;
          } else {
            g.frequency = 'weekly';
          }
        } else {
          g.frequency = 'weekly';
        }
        // In the new structure, we track whether an item has been archived and when it was purchased. Default false/null.
        if (g.archived === undefined) g.archived = false;
        if (g.purchasedDate === undefined) g.purchasedDate = null;
        if (!g.category) g.category = 'standard';
        if (typeof g.cost === 'string') {
          const parsedCost = parseFloat(g.cost);
          if (!isNaN(parsedCost)) g.cost = parsedCost;
        }
        if (typeof g.originalCost === 'string') {
          const parsedOriginal = parseFloat(g.originalCost);
          if (!isNaN(parsedOriginal)) g.originalCost = parsedOriginal;
        }
        if (g.originalCost === undefined && typeof g.cost === 'number') g.originalCost = g.cost;
        if (g.appliedCredits === undefined) g.appliedCredits = 0;
        if (g.boostApplied === undefined) g.boostApplied = false;
        if (g.boostPercentApplied === undefined) g.boostPercentApplied = 0;
        // Remove legacy fields carryOver and purchasedCount if present
        if (g.hasOwnProperty('carryOver')) delete g.carryOver;
        if (g.hasOwnProperty('purchasedCount')) delete g.purchasedCount;
        return g;
      }) : [],
      // Single-item purchase quotas have been removed. Now, budgets control overall spending rather than item counts.
      // As a result, carry-over counts for purchases are no longer tracked or persisted in the data structure.
      groceryBudgetWeekly: typeof parsed.groceryBudgetWeekly === 'number' ? parsed.groceryBudgetWeekly : 1000,
      groceryBudgetMonthly: typeof parsed.groceryBudgetMonthly === 'number' ? parsed.groceryBudgetMonthly : 4000,
      groceryBudgetBiYearly: typeof parsed.groceryBudgetBiYearly === 'number' ? parsed.groceryBudgetBiYearly : 20000,
      groceryBudgetWeeklyCarry: typeof parsed.groceryBudgetWeeklyCarry === 'number' ? parsed.groceryBudgetWeeklyCarry : 0,
      groceryBudgetMonthlyCarry: typeof parsed.groceryBudgetMonthlyCarry === 'number' ? parsed.groceryBudgetMonthlyCarry : 0,
      groceryBudgetBiYearlyCarry: typeof parsed.groceryBudgetBiYearlyCarry === 'number' ? parsed.groceryBudgetBiYearlyCarry : 0,
      groceryBudgetWeeklyCarryBaseline: typeof parsed.groceryBudgetWeeklyCarryBaseline === 'number'
        ? parsed.groceryBudgetWeeklyCarryBaseline
        : (typeof parsed.groceryBudgetWeeklyCarry === 'number' ? parsed.groceryBudgetWeeklyCarry : 0),
      groceryBudgetMonthlyCarryBaseline: typeof parsed.groceryBudgetMonthlyCarryBaseline === 'number'
        ? parsed.groceryBudgetMonthlyCarryBaseline
        : (typeof parsed.groceryBudgetMonthlyCarry === 'number' ? parsed.groceryBudgetMonthlyCarry : 0),
      groceryBudgetBiYearlyCarryBaseline: typeof parsed.groceryBudgetBiYearlyCarryBaseline === 'number'
        ? parsed.groceryBudgetBiYearlyCarryBaseline
        : (typeof parsed.groceryBudgetBiYearlyCarry === 'number' ? parsed.groceryBudgetBiYearlyCarry : 0),
      // Start date for budgeting periods (YYYY-MM-DD); defaults to null to use current date on first run
      groceryBudgetStartDate: parsed.groceryBudgetStartDate || null,
      // Preserve additional persisted properties like backupDirName if present in saved data
      backupDirName: parsed.backupDirName || null,
      lastBackupAt: parsed.lastBackupAt || null,
      fitness: applyFitnessDefaults(parsed.fitness)
    };
  } catch (err) {
    return {
      projects: [],
      entries: [],
      todos: [],
      groceries: [],
      groceryBudgetWeekly: 1000,
      groceryBudgetMonthly: 4000,
      groceryBudgetBiYearly: 20000,
      groceryBudgetWeeklyCarry: 0,
      groceryBudgetMonthlyCarry: 0,
      groceryBudgetBiYearlyCarry: 0,
      groceryBudgetWeeklyCarryBaseline: 0,
      groceryBudgetMonthlyCarryBaseline: 0,
      groceryBudgetBiYearlyCarryBaseline: 0,
      groceryBudgetStartDate: null,
      backupDirName: null,
      lastBackupAt: null,
      fitness: makeDefaultFitness()
    };
  }
}
        function saveData() {
          localStorage.setItem('timekeeperDataPro', JSON.stringify(data));
          // Mark data as needing backup
          needsBackup = true;
        }

        // Compute concurrency factor based on the number of active timers.
        // Factor decreases as more timers run simultaneously: for example, 1 timer=1.0, 2 timers=0.75, 3 timers=0.6.
        function computeConcurrencyFactor(n) {
          if (n <= 1) return 1;
          return 1 / (1 + (n - 1) / 3);
        }
        let data = loadData();
        ensureFitnessDefaults();
        // Initialize backup and sync flags before they are referenced in saveData().
        // needsBackup tracks whether the data has changed and needs to be exported.
        // autoSyncEnabled indicates whether automatic export is enabled.
        // backupDirHandle holds the selected directory for backups via the File System Access API.
        let needsBackup = false;
        let autoSyncEnabled = false;
        let backupDirHandle = null;
        // backupPermissionState tracks the permission status for writing backups using the File System Access API.
        // Possible states:
        //   'missing' - No backup directory has been selected yet.
        //   'prompt'  - A backup directory is selected, but permission to write has not been granted.
        //   'granted' - Permission to write to the backup directory has been granted.
        //   'denied'  - Permission to write to the backup directory has been denied.
        let backupPermissionState = 'missing';
        let backupWarningMessage = '';
        // Flag to track whether to show all entries or only recent ones. If false,
        // entries older than approximately one month are hidden by default to keep
        // the list manageable. This can be toggled via a button in the Entries section.
        let showAllEntries = false;

        // -------------------------------------------------------------------------
        //  Haptic feedback and simple audio cues
        //
        //  provideHaptic() triggers vibration on devices that support the
        //  Vibration API. If a 'beep' type is requested, it plays a short tone via
        //  the Web Audio API. These feedback cues enhance the feeling of
        //  interaction when starting/stopping timers or adjusting entry durations.
        function provideHaptic(type) {
          // Trigger a short vibration where supported
          if (navigator && 'vibrate' in navigator) {
            if (type === 'long') navigator.vibrate([50, 50, 50]);
            else navigator.vibrate(40);
          }
          // Play a simple beep for auditory feedback
          if (type === 'beep') {
            try {
              if (!window._beepAudioCtx) {
                window._beepAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
              }
              const ctx = window._beepAudioCtx;
              const osc = ctx.createOscillator();
              osc.type = 'sine';
              osc.frequency.value = 440;
              osc.connect(ctx.destination);
              osc.start();
              osc.stop(ctx.currentTime + 0.05);
            } catch (err) {
              // Audio may fail if the page is not interacted with yet
            }
          }
        }

        // -------------------------------------------------------------------------
        //  IndexedDB persistence for backup directory handle
        //
        //  Persisting the selected backup folder across sessions requires storing
        //  the FileSystemDirectoryHandle in IndexedDB. Handles are structured
        //  cloneable and can be retrieved on subsequent page loads. These
        //  functions abstract opening the database, saving the handle, and
        //  retrieving it when the page initializes.
        function openHandleDB() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open('timekeeper-db', 1);
            request.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains('handles')) {
                db.createObjectStore('handles');
              }
            };
            request.onsuccess = (e) => resolve(e.target.result);
            request.onerror = (e) => reject(e.target.error);
          });
        }
        async function saveBackupDirHandle(handle) {
          try {
            const db = await openHandleDB();
            const tx = db.transaction('handles', 'readwrite');
            tx.objectStore('handles').put(handle, 'backupDir');
            return tx.complete;
          } catch (err) {
            console.error('Error saving backup handle:', err);
          }
        }
        async function loadBackupDirHandle() {
          try {
            const db = await openHandleDB();
            return await new Promise((resolve) => {
              const tx = db.transaction('handles', 'readonly');
              const getReq = tx.objectStore('handles').get('backupDir');
              getReq.onsuccess = () => resolve(getReq.result || null);
              getReq.onerror = () => resolve(null);
            });
          } catch (err) {
            return null;
          }
        }
        async function getBackupPermissionState(handle) {
          if (!handle) return 'missing';
          if (!handle.queryPermission) return 'granted';
          try {
            return await handle.queryPermission({ mode: 'readwrite' });
          } catch (err) {
            return 'denied';
          }
        }
        async function ensureBackupPermissionWithPrompt(handle) {
          if (!handle) {
            backupPermissionState = 'missing';
            return false;
          }
          if (!handle.queryPermission) {
            backupPermissionState = 'granted';
            return true;
          }
          try {
            let status = await handle.queryPermission({ mode: 'readwrite' });
            if (status === 'granted') {
              backupPermissionState = 'granted';
              return true;
            }
            if (status === 'prompt' && handle.requestPermission) {
              status = await handle.requestPermission({ mode: 'readwrite' });
              backupPermissionState = status;
              return status === 'granted';
            }
            backupPermissionState = status || 'denied';
            return false;
          } catch (err) {
            backupPermissionState = 'denied';
            return false;
          }
        }
        function disableAutoSyncWithWarning(message) {
          autoSyncEnabled = false;
          localStorage.setItem('autoSyncEnabledPro', 'false');
          const toggle = document.getElementById('autoSyncToggle');
          if (toggle) {
            toggle.checked = false;
          }
          if (message) {
            backupWarningMessage = message;
          }
          updateAutoSyncStatus();
        }
        // Reset todo checkboxes each Monday. If the stored reset date is not for the current Monday,
        // mark all tasks as unchecked and update the reset date in localStorage. This ensures
        // todos remain persistent week-to-week but are reset at the start of each new week.
        function resetTodosIfNeeded() {
          const today = new Date();
          // Determine the Monday of this week
          const monday = new Date(today);
          const dow = monday.getDay();
          const diffToMonday = (dow + 6) % 7;
          monday.setDate(monday.getDate() - diffToMonday);
          const mondayStr = monday.toDateString();
          const lastReset = localStorage.getItem('todoResetDatePro');
          if (lastReset !== mondayStr) {
            // At the start of a new week, compute carryOver for each workout based on last week's performance
            if (Array.isArray(data.todos)) {
              // Determine last Monday (one week before this week's Monday) for computing logs in the previous week
              const lastMonday = new Date(monday);
              lastMonday.setDate(monday.getDate() - 7);
              lastMonday.setHours(0, 0, 0, 0);
              const weeklyStats = [];
              data.todos.forEach(t => {
                // Ensure properties exist
                if (typeof t.weeklyTarget !== 'number' || t.weeklyTarget < 1) {
                  t.weeklyTarget = 1;
                }
                if (t.carryOver === undefined) {
                  t.carryOver = 0;
                }
                if (!Array.isArray(t.logs)) {
                  t.logs = [];
                }
                // Count the number of sessions logged in the previous week
                const sessionsLastWeek = t.logs.filter(log => {
                  const dt = new Date(log);
                  return dt >= lastMonday && dt < monday;
                }).length;
                weeklyStats.push({ id: t.id, name: t.name || '', target: Math.max(0, t.weeklyTarget), actual: sessionsLastWeek });
                // Dynamic target for the previous week
                const dynamicTarget = t.weeklyTarget + t.carryOver;
                // Determine carryOver for the new week based on difference between target and actual sessions
                let newCarry = dynamicTarget - sessionsLastWeek;
                // Update carryOver (can be negative or positive)
                t.carryOver = newCarry;
                // Reset checked state
                t.checked = false;
                // Remove logs before this week; keep logs on or after the current Monday
                t.logs = t.logs.filter(log => {
                  const dt = new Date(log);
                  return dt >= monday;
                });
              });
              finalizeFitnessWeek(weeklyStats, lastMonday, monday);
            }
            localStorage.setItem('todoResetDatePro', mondayStr);
            saveData();
          }
        }
        // Perform initial todo reset check
        resetTodosIfNeeded();
        // Ensure every project has a color and that colors are unique when possible.
        (function assignProjectColors() {
          const used = new Set();
          let assigned = false;
          data.projects.forEach(p => {
            // If project has a color but it has already been used by a previous project, treat as missing
            if (!p.color || used.has(p.color)) {
              p.color = getUniqueColor();
              assigned = true;
            }
            used.add(p.color);
          });
          if (assigned) {
            saveData();
          }
        })();
        // Global variables to track recommended projects (by id)
        let currentRecommendedWeeklyId = null;
        let currentRecommendedMonthlyId = null;
        // Load persisted auto sync preference
        const autoSyncPref = localStorage.getItem('autoSyncEnabledPro');
        if (autoSyncPref !== null) {
          autoSyncEnabled = autoSyncPref === 'true';
        }

        // Attempt to restore the backup directory handle from IndexedDB on load. If
        // a handle exists, assign it to the global backupDirHandle so that auto
        // sync can operate without requiring the user to pick a folder each
        // time the page loads.
        loadBackupDirHandle().then(async handle => {
          if (handle) {
            backupDirHandle = handle;
            const permissionState = await getBackupPermissionState(handle);
            backupPermissionState = permissionState;
            if (permissionState === 'granted') {
              backupWarningMessage = '';
              if (handle.name && data.backupDirName !== handle.name) {
                data.backupDirName = handle.name;
                try {
                  localStorage.setItem('timekeeperDataPro', JSON.stringify(data));
                } catch (err) {
                  // Ignore storage write errors; UI will still reflect the folder name.
                }
              }
            } else if (permissionState === 'prompt') {
              if (autoSyncEnabled) {
                disableAutoSyncWithWarning('Auto sync paused: confirm access to your backup folder to resume syncing.');
              } else {
                backupWarningMessage = 'Confirm access to your backup folder to resume auto sync.';
              }
            } else {
              if (autoSyncEnabled) {
                disableAutoSyncWithWarning('Auto sync disabled: permission to the backup folder was denied.');
              } else {
                backupWarningMessage = 'Permission to the backup folder was denied. Select it again to restore auto sync.';
              }
            }
          } else {
            backupDirHandle = null;
            backupPermissionState = 'missing';
            if (autoSyncEnabled) {
              disableAutoSyncWithWarning('Auto sync disabled: no backup folder configured.');
            }
          }
          updateAutoSyncStatus();
          updateFocusBlocker();
        });

        // -------------------------------------------------------------------------
        //  Webhook support and Todo functionality
        //
        //  These constants define the webhook endpoints that should be called when
        //  timers start and stop. They are used to toggle focus modes on the user's
        //  Android and Windows devices. When the first timer starts, the start
        //  webhooks are invoked; when all timers stop, the stop webhooks are invoked.
        const START_WEBHOOKS = ['http://127.0.0.1:8766/focus/start'];
        const STOP_WEBHOOKS = ['http://127.0.0.1:8766/focus/stop'];

        // Send a ping to each URL in the list. Uses navigator.sendBeacon where
        // available to avoid blocking the page; falls back to fetch otherwise.
        function triggerWebhooks(urls) {
          urls.forEach(u => {
            try {
              navigator.sendBeacon(u);
            } catch (err) {
              // sendBeacon may not support GET-only endpoints; fallback to fetch
              fetch(u, { method: 'GET', mode: 'no-cors' }).catch(() => {});
            }
          });
        }

        // Convenience wrappers to trigger start/stop webhooks.
        function triggerFocusStart() {
          triggerWebhooks(START_WEBHOOKS);
        }
        function triggerFocusStop() {
          triggerWebhooks(STOP_WEBHOOKS);
        }

        // Track whether the focus blocker (external MacroDroid/Windows scripts) is currently active.
        // The blocker should only be enabled when the sum of all running timer factors exceeds 0.5.
        let focusBlockerActive = false;
        function updateFocusBlocker() {
          // Sum the factors of all running timers. Use the factor property; if undefined, compute concurrency factor.
          const running = getRunningEntries();
          let total = 0;
          running.forEach(e => {
            total += e.factor || computeConcurrencyFactor(running.length);
          });
          // Activate blocker if we cross the 50% threshold, deactivate if we drop below or equal
          if (!focusBlockerActive && total > 0.5) {
            focusBlockerActive = true;
            triggerFocusStart();
          } else if (focusBlockerActive && total <= 0.5) {
            focusBlockerActive = false;
            triggerFocusStop();
          }
        }

        // Update the Workout section UI based on the current data.todos array.
        // Each workout has a name, a weekly target (number of sessions), and a list of
        // logs indicating when sessions were completed. We display progress
        // relative to the weekly target and provide buttons to log a session,
        // edit the target, or delete the workout. The UI resets weekly on
        // Mondays by filtering logs before this week.
        function commitFitnessMutation(mutator) {
          const fitness = ensureFitnessDefaults();
          mutator(fitness);
          saveData();
          updateTodoSection();
          updateGrocerySection();
        }
        function updateFitnessCards(statsInfo) {
          const summaryEl = document.getElementById('fitnessSummaryContent');
          const settingsEl = document.getElementById('fitnessSettingsContent');
          const fitness = ensureFitnessDefaults();
          const statsData = statsInfo || collectWorkoutStats();
          const stats = Array.isArray(statsData.stats) ? statsData.stats : [];
          const hasTargets = stats.some(stat => stat.target > 0);
          const summary = hasTargets ? computeFitnessSummary(stats, fitness.alpha, fitness.beta) : {
            adjPercent: 0,
            totalPenalty: 0,
            totalOverage: 0,
            complianceAvg: 1,
            totalTargets: 0,
            totalActual: 0
          };
          const currentMultiplier = clampMultiplier(fitness.currentMultiplier || 1);
          const nextMultiplier = clampMultiplier(typeof fitness.nextMultiplier === 'number' ? fitness.nextMultiplier : currentMultiplier);
          const projectedMultiplier = clampMultiplier(1 + summary.adjPercent);
          const weeklyBaseBudget = (data.groceryBudgetWeekly || 0) + (data.groceryBudgetWeeklyCarry || 0);
          const currentBudget = weeklyBaseBudget * currentMultiplier;
          const nextBudget = weeklyBaseBudget * nextMultiplier;
          const projectedBudget = weeklyBaseBudget * projectedMultiplier;
          const totalTargetSessions = stats.reduce((acc, stat) => stat.target > 0 ? acc + stat.target : acc, 0);
          const totalActualSessions = stats.reduce((acc, stat) => stat.target > 0 ? acc + stat.actual : acc, 0);
          const complianceRatio = totalTargetSessions > 0 ? totalActualSessions / totalTargetSessions : 0;
          const pausedThisWeek = isWeekPaused(getWeekKey(new Date()));
          const boostEnabled = fitness.weekendBoostEnabled;
          const boostActive = isWeekendBoostActive();
          const boostUnlocked = fitness.weekendBoostUnlockedWeek === getWeekKey(new Date());
          const boostPercent = Math.round((fitness.weekendBoostPercent || 0) * 100);
          const defaultCreditSettings = makeDefaultFitness().creditSettings;
          const creditSettings = Object.assign({}, defaultCreditSettings, fitness.creditSettings || {});
          const formatAmount = (num) => {
            const str = formatCurrency(num, -1);
            return str ? str.replace(' kr', ' SEK') : '0 SEK';
          };
          if (summaryEl) {
            summaryEl.innerHTML = '';
            const grid = document.createElement('div');
            grid.className = 'fitness-summary-grid';
            function createRow(label, value, subText) {
              const row = document.createElement('div');
              row.className = 'fitness-summary-row';
              const labelEl = document.createElement('div');
              labelEl.className = 'fitness-summary-label';
              labelEl.textContent = label;
              const valueEl = document.createElement('div');
              valueEl.className = 'fitness-summary-value';
              valueEl.textContent = value;
              row.appendChild(labelEl);
              row.appendChild(valueEl);
              if (subText) {
                const sub = document.createElement('div');
                sub.className = 'fitness-summary-sub';
                sub.textContent = subText;
                row.appendChild(sub);
              }
              grid.appendChild(row);
            }
            createRow('Current multiplier', currentMultiplier.toFixed(2) + '×', 'Weekly budget ' + formatAmount(currentBudget));
            const projectedDelta = projectedBudget - weeklyBaseBudget;
            if (hasTargets) {
              createRow('Projected (if week ended today)', projectedMultiplier.toFixed(2) + '×', formatSignedCurrency(projectedDelta));
            }
            const lastWeek = fitness.lastWeekSummary;
            const nextDelta = nextBudget - weeklyBaseBudget;
            let nextSub = formatSignedCurrency(nextDelta);
            if (lastWeek && !lastWeek.paused) {
              const bonusPct = fitness.alpha * lastWeek.totalOverage;
              const penaltyPct = fitness.beta * lastWeek.totalPenalty;
              nextSub += ' • Last week ' + formatPercent(bonusPct, 1) + ' bonus, ' + formatPercent(penaltyPct, 1) + ' penalty';
            } else if (lastWeek && lastWeek.paused) {
              nextSub += ' • Last week paused';
            }
            createRow('Next week (locked)', nextMultiplier.toFixed(2) + '×', nextSub);
            if (hasTargets) {
              createRow('Weekly compliance', totalActualSessions + ' / ' + totalTargetSessions + ' sessions', formatPercent(Math.min(complianceRatio, 1), 1));
            } else {
              createRow('Weekly compliance', 'No targets', null);
            }
            const creditsRow = document.createElement('div');
            creditsRow.className = 'fitness-pill-row';
            const creditsPill = document.createElement('span');
            creditsPill.className = 'fitness-pill';
            creditsPill.textContent = 'Wellness Credits: ' + formatCurrency(fitness.wellnessCredits || 0, -1).replace(' kr', ' SEK');
            creditsRow.appendChild(creditsPill);
            if (fitness.creditsCap) {
              const capPill = document.createElement('span');
              capPill.className = 'fitness-pill muted';
              capPill.textContent = 'Cap ' + formatCurrency(fitness.creditsCap, -1).replace(' kr', ' SEK');
              creditsRow.appendChild(capPill);
            }
            if (fitness.streakCount && fitness.streakCount > 0) {
              const streakPill = document.createElement('span');
              streakPill.className = 'fitness-pill warm';
              streakPill.textContent = '🔥 Streak ' + fitness.streakCount + ' week' + (fitness.streakCount === 1 ? '' : 's');
              creditsRow.appendChild(streakPill);
            }
            summaryEl.appendChild(grid);
            summaryEl.appendChild(creditsRow);
            const boostRow = document.createElement('div');
            boostRow.className = 'fitness-summary-row';
            const boostLabel = document.createElement('div');
            boostLabel.className = 'fitness-summary-label';
            boostLabel.textContent = 'Weekend boost';
            const boostValue = document.createElement('div');
            boostValue.className = 'fitness-summary-value';
            if (!boostEnabled) {
              boostValue.textContent = 'Disabled';
            } else if (boostActive) {
              boostValue.textContent = 'Unlocked: +' + boostPercent + '% on Treats';
            } else if (boostUnlocked) {
              boostValue.textContent = 'Unlocked – waiting for weekend (+' + boostPercent + '%)';
            } else if (hasTargets && totalTargetSessions > 0) {
              const remaining = Math.max(0, totalTargetSessions - totalActualSessions);
              boostValue.textContent = 'Locked – ' + remaining + ' session' + (remaining === 1 ? '' : 's') + ' to unlock +' + boostPercent + '%';
            } else {
              boostValue.textContent = 'Locked';
            }
            boostRow.appendChild(boostLabel);
            boostRow.appendChild(boostValue);
            summaryEl.appendChild(boostRow);
            const pauseRow = document.createElement('div');
            pauseRow.className = 'fitness-summary-row';
            const pauseLabel = document.createElement('div');
            pauseLabel.className = 'fitness-summary-label';
            pauseLabel.textContent = 'Sick / travel pause';
            const pauseValue = document.createElement('div');
            pauseValue.className = 'fitness-summary-value';
            const pauseToggle = document.createElement('label');
            pauseToggle.className = 'switch-label';
            const pauseCheckbox = document.createElement('input');
            pauseCheckbox.type = 'checkbox';
            pauseCheckbox.checked = pausedThisWeek;
            pauseCheckbox.addEventListener('change', () => {
              setWeekPaused(getWeekKey(new Date()), pauseCheckbox.checked);
              saveData();
              updateTodoSection();
              updateGrocerySection();
            });
            const toggleSpan = document.createElement('span');
            toggleSpan.textContent = pauseCheckbox.checked ? 'Paused' : 'Active';
            pauseCheckbox.addEventListener('change', () => {
              toggleSpan.textContent = pauseCheckbox.checked ? 'Paused' : 'Active';
            });
            pauseToggle.appendChild(pauseCheckbox);
            pauseToggle.appendChild(toggleSpan);
            pauseValue.appendChild(pauseToggle);
            pauseRow.appendChild(pauseLabel);
            pauseRow.appendChild(pauseValue);
            summaryEl.appendChild(pauseRow);
            if (creditSettings) {
              const ratesRow = document.createElement('div');
              ratesRow.className = 'fitness-summary-row muted';
              ratesRow.textContent = `Credits: +${creditSettings.base} up to target, +${creditSettings.extra} extra, −${creditSettings.penalty} missed`;
              summaryEl.appendChild(ratesRow);
            }
          }
          if (settingsEl) {
            if (!settingsEl.dataset.initialized) {
              settingsEl.dataset.initialized = 'true';
              const settingsGrid = document.createElement('div');
              settingsGrid.className = 'fitness-settings-grid';
              const controls = {};
              function appendSetting(labelText, control) {
                const row = document.createElement('div');
                row.className = 'fitness-setting-row';
                const label = document.createElement('label');
                label.textContent = labelText;
                row.appendChild(label);
                row.appendChild(control);
                settingsGrid.appendChild(row);
              }
              function registerControl(key, control) {
                controls[key] = control;
                return control;
              }
              const modeSelect = registerControl('mode', document.createElement('select'));
              Object.entries(FITNESS_MODES).forEach(([key, cfg]) => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = cfg.label;
                modeSelect.appendChild(option);
              });
              const customOption = document.createElement('option');
              customOption.value = 'custom';
              customOption.textContent = 'Custom';
              modeSelect.appendChild(customOption);
              modeSelect.addEventListener('change', () => {
                const val = modeSelect.value;
                if (FITNESS_MODES[val]) {
                  commitFitnessMutation(fit => {
                    fit.mode = val;
                    fit.alpha = FITNESS_MODES[val].alpha;
                    fit.beta = FITNESS_MODES[val].beta;
                  });
                } else {
                  commitFitnessMutation(fit => {
                    fit.mode = 'custom';
                  });
                }
              });
              appendSetting('Budget mode', modeSelect);
              const alphaInput = registerControl('alpha', document.createElement('input'));
              alphaInput.type = 'number';
              alphaInput.step = '0.1';
              alphaInput.min = '0';
              alphaInput.addEventListener('change', () => {
                const val = parseFloat(alphaInput.value);
                if (isNaN(val)) {
                  const fallback = ensureFitnessDefaults().alpha;
                  alphaInput.value = (fallback * 100).toFixed(1);
                  return;
                }
                commitFitnessMutation(fit => {
                  fit.alpha = val / 100;
                  fit.mode = 'custom';
                });
              });
              appendSetting('Multiplier bonus α (%)', alphaInput);
              const betaInput = registerControl('beta', document.createElement('input'));
              betaInput.type = 'number';
              betaInput.step = '0.1';
              betaInput.min = '0';
              betaInput.addEventListener('change', () => {
                const val = parseFloat(betaInput.value);
                if (isNaN(val)) {
                  const fallback = ensureFitnessDefaults().beta;
                  betaInput.value = (fallback * 100).toFixed(1);
                  return;
                }
                commitFitnessMutation(fit => {
                  fit.beta = val / 100;
                  fit.mode = 'custom';
                });
              });
              appendSetting('Penalty weight β (%)', betaInput);
              const creditBaseInput = registerControl('creditBase', document.createElement('input'));
              creditBaseInput.type = 'number';
              creditBaseInput.step = '1';
              creditBaseInput.addEventListener('change', () => {
                const val = parseFloat(creditBaseInput.value);
                if (isNaN(val)) {
                  const fallbackFitness = ensureFitnessDefaults();
                  const fallbackCredits = Object.assign({}, defaultCreditSettings, fallbackFitness.creditSettings || {});
                  creditBaseInput.value = String(fallbackCredits.base);
                  return;
                }
                commitFitnessMutation(fit => {
                  if (!fit.creditSettings) fit.creditSettings = {};
                  fit.creditSettings.base = val;
                });
              });
              appendSetting('Credits per session (up to target)', creditBaseInput);
              const creditExtraInput = registerControl('creditExtra', document.createElement('input'));
              creditExtraInput.type = 'number';
              creditExtraInput.step = '1';
              creditExtraInput.addEventListener('change', () => {
                const val = parseFloat(creditExtraInput.value);
                if (isNaN(val)) {
                  const fallbackFitness = ensureFitnessDefaults();
                  const fallbackCredits = Object.assign({}, defaultCreditSettings, fallbackFitness.creditSettings || {});
                  creditExtraInput.value = String(fallbackCredits.extra);
                  return;
                }
                commitFitnessMutation(fit => {
                  if (!fit.creditSettings) fit.creditSettings = {};
                  fit.creditSettings.extra = val;
                });
              });
              appendSetting('Credits per extra session', creditExtraInput);
              const creditPenaltyInput = registerControl('creditPenalty', document.createElement('input'));
              creditPenaltyInput.type = 'number';
              creditPenaltyInput.step = '1';
              creditPenaltyInput.addEventListener('change', () => {
                const val = parseFloat(creditPenaltyInput.value);
                if (isNaN(val)) {
                  const fallbackFitness = ensureFitnessDefaults();
                  const fallbackCredits = Object.assign({}, defaultCreditSettings, fallbackFitness.creditSettings || {});
                  creditPenaltyInput.value = String(fallbackCredits.penalty);
                  return;
                }
                commitFitnessMutation(fit => {
                  if (!fit.creditSettings) fit.creditSettings = {};
                  fit.creditSettings.penalty = val;
                });
              });
              appendSetting('Penalty per missed session', creditPenaltyInput);
              const weeklyBonusInput = registerControl('creditWeeklyBonus', document.createElement('input'));
              weeklyBonusInput.type = 'number';
              weeklyBonusInput.step = '1';
              weeklyBonusInput.addEventListener('change', () => {
                const val = parseFloat(weeklyBonusInput.value);
                if (isNaN(val)) {
                  const fallbackFitness = ensureFitnessDefaults();
                  const fallbackCredits = Object.assign({}, defaultCreditSettings, fallbackFitness.creditSettings || {});
                  weeklyBonusInput.value = String(fallbackCredits.weeklyBonus);
                  return;
                }
                commitFitnessMutation(fit => {
                  if (!fit.creditSettings) fit.creditSettings = {};
                  fit.creditSettings.weeklyBonus = val;
                });
              });
              appendSetting('Weekly bonus', weeklyBonusInput);
              const streakBonusInput = registerControl('creditStreakBonus', document.createElement('input'));
              streakBonusInput.type = 'number';
              streakBonusInput.step = '1';
              streakBonusInput.addEventListener('change', () => {
                const val = parseFloat(streakBonusInput.value);
                if (isNaN(val)) {
                  const fallbackFitness = ensureFitnessDefaults();
                  const fallbackCredits = Object.assign({}, defaultCreditSettings, fallbackFitness.creditSettings || {});
                  streakBonusInput.value = String(fallbackCredits.streakBonus);
                  return;
                }
                commitFitnessMutation(fit => {
                  if (!fit.creditSettings) fit.creditSettings = {};
                  fit.creditSettings.streakBonus = val;
                });
              });
              appendSetting('Streak bonus (4 weeks)', streakBonusInput);
              const creditsCapInput = registerControl('creditsCap', document.createElement('input'));
              creditsCapInput.type = 'number';
              creditsCapInput.step = '1';
              creditsCapInput.min = '0';
              creditsCapInput.addEventListener('change', () => {
                const val = parseFloat(creditsCapInput.value);
                if (isNaN(val)) {
                  const fallbackFitness = ensureFitnessDefaults();
                  creditsCapInput.value = String(Math.max(0, fallbackFitness.creditsCap || 0));
                  return;
                }
                commitFitnessMutation(fit => {
                  fit.creditsCap = Math.max(0, val);
                });
              });
              appendSetting('Credits cap', creditsCapInput);
              const boostToggle = registerControl('boostToggle', document.createElement('input'));
              boostToggle.type = 'checkbox';
              boostToggle.addEventListener('change', () => {
                commitFitnessMutation(fit => {
                  fit.weekendBoostEnabled = boostToggle.checked;
                });
              });
              appendSetting('Enable weekend boost', boostToggle);
              const boostPercentInput = registerControl('boostPercent', document.createElement('input'));
              boostPercentInput.type = 'number';
              boostPercentInput.step = '1';
              boostPercentInput.min = '0';
              boostPercentInput.addEventListener('change', () => {
                const val = parseFloat(boostPercentInput.value);
                if (isNaN(val)) {
                  const fallbackFitness = ensureFitnessDefaults();
                  boostPercentInput.value = ((fallbackFitness.weekendBoostPercent || 0) * 100).toFixed(0);
                  return;
                }
                commitFitnessMutation(fit => {
                  fit.weekendBoostPercent = Math.max(0, val) / 100;
                });
              });
              appendSetting('Weekend boost percent', boostPercentInput);
              settingsEl.innerHTML = '';
              settingsEl.appendChild(settingsGrid);
              settingsEl._fitnessControls = controls;
            }
            const controls = settingsEl._fitnessControls || {};
            const liveFitness = ensureFitnessDefaults();
            const liveCredits = Object.assign({}, defaultCreditSettings, liveFitness.creditSettings || {});
            if (controls.mode) {
              controls.mode.value = FITNESS_MODES[liveFitness.mode] ? liveFitness.mode : 'custom';
            }
            if (controls.alpha) {
              controls.alpha.value = (liveFitness.alpha * 100).toFixed(1);
            }
            if (controls.beta) {
              controls.beta.value = (liveFitness.beta * 100).toFixed(1);
            }
            if (controls.creditBase) {
              controls.creditBase.value = String(liveCredits.base);
            }
            if (controls.creditExtra) {
              controls.creditExtra.value = String(liveCredits.extra);
            }
            if (controls.creditPenalty) {
              controls.creditPenalty.value = String(liveCredits.penalty);
            }
            if (controls.creditWeeklyBonus) {
              controls.creditWeeklyBonus.value = String(liveCredits.weeklyBonus);
            }
            if (controls.creditStreakBonus) {
              controls.creditStreakBonus.value = String(liveCredits.streakBonus);
            }
            if (controls.creditsCap) {
              const capVal = typeof liveFitness.creditsCap === 'number' && isFinite(liveFitness.creditsCap) ? liveFitness.creditsCap : 0;
              controls.creditsCap.value = String(Math.max(0, capVal));
            }
            if (controls.boostToggle) {
              controls.boostToggle.checked = !!liveFitness.weekendBoostEnabled;
            }
            if (controls.boostPercent) {
              controls.boostPercent.value = ((liveFitness.weekendBoostPercent || 0) * 100).toFixed(0);
            }
          }
        }
        function updateTodoSection() {
          const listEl = document.getElementById('todoList');
          if (!listEl) return;
          listEl.innerHTML = '';
          const todos = Array.isArray(data.todos) ? data.todos : [];
          // Determine the start of the current week (Monday 00:00) to count this week's logs
          const now = new Date();
          const dow = now.getDay();
          const diffToMonday = (dow + 6) % 7;
          const monday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - diffToMonday);
          monday.setHours(0, 0, 0, 0);
          todos.forEach(todo => {
            if (typeof todo.weeklyTarget !== 'number' || todo.weeklyTarget < 1) {
              todo.weeklyTarget = 1;
            }
            if (!Array.isArray(todo.logs)) todo.logs = [];
            if (todo.carryOver === undefined) todo.carryOver = 0;
          });
          const statsInfo = collectWorkoutStats({ start: monday });
          updateFitnessCards(statsInfo);
          const statsById = new Map(statsInfo.stats.map(stat => [stat.id, stat]));
          const fitness = ensureFitnessDefaults();
          const alpha = fitness.alpha;
          const beta = fitness.beta;
          const creditSettings = Object.assign({}, makeDefaultFitness().creditSettings, fitness.creditSettings || {});
          const fragment = document.createDocumentFragment();
          todos.forEach((todo, index) => {
            // Ensure workout properties exist
            // Dynamic target for this week includes spillover from previous weeks
            const dynamicTarget = Math.max(0, todo.weeklyTarget + todo.carryOver);
            // Count sessions completed this week by filtering logs on or after Monday
            const sessionsThisWeek = todo.logs.filter(log => {
              const t = new Date(log);
              return t >= monday;
            }).length;
            const statInfo = statsById.get(todo.id) || { target: todo.weeklyTarget, actual: sessionsThisWeek };
            const baseTarget = statInfo.target;
            const actualSessions = statInfo.actual;
            let projectedDeltaPercent = 0;
            if (baseTarget > 0) {
              const currentCompliance = Math.min(1, actualSessions / baseTarget);
              const nextCompliance = Math.min(1, (actualSessions + 1) / baseTarget);
              const deltaPenalty = currentCompliance - nextCompliance;
              const currentOverage = Math.max(0, (actualSessions / baseTarget) - 1);
              const nextOverage = Math.max(0, ((actualSessions + 1) / baseTarget) - 1);
              const deltaOverage = nextOverage - currentOverage;
              projectedDeltaPercent = (alpha * deltaOverage - beta * deltaPenalty) * 100;
            }
            let impactText;
            if (baseTarget <= 0) {
              impactText = 'Budget impact: set a weekly target';
            } else if (Math.abs(projectedDeltaPercent) >= 0.05) {
              impactText = `Budget impact: ${projectedDeltaPercent > 0 ? '+' : ''}${projectedDeltaPercent.toFixed(1)}% next week`;
            } else if (actualSessions >= baseTarget) {
              impactText = 'Budget impact: already maxed';
            } else if (projectedDeltaPercent > 0) {
              impactText = 'Budget impact: <0.1% next week – almost there';
            } else {
              const remainingToTarget = Math.max(0, baseTarget - actualSessions);
              impactText = remainingToTarget === 1 ? 'Budget impact: one more session to move the needle' : 'Budget impact: keep going';
            }
            const nextCredit = baseTarget > 0 ? (actualSessions < baseTarget ? creditSettings.base : creditSettings.extra) : 0;
            // Create list item container
            const li = document.createElement('li');
            li.style.display = 'flex';
            li.style.flexDirection = 'column';
            li.style.gap = '0.3rem';
            li.style.padding = '0.5rem 0';
            li.style.borderBottom = '1px solid #f1f5f9';
            // Title row: workout name and delete button
            const titleRow = document.createElement('div');
            titleRow.style.display = 'flex';
            titleRow.style.justifyContent = 'space-between';
            titleRow.style.alignItems = 'center';
            const nameSpan = document.createElement('span');
            nameSpan.textContent = todo.name || '';
            nameSpan.style.fontWeight = '600';
            titleRow.appendChild(nameSpan);
            const btnGroup = document.createElement('div');
            // Log session button
            const logBtn = document.createElement('button');
            logBtn.className = 'btn';
            logBtn.textContent = '+ Log';
            logBtn.style.fontSize = '0.7rem';
            logBtn.addEventListener('click', () => {
              // Add a log for now
              todo.logs.push(new Date().toISOString());
              saveData();
              updateTodoSection();
              // Provide tactile feedback on log
              if (typeof provideHaptic === 'function') {
                provideHaptic('beep');
              }
            });
            btnGroup.appendChild(logBtn);
            // Edit target button
            const editBtn = document.createElement('button');
            editBtn.className = 'btn secondary';
            editBtn.textContent = 'Edit';
            editBtn.style.fontSize = '0.7rem';
            editBtn.addEventListener('click', () => {
              const newTargetStr = prompt('Set weekly target for ' + (todo.name || ''), String(todo.weeklyTarget));
              if (newTargetStr !== null) {
                const newTarget = parseInt(newTargetStr, 10);
                if (!isNaN(newTarget) && newTarget > 0) {
                  todo.weeklyTarget = newTarget;
                  saveData();
                  updateTodoSection();
                }
              }
            });
            btnGroup.appendChild(editBtn);
            // Delete button
            const delBtn = document.createElement('button');
            delBtn.className = 'btn danger';
            delBtn.textContent = 'Delete';
            delBtn.style.fontSize = '0.7rem';
            delBtn.addEventListener('click', () => {
              data.todos.splice(index, 1);
              saveData();
              updateTodoSection();
            });
            btnGroup.appendChild(delBtn);
            titleRow.appendChild(btnGroup);
            li.appendChild(titleRow);
            // Progress bar and text
            const progressContainer = document.createElement('div');
            progressContainer.style.display = 'flex';
            progressContainer.style.flexDirection = 'column';
            progressContainer.style.gap = '0.15rem';
            // Bar container
            const bar = document.createElement('div');
            bar.style.height = '0.35rem';
            bar.style.backgroundColor = '#e2e8f0';
            bar.style.borderRadius = '0.25rem';
            bar.style.overflow = 'hidden';
            // Fill bar representing sessions completed
            const fill = document.createElement('div');
            // Use dynamicTarget for progress and colour the bar green when the goal is met or exceeded.
            const pct = dynamicTarget > 0 ? (sessionsThisWeek / dynamicTarget) : 1;
            fill.style.width = Math.min(pct, 1) * 100 + '%';
            fill.style.height = '100%';
            fill.style.backgroundColor = pct >= 1 ? '#15803d' : '#3b82f6';
            bar.appendChild(fill);
            progressContainer.appendChild(bar);
            // Text showing sessions vs dynamic target
            const text = document.createElement('div');
            text.style.fontSize = '0.75rem';
            text.textContent = sessionsThisWeek + ' / ' + dynamicTarget + ' sessions';
            progressContainer.appendChild(text);
            const impactLine = document.createElement('div');
            impactLine.className = 'fitness-impact-line';
            impactLine.textContent = impactText;
            progressContainer.appendChild(impactLine);
            if (nextCredit > 0) {
              const creditLine = document.createElement('div');
              creditLine.className = 'fitness-credit-line';
              creditLine.textContent = 'Wellness Credits: +' + nextCredit + ' SEK on next session';
              progressContainer.appendChild(creditLine);
            }
            li.appendChild(progressContainer);
            fragment.appendChild(li);
          });
          listEl.appendChild(fragment);
        }

        // Attach submit handler to the Workout form. When submitted, a new workout is
        // added to data.todos with a unique ID, weekly target, and empty logs array.
        const todoForm = document.getElementById('todoForm');
        if (todoForm) {
          todoForm.addEventListener('submit', e => {
            e.preventDefault();
            const nameInput = document.getElementById('todoName');
            const targetInput = document.getElementById('todoTarget');
            const name = nameInput.value.trim();
            const targetVal = parseInt(targetInput.value, 10);
            if (!name) return;
            const target = (!isNaN(targetVal) && targetVal > 0) ? targetVal : 1;
            if (!Array.isArray(data.todos)) {
              data.todos = [];
            }
            // When adding a new workout, initialise carryOver to zero so that spillover can be tracked.
            data.todos.push({ id: uuid(), name: name, weeklyTarget: target, logs: [], carryOver: 0 });
            saveData();
            updateTodoSection();
            nameInput.value = '';
            targetInput.value = '';
          });
        }

        // Attach submit handler to the Grocery form. When submitted, a new grocery
        // item is added to data.groceries with a unique ID, frequency, carryOver
        // and purchasedCount initialised to zero.
        const groceryForm = document.getElementById('groceryForm');
        if (groceryForm) {
          groceryForm.addEventListener('submit', e => {
            e.preventDefault();
            const nameInput = document.getElementById('groceryName');
            const freqSelect = document.getElementById('groceryFreq');
            const categorySelect = document.getElementById('groceryCategory');
            const name = nameInput.value.trim();
            const freq = freqSelect.value;
            const category = categorySelect ? categorySelect.value : 'standard';
            if (!name) return;
            if (!Array.isArray(data.groceries)) {
              data.groceries = [];
            }
            // When adding a new grocery item, initialise it as not archived with no purchase date.
            data.groceries.push({
              id: uuid(),
              name: name,
              frequency: freq,
              category: category,
              archived: false,
              purchasedDate: null,
              originalCost: 0,
              appliedCredits: 0,
              boostApplied: false,
              boostPercentApplied: 0
            });
            saveData();
            updateGrocerySection();
            nameInput.value = '';
            freqSelect.value = 'weekly';
            if (categorySelect) categorySelect.value = 'standard';
          });
        }

        // Render the todo list once on load so that tasks persist across
        // navigation between sections.
        updateTodoSection();

        // Render groceries list on load (reset is triggered within the renderer)
        updateGrocerySection();

        // -------------------------------------------------------------------------
        //  Grocery functions
        //
        //  The grocery section tracks items that should be purchased either weekly
        //  or monthly. Each item has a base target of 1 purchase per period. A
        //  carryOver value (positive or negative) indicates how many extra or
        //  fewer items should be purchased next period due to under- or over-
        //  purchase in the previous period. On reset (weekly or monthly), the
        //  carryOver is updated based on the difference between the dynamic
        //  target (base + carryOver) and the number of purchases made. The
        //  dynamic target for the current period is base + carryOver (clamped
        //  to zero).

        function updateGrocerySection() {
          resetGroceriesIfNeeded();
          const weeklyListEl = document.getElementById('weeklyGroceryList');
          const monthlyListEl = document.getElementById('monthlyGroceryList');
          const biannualListEl = document.getElementById('biannualGroceryList');
          const summaryContainer = document.getElementById('budgetSummaryContainer');
          if (!weeklyListEl || !monthlyListEl || !biannualListEl || !summaryContainer) return;
          // Clear lists and summary
          weeklyListEl.innerHTML = '';
          monthlyListEl.innerHTML = '';
          biannualListEl.innerHTML = '';
          summaryContainer.innerHTML = '';
          const groceries = Array.isArray(data.groceries) ? data.groceries : [];
          let normalizedAny = false;
          // Determine period boundaries for weekly, monthly and biannual budgets
          const now = new Date();
          // Weekly boundaries (Monday to next Monday) for spending
          const dayOfWeek = now.getDay();
          const diffToMon = (dayOfWeek + 6) % 7;
          const weekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - diffToMon);
          weekStart.setHours(0, 0, 0, 0);
          const weekEnd = new Date(weekStart.getTime() + 7 * 24 * 60 * 60 * 1000);
          // Monthly boundaries (1st to next 1st) for spending
          const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          monthStart.setHours(0, 0, 0, 0);
          const monthEnd = new Date(now.getFullYear(), now.getMonth() + 1, 1);
          // Biannual boundaries based on start date
          let halfStart;
          let halfEnd;
          {
            // Determine budgeting start date; if not set, default to current date (start of month)
            let startDate = parseLocalDateString(data.groceryBudgetStartDate);
            if (!startDate) {
              // default to first day of current month
              startDate = new Date(now.getFullYear(), now.getMonth(), 1);
              data.groceryBudgetStartDate = formatLocalDateString(startDate);
              // persist start date
              saveData();
            }
            startDate.setHours(0, 0, 0, 0);
            // Compute months difference between startDate and now
            const monthsDiff = (now.getFullYear() - startDate.getFullYear()) * 12 + (now.getMonth() - startDate.getMonth());
            const halfIndex = Math.floor(monthsDiff / 6);
            halfStart = new Date(startDate.getFullYear(), startDate.getMonth() + halfIndex * 6, startDate.getDate());
            halfStart.setHours(0, 0, 0, 0);
            halfEnd = new Date(startDate.getFullYear(), startDate.getMonth() + (halfIndex + 1) * 6, startDate.getDate());
            halfEnd.setHours(0, 0, 0, 0);
          }
          // Compute amount spent in each period
          let weeklySpent = 0;
          let monthlySpent = 0;
          let biannualSpent = 0;
          groceries.forEach(it => {
            if (!it || !it.archived || !it.purchasedDate) return;
            const cost = Number(it.cost);
            if (!Number.isFinite(cost)) return;
            const freq = typeof it.frequency === 'string' ? it.frequency.toLowerCase() : 'weekly';
            if (it.frequency !== freq) {
              it.frequency = freq;
              normalizedAny = true;
            }
            const pd = new Date(it.purchasedDate);
            if (isNaN(pd)) return;
            if (freq === 'weekly' && pd >= weekStart && pd < weekEnd) {
              weeklySpent += cost;
            }
            if (freq === 'monthly' && pd >= monthStart && pd < monthEnd) {
              monthlySpent += cost;
            }
            if (freq === 'biannual' && pd >= halfStart && pd < halfEnd) {
              biannualSpent += cost;
            }
          });

        // After rendering active items, render archived purchases with ability to edit cost
        const archivedListEl = document.getElementById('archivedGroceryList');
        if (archivedListEl) {
          // Clear previous list
          archivedListEl.innerHTML = '';
          groceries.forEach((archItem, archIndex) => {
            if (!archItem.archived) return;
            const liArch = document.createElement('li');
            liArch.style.display = 'flex';
            liArch.style.flexDirection = 'column';
            liArch.style.gap = '0.3rem';
            liArch.style.padding = '0.5rem 0';
            liArch.style.borderBottom = '1px solid #f1f5f9';
            // Row containing details and action buttons
            const rowArch = document.createElement('div');
            rowArch.style.display = 'flex';
            rowArch.style.justifyContent = 'space-between';
            rowArch.style.alignItems = 'center';
            // Details span: name – cost – frequency – purchase date
            const detailsSpan = document.createElement('span');
            let dateStr = '';
            const freq = typeof archItem.frequency === 'string' ? archItem.frequency.toLowerCase() : 'weekly';
            if (archItem.frequency !== freq) {
              archItem.frequency = freq;
              normalizedAny = true;
            }
            if (archItem.purchasedDate) {
              const dt = new Date(archItem.purchasedDate);
              dateStr = dt.toLocaleDateString();
            }
            const costNum = Number(archItem.cost);
            const costString = Number.isFinite(costNum) ? formatCurrency(costNum, -1).replace(' kr', ' SEK') : '0 SEK';
            const parts = [`${archItem.name}`, costString];
            const originalCostNum = Number(archItem.originalCost);
            if (Number.isFinite(originalCostNum) && originalCostNum !== costNum) {
              const originalString = formatCurrency(originalCostNum, -1).replace(' kr', ' SEK');
              let creditNote = `original ${originalString}`;
              const appliedCreditsNum = Number(archItem.appliedCredits);
              if (Number.isFinite(appliedCreditsNum) && appliedCreditsNum > 0) {
                creditNote += `, credits −${formatCurrency(appliedCreditsNum, -1).replace(' kr', ' SEK')}`;
              }
              parts.push(creditNote);
            }
            const freqLabel = freq.charAt(0).toUpperCase() + freq.slice(1);
            parts.push(freqLabel);
            if (dateStr) parts.push(dateStr);
            detailsSpan.textContent = parts.join(' – ');
            rowArch.appendChild(detailsSpan);
            if (archItem.boostApplied && archItem.boostPercentApplied) {
              const boostNote = document.createElement('div');
              boostNote.className = 'treat-note archived';
              boostNote.textContent = 'Weekend Boost covered ' + Math.round((archItem.boostPercentApplied || (typeof fitness !== 'undefined' && fitness.weekendBoostPercent ? fitness.weekendBoostPercent : 0)) * 100) + '%';
              liArch.appendChild(boostNote);
            }
            // Action buttons for archived items
            const btnGroupArch = document.createElement('div');
            // Edit archived item: allows editing cost
            const editArchBtn = document.createElement('button');
            editArchBtn.className = 'btn secondary';
            editArchBtn.textContent = 'Edit';
            editArchBtn.style.fontSize = '0.7rem';
            editArchBtn.addEventListener('click', () => {
              // Prompt for new cost
              let newCostStr = prompt('Edit cost of this item (SEK)', String(archItem.cost || 0));
              if (newCostStr === null) return;
              let newCostVal = parseFloat(newCostStr);
              if (isNaN(newCostVal)) newCostVal = 0;
              archItem.cost = newCostVal;
              // Update purchase date to now if none exists
              if (!archItem.purchasedDate) {
                archItem.purchasedDate = new Date().toISOString();
              }
              saveData();
              updateGrocerySection();
              if (typeof provideHaptic === 'function') {
                provideHaptic('beep');
              }
            });
            btnGroupArch.appendChild(editArchBtn);
            // Delete archived item
            const deleteArchBtn = document.createElement('button');
            deleteArchBtn.className = 'btn danger';
            deleteArchBtn.textContent = 'Delete';
            deleteArchBtn.style.fontSize = '0.7rem';
            deleteArchBtn.addEventListener('click', () => {
              data.groceries.splice(archIndex, 1);
              saveData();
              updateGrocerySection();
            });
            btnGroupArch.appendChild(deleteArchBtn);
            rowArch.appendChild(btnGroupArch);
            liArch.appendChild(rowArch);
            archivedListEl.appendChild(liArch);
          });
        }
          // Dynamic budgets = base + carry
          const fitness = ensureFitnessDefaults();
          const currentMultiplier = clampMultiplier(fitness.currentMultiplier || 1);
          const nextMultiplier = clampMultiplier(typeof fitness.nextMultiplier === 'number' ? fitness.nextMultiplier : currentMultiplier);
          const weeklyBaseBudget = data.groceryBudgetWeekly || 0;
          const monthlyBaseBudget = data.groceryBudgetMonthly || 0;
          const biBaseBudget = data.groceryBudgetBiYearly || 0;
          const weeklyBaseWithCarry = weeklyBaseBudget + (data.groceryBudgetWeeklyCarry || 0);
          const monthlyDynamicBudget = monthlyBaseBudget + (data.groceryBudgetMonthlyCarry || 0);
          const biDynamicBudget = biBaseBudget + (data.groceryBudgetBiYearlyCarry || 0);
          const weeklyDynamicBudget = weeklyBaseWithCarry * currentMultiplier;
          const nextWeekBudget = weeklyBaseWithCarry * nextMultiplier;
          // Time progress for budgets (fraction of period elapsed)
          const weekTimeProgress = clampUnitInterval((now - weekStart) / (weekEnd - weekStart));
          const monthTimeProgress = clampUnitInterval((now - monthStart) / (monthEnd - monthStart));
          const halfTimeProgress = clampUnitInterval((now - halfStart) / (halfEnd - halfStart));
          // Expected spending so far
          const weeklyExpectedSpent = weeklyDynamicBudget * weekTimeProgress;
          const monthlyExpectedSpent = monthlyDynamicBudget * monthTimeProgress;
          const biExpectedSpent = biDynamicBudget * halfTimeProgress;
          // Build budget summary card
          const summaryCard = document.createElement('div');
          summaryCard.className = 'card';
          summaryCard.style.marginBottom = '1rem';
          const summaryTitle = document.createElement('h3');
          summaryTitle.style.margin = '0 0 0.5rem 0';
          summaryTitle.style.fontSize = '1.1rem';
          summaryTitle.style.fontWeight = '600';
          summaryTitle.textContent = 'Budget Summary';
          summaryCard.appendChild(summaryTitle);
          function addBudgetLine(label, spent, budget, expected) {
            const line = document.createElement('div');
            line.style.fontSize = '0.85rem';
            line.style.marginBottom = '0.25rem';
            // Format currency to nearest ten (use existing formatCurrency)
            const spentStr = formatCurrency(spent || 0, -1);
            const budgetStr = formatCurrency(budget || 0, -1);
            const expectedStr = formatCurrency(expected || 0, -1);
            line.textContent = `${label}: ${spentStr} / ${budgetStr} SEK (expected ${expectedStr} SEK)`;
            summaryCard.appendChild(line);
            // Create multi progress bar for budgets
            const pb = document.createElement('div');
            pb.className = 'progress-bar multi';
            pb.style.marginBottom = '0.4rem';
            // Expected fill (black)
            const expectedFill = document.createElement('div');
            expectedFill.className = 'expected-fill';
            expectedFill.style.width = budget > 0 ? Math.min(100, (expected / budget) * 100).toFixed(1) + '%' : '0%';
            pb.appendChild(expectedFill);
            // Actual fill (blue)
            const actualFill = document.createElement('div');
            actualFill.className = 'hours-fill';
            actualFill.style.width = budget > 0 ? Math.min(100, (spent / budget) * 100).toFixed(1) + '%' : '0%';
            pb.appendChild(actualFill);
            summaryCard.appendChild(pb);
          }
          addBudgetLine('Weekly', weeklySpent, weeklyDynamicBudget, weeklyExpectedSpent);
          const multiplierLine = document.createElement('div');
          multiplierLine.className = 'fitness-summary-sub';
          multiplierLine.textContent = 'Fitness Multiplier next week: ' + nextMultiplier.toFixed(2) + '× (' + formatSignedCurrency(nextWeekBudget - weeklyBaseWithCarry) + ')';
          summaryCard.appendChild(multiplierLine);
          const creditsLine = document.createElement('div');
          creditsLine.className = 'fitness-summary-sub';
          creditsLine.textContent = 'Wellness Credits: ' + formatCurrency(fitness.wellnessCredits || 0, -1).replace(' kr', ' SEK') + ' (auto-applied)';
          summaryCard.appendChild(creditsLine);
          addBudgetLine('Monthly', monthlySpent, monthlyDynamicBudget, monthlyExpectedSpent);
          addBudgetLine('Biannual', biannualSpent, biDynamicBudget, biExpectedSpent);
          // Add edit buttons for budgets and start date
          const controlsDiv = document.createElement('div');
          controlsDiv.style.display = 'flex';
          controlsDiv.style.gap = '0.5rem';
          controlsDiv.style.marginTop = '0.5rem';
          // Edit budgets button
          const editBudgetsBtn = document.createElement('button');
          editBudgetsBtn.className = 'btn secondary';
          editBudgetsBtn.style.fontSize = '0.75rem';
          editBudgetsBtn.textContent = 'Edit Budgets';
          editBudgetsBtn.addEventListener('click', () => {
            const w = prompt('Weekly budget (SEK)', String(data.groceryBudgetWeekly || 0));
            const m = prompt('Monthly budget (SEK)', String(data.groceryBudgetMonthly || 0));
            const b = prompt('Biannual budget (SEK)', String(data.groceryBudgetBiYearly || 0));
            if (w !== null) {
              const val = parseFloat(w);
              if (!isNaN(val)) data.groceryBudgetWeekly = val;
            }
            if (m !== null) {
              const val = parseFloat(m);
              if (!isNaN(val)) data.groceryBudgetMonthly = val;
            }
            if (b !== null) {
              const val = parseFloat(b);
              if (!isNaN(val)) data.groceryBudgetBiYearly = val;
            }
            saveData();
            updateGrocerySection();
          });
          controlsDiv.appendChild(editBudgetsBtn);
          // Edit start date button
          const editStartBtn = document.createElement('button');
          editStartBtn.className = 'btn secondary';
          editStartBtn.style.fontSize = '0.75rem';
          editStartBtn.textContent = 'Set Start Date';
          editStartBtn.addEventListener('click', () => {
            const d = prompt('Start date for biannual budget periods (YYYY-MM-DD)', data.groceryBudgetStartDate || '');
            if (!d) return;
            const parsed = parseLocalDateString(d);
            if (!parsed) return;
            const normalized = formatLocalDateString(parsed);
            if (data.groceryBudgetStartDate !== normalized) {
              data.groceryBudgetStartDate = normalized;
              saveData();
            }
            updateGrocerySection();
          });
          controlsDiv.appendChild(editStartBtn);
          summaryCard.appendChild(controlsDiv);
          summaryContainer.appendChild(summaryCard);
          // ------------------------------------------------------------
          // In budget-only mode we do not limit the number of items that can be
          // purchased in a period.  We therefore do not compute or display
          // purchase quotas, and buy buttons remain enabled regardless of
          // how many items have been purchased.
          // Render unarchived items
          const boostEnabled = fitness.weekendBoostEnabled;
          const boostActive = isWeekendBoostActive();
          const boostUnlocked = fitness.weekendBoostUnlockedWeek === getWeekKey(new Date());
          const boostPercentDisplay = Math.round((fitness.weekendBoostPercent || 0) * 100);
          groceries.forEach((item, index) => {
            if (item.archived) return;
            const freq = typeof item.frequency === 'string' ? item.frequency.toLowerCase() : 'weekly';
            if (item.frequency !== freq) {
              item.frequency = freq;
              normalizedAny = true;
            }
            const li = document.createElement('li');
            li.style.display = 'flex';
            li.style.flexDirection = 'column';
            li.style.gap = '0.3rem';
            li.style.padding = '0.5rem 0';
            li.style.borderBottom = '1px solid #f1f5f9';
            // Row: name and actions
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.justifyContent = 'space-between';
            row.style.alignItems = 'center';
            const nameSpan = document.createElement('span');
            nameSpan.textContent = item.name;
            nameSpan.style.fontWeight = '600';
            if (item.category === 'treat') {
              const tag = document.createElement('span');
              tag.className = 'treat-tag';
              tag.textContent = 'Treat';
              tag.style.marginLeft = '0.35rem';
              nameSpan.appendChild(tag);
            } else if (item.category === 'essential') {
              const tag = document.createElement('span');
              tag.className = 'treat-tag muted';
              tag.textContent = 'Essential';
              tag.style.marginLeft = '0.35rem';
              nameSpan.appendChild(tag);
            }
            row.appendChild(nameSpan);
            const btnGroup = document.createElement('div');
            // Buy button (log purchase with cost). In budget-only mode there is
            // no limit on the number of purchases per period, so the button
            // is always enabled.
            const buyBtn = document.createElement('button');
            buyBtn.className = 'btn';
            buyBtn.textContent = 'Buy';
            buyBtn.style.fontSize = '0.7rem';
            buyBtn.addEventListener('click', () => {
              // Prompt for cost
              let costStr = prompt('Enter cost of this item (SEK)', '0');
              if (costStr === null) return;
              let costVal = parseFloat(costStr);
              if (isNaN(costVal)) costVal = 0;
              const fitnessData = ensureFitnessDefaults();
              let originalCost = costVal;
              let creditsUsed = 0;
              let boostCreditsUsed = 0;
              let boostPercentApplied = 0;
              const itemFrequency = typeof item.frequency === 'string' ? item.frequency.toLowerCase() : 'weekly';
              if (itemFrequency === 'weekly') {
                const availableCredits = fitnessData.wellnessCredits || 0;
                let remainingCredits = availableCredits;
                if (fitnessData.weekendBoostEnabled && item.category === 'treat' && isWeekendBoostActive()) {
                  const boostPct = Math.max(0, fitnessData.weekendBoostPercent || 0);
                  if (boostPct > 0) {
                    const discount = originalCost * boostPct;
                    boostCreditsUsed = Math.min(discount, remainingCredits);
                    creditsUsed += boostCreditsUsed;
                    remainingCredits -= boostCreditsUsed;
                    boostPercentApplied = boostPct;
                  }
                }
                const additionalCredits = Math.min(remainingCredits, Math.max(0, originalCost - creditsUsed));
                creditsUsed += additionalCredits;
                fitnessData.wellnessCredits = Math.max(0, (fitnessData.wellnessCredits || 0) - creditsUsed);
                costVal = Math.max(0, originalCost - creditsUsed);
              }
              item.originalCost = originalCost;
              item.cost = costVal;
              item.appliedCredits = creditsUsed;
              item.boostApplied = boostCreditsUsed > 0;
              item.boostPercentApplied = boostPercentApplied;
              item.archived = true;
              item.purchasedDate = new Date().toISOString();
              saveData();
              updateGrocerySection();
              if (typeof updateTodoSection === 'function') {
                updateTodoSection();
              }
              if (typeof provideHaptic === 'function') {
                provideHaptic('beep');
              }
            });
            btnGroup.appendChild(buyBtn);
            // Edit button
            const editBtn = document.createElement('button');
            editBtn.className = 'btn secondary';
            editBtn.textContent = 'Edit';
            editBtn.style.fontSize = '0.7rem';
            editBtn.addEventListener('click', () => {
              const newName = prompt('Edit item name', item.name);
              if (newName !== null) {
                item.name = newName.trim();
              }
              const newFreq = prompt('Frequency (weekly/monthly/biannual)', item.frequency);
              if (newFreq !== null) {
                const cleanedFreq = newFreq.trim().toLowerCase();
                if (cleanedFreq === 'weekly' || cleanedFreq === 'monthly' || cleanedFreq === 'biannual') {
                  item.frequency = cleanedFreq;
                }
              }
              const newCategory = prompt('Category (standard/treat/essential)', item.category || 'standard');
              if (newCategory) {
                const cleaned = newCategory.toLowerCase();
                if (cleaned === 'standard' || cleaned === 'treat' || cleaned === 'essential') {
                  item.category = cleaned;
                }
              }
              saveData();
              updateGrocerySection();
            });
            btnGroup.appendChild(editBtn);
            // Delete button
            const delBtn = document.createElement('button');
            delBtn.className = 'btn danger';
            delBtn.textContent = 'Delete';
            delBtn.style.fontSize = '0.7rem';
            delBtn.addEventListener('click', () => {
              data.groceries.splice(index, 1);
              saveData();
              updateGrocerySection();
            });
            btnGroup.appendChild(delBtn);
            row.appendChild(btnGroup);
            li.appendChild(row);
            if (item.category === 'treat') {
              const note = document.createElement('div');
              note.className = 'treat-note';
              if (!boostEnabled) {
                note.textContent = 'Treat item';
              } else if (boostActive) {
                note.textContent = 'Weekend Boost applied: −' + boostPercentDisplay + '% from credits';
              } else if (boostUnlocked) {
                note.textContent = 'Weekend Boost unlocked: +' + boostPercentDisplay + '% on Treats this weekend';
              } else {
                note.textContent = 'Treat item – unlock +' + boostPercentDisplay + '% by Friday 18:00';
              }
              li.appendChild(note);
            }
            // Append to appropriate list
            if (freq === 'monthly') {
              monthlyListEl.appendChild(li);
            } else if (freq === 'biannual') {
              biannualListEl.appendChild(li);
            } else {
              weeklyListEl.appendChild(li);
            }
          });
          updateFitnessCards();
          if (normalizedAny) {
            saveData();
          }
        }

        // Reset grocery budgets for weekly, monthly, and biannual periods. Carry-overs are recalculated
        // whenever we cross a boundary or when archived purchases are edited retroactively.
        function resetGroceriesIfNeeded() {
          const now = new Date();
          let dataChanged = false;
          const budgetStartDate = parseLocalDateString(data.groceryBudgetStartDate);
          if (budgetStartDate) {
            budgetStartDate.setHours(0, 0, 0, 0);
          }
          // Determine the start of this week (Monday at 00:00)
          const dow = now.getDay();
          const diffToMonday = (dow + 6) % 7;
          const thisMonday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - diffToMonday);
          thisMonday.setHours(0, 0, 0, 0);
          const mondayStr = thisMonday.toDateString();
          const prevMonday = new Date(thisMonday.getTime() - 7 * 24 * 60 * 60 * 1000);
          const lastWeekReset = localStorage.getItem('groceryWeeklyResetPro');
          const hasWeekReset = typeof lastWeekReset === 'string' && lastWeekReset.length > 0;
          let weeklySpentPrev = 0;
          if (Array.isArray(data.groceries)) {
            const legacyFallbackDate = new Date(thisMonday.getTime() - 1);
            data.groceries.forEach(item => {
              if (!item || !item.archived) return;
              const freq = typeof item.frequency === 'string' ? item.frequency.toLowerCase() : 'weekly';
              if (item.frequency !== freq) item.frequency = freq;
              if (freq !== 'weekly') return;
              const cost = Number(item.cost);
              if (!Number.isFinite(cost)) return;
              if (item.purchasedDate) {
                const pd = new Date(item.purchasedDate);
                if (pd >= prevMonday && pd < thisMonday) {
                  weeklySpentPrev += cost;
                }
              } else {
                // Exclude legacy purchases without a recorded purchase date from budget calculations.
                // Optionally, assign a neutral date for consistency:
                item.purchasedDate = null;
                // Do not count their cost in weeklySpentPrev.
              }
            });
          }
          const baseBudget = typeof data.groceryBudgetWeekly === 'number' ? data.groceryBudgetWeekly : 0;
          const storedCarry = typeof data.groceryBudgetWeeklyCarry === 'number' ? data.groceryBudgetWeeklyCarry : 0;
          if (hasWeekReset) {
            const baselineCarry = lastWeekReset === mondayStr && typeof data.groceryBudgetWeeklyCarryBaseline === 'number'
              ? data.groceryBudgetWeeklyCarryBaseline
              : storedCarry;
            const dynamicPrevBudget = baseBudget + baselineCarry;
            const newWeeklyCarry = dynamicPrevBudget - weeklySpentPrev;
            if (lastWeekReset !== mondayStr ||
                data.groceryBudgetWeeklyCarry !== newWeeklyCarry ||
                data.groceryBudgetWeeklyCarryBaseline !== baselineCarry) {
              data.groceryBudgetWeeklyCarry = newWeeklyCarry;
              data.groceryBudgetWeeklyCarryBaseline = baselineCarry;
              localStorage.setItem('groceryWeeklyResetPro', mondayStr);
              dataChanged = true;
            }
          } else {
            localStorage.setItem('groceryWeeklyResetPro', mondayStr);
            if (data.groceryBudgetWeeklyCarry !== storedCarry) {
              data.groceryBudgetWeeklyCarry = storedCarry;
              dataChanged = true;
            }
            if (data.groceryBudgetWeeklyCarryBaseline !== storedCarry) {
              data.groceryBudgetWeeklyCarryBaseline = storedCarry;
              dataChanged = true;
            }
          }
          // Monthly carry-over recalculation
          const year = now.getFullYear();
          const month = now.getMonth();
          const thisMonthStart = new Date(year, month, 1);
          thisMonthStart.setHours(0, 0, 0, 0);
          const monthKey = year + '-' + month;
          const lastMonthReset = localStorage.getItem('groceryMonthlyResetPro');
          const hasMonthReset = typeof lastMonthReset === 'string' && lastMonthReset.length > 0;
          const prevMonthStart = new Date(year, month - 1, 1);
          const prevMonthEnd = new Date(year, month, 1);
          let monthlySpentPrev = 0;
          if (Array.isArray(data.groceries)) {
            const legacyFallbackDate = new Date(thisMonthStart.getTime() - 1);
            data.groceries.forEach(item => {
              if (!item || !item.archived) return;
              const freq = typeof item.frequency === 'string' ? item.frequency.toLowerCase() : 'weekly';
              if (item.frequency !== freq) item.frequency = freq;
              if (freq !== 'monthly') return;
              const cost = Number(item.cost);
              if (!Number.isFinite(cost)) return;
              if (item.purchasedDate) {
                const pd = new Date(item.purchasedDate);
                if (pd >= prevMonthStart && pd < prevMonthEnd) {
                  monthlySpentPrev += cost;
                }
              } else {
                // Legacy monthly item without a purchasedDate: skip from monthlySpentPrev calculation.
                // Optionally, flag for user review or log a warning here.
                // No changes to item or monthlySpentPrev.
              }
            });
          }
          const baseBudgetM = typeof data.groceryBudgetMonthly === 'number' ? data.groceryBudgetMonthly : 0;
          const storedCarryM = typeof data.groceryBudgetMonthlyCarry === 'number' ? data.groceryBudgetMonthlyCarry : 0;
          const skipMonthlyCarry = !!(budgetStartDate && prevMonthEnd <= budgetStartDate);
          if (hasMonthReset && !skipMonthlyCarry) {
            const baselineCarryM = lastMonthReset === monthKey && typeof data.groceryBudgetMonthlyCarryBaseline === 'number'
              ? data.groceryBudgetMonthlyCarryBaseline
              : storedCarryM;
            const dynamicPrevBudgetM = baseBudgetM + baselineCarryM;
            const newMonthlyCarry = dynamicPrevBudgetM - monthlySpentPrev;
            if (lastMonthReset !== monthKey ||
                data.groceryBudgetMonthlyCarry !== newMonthlyCarry ||
                data.groceryBudgetMonthlyCarryBaseline !== baselineCarryM) {
              data.groceryBudgetMonthlyCarry = newMonthlyCarry;
              data.groceryBudgetMonthlyCarryBaseline = baselineCarryM;
              localStorage.setItem('groceryMonthlyResetPro', monthKey);
              dataChanged = true;
            }
          } else {
            const fallbackCarryM = typeof data.groceryBudgetMonthlyCarryBaseline === 'number'
              ? data.groceryBudgetMonthlyCarryBaseline
              : storedCarryM;
            localStorage.setItem('groceryMonthlyResetPro', monthKey);
            if (data.groceryBudgetMonthlyCarry !== fallbackCarryM) {
              data.groceryBudgetMonthlyCarry = fallbackCarryM;
              dataChanged = true;
            }
            if (data.groceryBudgetMonthlyCarryBaseline !== fallbackCarryM) {
              data.groceryBudgetMonthlyCarryBaseline = fallbackCarryM;
              dataChanged = true;
            }
          }
          // Biannual carry-over recalculation
          let startDate = budgetStartDate ? new Date(budgetStartDate.getTime()) : null;
          if (!startDate) {
            startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          }
          startDate.setHours(0, 0, 0, 0);
          const monthsDiff = (now.getFullYear() - startDate.getFullYear()) * 12 + (now.getMonth() - startDate.getMonth());
          const currentHalfIndex = Math.floor(monthsDiff / 6);
          const lastHalfReset = localStorage.getItem('groceryBiResetPro');
          const hasHalfReset = typeof lastHalfReset === 'string' && lastHalfReset.length > 0;
          const halfKey = String(currentHalfIndex);
          const prevHalfStart = new Date(startDate.getFullYear(), startDate.getMonth() + (currentHalfIndex - 1) * 6, startDate.getDate());
          const prevHalfEnd = new Date(startDate.getFullYear(), startDate.getMonth() + currentHalfIndex * 6, startDate.getDate());
          let biSpentPrevTotal = 0;
          if (Array.isArray(data.groceries)) {
            const legacyFallbackDate = new Date(prevHalfEnd.getTime() - 1);
            data.groceries.forEach(item => {
              if (!item || !item.archived) return;
              const freq = typeof item.frequency === 'string' ? item.frequency.toLowerCase() : 'weekly';
              if (item.frequency !== freq) item.frequency = freq;
              if (freq !== 'biannual') return;
              const cost = Number(item.cost);
              if (!Number.isFinite(cost)) return;
              if (item.purchasedDate) {
                const pd = new Date(item.purchasedDate);
                if (pd >= prevHalfStart && pd < prevHalfEnd) {
                  biSpentPrevTotal += cost;
                }
              } else {
                // Undated legacy biannual purchase: exclude from carry-over calculation.
                // Optionally, flag for review:
                item.needsDateAssignment = true;
              }
            });
          }
          const baseBudgetBi = typeof data.groceryBudgetBiYearly === 'number' ? data.groceryBudgetBiYearly : 0;
          const storedCarryBi = typeof data.groceryBudgetBiYearlyCarry === 'number' ? data.groceryBudgetBiYearlyCarry : 0;
          const skipBiCarry = !!(budgetStartDate && prevHalfEnd <= budgetStartDate);
          if (hasHalfReset && !skipBiCarry) {
            const baselineCarryBi = lastHalfReset === halfKey && typeof data.groceryBudgetBiYearlyCarryBaseline === 'number'
              ? data.groceryBudgetBiYearlyCarryBaseline
              : storedCarryBi;
            const dynamicPrevBudgetBi = baseBudgetBi + baselineCarryBi;
            const newBiCarry = dynamicPrevBudgetBi - biSpentPrevTotal;
            if (lastHalfReset !== halfKey ||
                data.groceryBudgetBiYearlyCarry !== newBiCarry ||
                data.groceryBudgetBiYearlyCarryBaseline !== baselineCarryBi) {
              data.groceryBudgetBiYearlyCarry = newBiCarry;
              data.groceryBudgetBiYearlyCarryBaseline = baselineCarryBi;
              localStorage.setItem('groceryBiResetPro', halfKey);
              dataChanged = true;
            }
          } else {
            const fallbackCarryBi = typeof data.groceryBudgetBiYearlyCarryBaseline === 'number'
              ? data.groceryBudgetBiYearlyCarryBaseline
              : storedCarryBi;
            localStorage.setItem('groceryBiResetPro', halfKey);
            if (data.groceryBudgetBiYearlyCarry !== fallbackCarryBi) {
              data.groceryBudgetBiYearlyCarry = fallbackCarryBi;
              dataChanged = true;
            }
            if (data.groceryBudgetBiYearlyCarryBaseline !== fallbackCarryBi) {
              data.groceryBudgetBiYearlyCarryBaseline = fallbackCarryBi;
              dataChanged = true;
            }
          }
          if (dataChanged) {
            saveData();
          }
        }

        // Render reports section including monthly heatmap and per-project burndown charts. This
        // function is called whenever navigating to the Reports section or when data is
        // updated (e.g., after modifying entries). It recomputes the heatmap for the
        // current month and builds burndown charts for each project using Chart.js.
        let burndownCharts = {};
        function updateAnalyticsSection() {
          const heatmapContainer = document.getElementById('heatmapContainer');
          const burndownContainer = document.getElementById('burndownContainer');
          if (!heatmapContainer || !burndownContainer) return;
          // Clear previous contents
          heatmapContainer.innerHTML = '';
          burndownContainer.innerHTML = '';
          // ---------- Build monthly heatmap ----------
          // Determine the start and end of the current month
          const now = new Date();
          const year = now.getFullYear();
          const month = now.getMonth();
          const firstDay = new Date(year, month, 1);
          const lastDay = new Date(year, month + 1, 0);
          const daysInMonth = lastDay.getDate();
          // Accumulate hours per day
          const hoursPerDay = {};
          // Initialize to zero for each day of month
          for (let d = 1; d <= daysInMonth; d++) {
            hoursPerDay[d] = 0;
          }
          data.entries.forEach(entry => {
            if (entry.isRunning || !entry.duration) return;
            const start = new Date(entry.startTime);
            if (start.getFullYear() === year && start.getMonth() === month) {
              const day = start.getDate();
              hoursPerDay[day] = (hoursPerDay[day] || 0) + entry.duration / 3600;
            }
          });
          // Compute maximum hours for scaling colors
          let maxHours = 0;
          Object.values(hoursPerDay).forEach(h => { if (h > maxHours) maxHours = h; });
          // Build a 7-column table starting on Monday (0=Monday). We will map JS getDay (0=Sunday) to Monday start.
          const heatmapTable = document.createElement('table');
          heatmapTable.style.width = '100%';
          heatmapTable.style.borderCollapse = 'collapse';
          const headerRow = document.createElement('tr');
          ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'].forEach(dName => {
            const th = document.createElement('th');
            th.textContent = dName;
            th.style.textAlign = 'center';
            th.style.padding = '0.25rem';
            th.style.fontSize = '0.75rem';
            headerRow.appendChild(th);
          });
          heatmapTable.appendChild(headerRow);
          // Determine the weekday index of the first day (0=Monday, 6=Sunday)
          const firstDow = (firstDay.getDay() + 6) % 7;
          let currentDay = 1;
          // We'll build up to 6 rows to cover all days
          for (let week = 0; week < 6; week++) {
            const tr = document.createElement('tr');
            for (let dow = 0; dow < 7; dow++) {
              const td = document.createElement('td');
              td.style.border = '1px solid #e2e8f0';
              td.style.height = '1.5rem';
              td.style.textAlign = 'center';
              td.style.fontSize = '0.7rem';
              // Determine if this cell corresponds to a valid day
              const cellIndex = week * 7 + dow;
              if (cellIndex >= firstDow && currentDay <= daysInMonth) {
                const dayNum = currentDay;
                const hours = hoursPerDay[dayNum] || 0;
                // Colour intensity based on hours
                let alpha;
                if (maxHours > 0) {
                  alpha = 0.1 + 0.8 * (hours / maxHours);
                } else {
                  alpha = 0;
                }
                td.style.backgroundColor = `rgba(59, 130, 246, ${alpha.toFixed(2)})`;
                // Display day number and hours (optional)
                const spanDay = document.createElement('div');
                spanDay.textContent = dayNum.toString();
                spanDay.style.fontWeight = '600';
                const spanHrs = document.createElement('div');
                spanHrs.textContent = hours > 0 ? hours.toFixed(1) + 'h' : '';
                spanHrs.style.fontSize = '0.6rem';
                td.appendChild(spanDay);
                td.appendChild(spanHrs);
                currentDay++;
              } else {
                td.textContent = '';
              }
              tr.appendChild(td);
            }
            heatmapTable.appendChild(tr);
            if (currentDay > daysInMonth) break;
          }
          heatmapContainer.appendChild(heatmapTable);
          // ---------- Build hours by project bar chart ----------
          // Compute total hours worked per project in the current month
          const barLabels = [];
          const barHours = [];
          const barTargets = [];
          data.projects.forEach(project => {
            const sp = computeProjectStats(project);
            barLabels.push(project.name);
            // Use monthlyHours for actual and monthlyTargetConst for target
            barHours.push(sp.monthlyHours || 0);
            barTargets.push(sp.monthlyTargetConst || 0);
          });
          if (barLabels.length > 0) {
            const barCard = document.createElement('div');
            barCard.style.marginBottom = '1rem';
            const barTitle = document.createElement('h3');
            barTitle.style.margin = '0 0 0.5rem 0';
            barTitle.style.fontSize = '1.1rem';
            barTitle.style.fontWeight = '600';
            barTitle.textContent = 'Hours by Project (This Month)';
            barCard.appendChild(barTitle);
            const barCanvas = document.createElement('canvas');
            barCanvas.height = 200;
            barCard.appendChild(barCanvas);
            heatmapContainer.appendChild(barCard);
            const ctxBar = barCanvas.getContext('2d');
            new Chart(ctxBar, {
              type: 'bar',
              data: {
                labels: barLabels,
                datasets: [
                  {
                    label: 'Hours Worked',
                    data: barHours,
                    backgroundColor: '#3b82f6',
                    borderColor: '#3b82f6',
                    borderWidth: 1
                  },
                  {
                    label: 'Target Hours',
                    data: barTargets,
                    backgroundColor: '#94a3b8',
                    borderColor: '#94a3b8',
                    borderWidth: 1
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: { display: false },
                    ticks: { autoSkip: false }
                  },
                  y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Hours' }
                  }
                },
                plugins: { legend: { display: true } }
              }
            });
          }

          // ---------- Build daily hours line chart for the current month ----------
          // This chart shows how many hours were worked each day of the current month and compares to the
          // average daily target (monthlyTargetConst / daysInMonth) aggregated across all projects.
          // Compute daily hours across all projects
          const dailyLabels = [];
          const dailyHoursData = [];
          const dailyTargetData = [];
          for (let d = 1; d <= daysInMonth; d++) {
            dailyLabels.push(d.toString());
            dailyHoursData.push(hoursPerDay[d] || 0);
            // Sum monthly targets for all projects to compute aggregate monthly target and then average per day
            const dayTarget = data.projects.reduce((sum, proj) => {
              const ps = computeProjectStats(proj);
              return sum + (ps.monthlyTargetConst || 0);
            }, 0) / daysInMonth;
            dailyTargetData.push(dayTarget);
          }
          // Only render chart if there is at least one project
          if (dailyLabels.length > 0 && data.projects.length > 0) {
            const lineCard = document.createElement('div');
            lineCard.style.marginBottom = '1rem';
            const lineTitle = document.createElement('h3');
            lineTitle.style.margin = '0 0 0.5rem 0';
            lineTitle.style.fontSize = '1.1rem';
            lineTitle.style.fontWeight = '600';
            lineTitle.textContent = 'Daily Hours Trend (This Month)';
            lineCard.appendChild(lineTitle);
            const lineCanvas = document.createElement('canvas');
            lineCanvas.height = 200;
            lineCard.appendChild(lineCanvas);
            heatmapContainer.appendChild(lineCard);
            const ctxLine = lineCanvas.getContext('2d');
            new Chart(ctxLine, {
              type: 'line',
              data: {
                labels: dailyLabels,
                datasets: [
                  {
                    label: 'Hours Worked',
                    data: dailyHoursData,
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59,130,246,0.3)',
                    fill: false,
                    tension: 0.1
                  },
                  {
                    label: 'Daily Target (avg)',
                    data: dailyTargetData,
                    borderColor: '#999999',
                    backgroundColor: 'rgba(153,153,153,0.3)',
                    borderDash: [5,5],
                    fill: false,
                    tension: 0.1
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: { title: { display: true, text: 'Day of Month' }, ticks: { autoSkip: false } },
                  y: { beginAtZero: true, title: { display: true, text: 'Hours' } }
                },
                plugins: { legend: { display: true }, tooltip: { mode: 'index', intersect: false } }
              }
            });
          }
          // ---------- Build per-project burndown charts ----------
          // Destroy existing charts to prevent memory leaks
          Object.values(burndownCharts).forEach(ch => {
            if (ch && typeof ch.destroy === 'function') ch.destroy();
          });
          burndownCharts = {};
          data.projects.forEach(project => {
            // Compute daily cumulative hours from project creation to now
            const createdAt = new Date(project.createdAt);
            const deadline = new Date(project.deadline);
            const today = new Date();
            // Determine end date for chart: use min(today, deadline)
            const endDate = today < deadline ? today : deadline;
            // Build date labels and cumulative actual hours and expected hours arrays
            const labels = [];
            const actualData = [];
            const expectedData = [];
            const totalDays = Math.ceil((endDate - createdAt) / (1000 * 60 * 60 * 24)) || 1;
            // Create a map of cumulative hours keyed by date string
            const dailyHoursMap = {};
            data.entries.forEach(entry => {
              if (entry.isRunning || !entry.duration) return;
              if (entry.projectId !== project.id) return;
              const start = new Date(entry.startTime);
              const dateStr = start.toISOString().split('T')[0];
              dailyHoursMap[dateStr] = (dailyHoursMap[dateStr] || 0) + entry.duration / 3600;
            });
            let cumulative = 0;
            for (let i = 0; i < totalDays; i++) {
              const date = new Date(createdAt.getTime());
              date.setDate(createdAt.getDate() + i);
              const dateStr = date.toISOString().split('T')[0];
              labels.push(dateStr);
              cumulative += dailyHoursMap[dateStr] || 0;
              actualData.push(cumulative);
              // Expected cumulative: linear expected burn from 0 to budget hours over total days
              expectedData.push((project.budgetHours / totalDays) * (i + 1));
            }
            // Build canvas
            const projectCard = document.createElement('div');
            projectCard.style.marginBottom = '1rem';
            const h4 = document.createElement('h4');
            h4.style.margin = '0 0 0.5rem 0';
            h4.style.fontSize = '1rem';
            h4.style.fontWeight = '600';
            h4.textContent = project.name;
            projectCard.appendChild(h4);
            const canvas = document.createElement('canvas');
            canvas.height = 150;
            projectCard.appendChild(canvas);
            burndownContainer.appendChild(projectCard);
            // Create Chart.js line chart
            const ctx = canvas.getContext('2d');
            burndownCharts[project.id] = new Chart(ctx, {
              type: 'line',
              data: {
                labels: labels,
                datasets: [
                  {
                    label: 'Cumulative Hours',
                    data: actualData,
                    borderColor: project.color || '#3b82f6',
                    backgroundColor: 'rgba(59,130,246,0.3)',
                    fill: false,
                    tension: 0.1
                  },
                  {
                    label: 'Expected Hours',
                    data: expectedData,
                    borderColor: '#999999',
                    backgroundColor: 'rgba(153,153,153,0.3)',
                    fill: false,
                    borderDash: [5,5],
                    tension: 0.1
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: {
                    title: { display: true, text: 'Date' },
                    ticks: { maxRotation: 90, minRotation: 45 }
                  },
                  y: {
                    title: { display: true, text: 'Hours' },
                    beginAtZero: true
                  }
                },
                plugins: {
                  legend: { display: true },
                  tooltip: { enabled: true }
                }
              }
            });
          });

          // ---------- Build Hours by Project bar chart ----------
          const hoursCanvas = document.getElementById('hoursByProjectChart');
          if (hoursCanvas) {
            // Destroy existing chart if present
            if (window.hoursByProjectChart) {
              try { window.hoursByProjectChart.destroy(); } catch (err) {}
            }
            const labels = [];
            const workedData = [];
            const targetData = [];
            data.projects.forEach(project => {
              const sp = computeProjectStats(project);
              labels.push(project.name);
              // Hours worked this month
              workedData.push(sp.monthlyHours || 0);
              // Dynamic monthly target
              targetData.push(sp.monthlyTargetConst || 0);
            });
            const ctxHours = hoursCanvas.getContext('2d');
            window.hoursByProjectChart = new Chart(ctxHours, {
              type: 'bar',
              data: {
                labels: labels,
                datasets: [
                  {
                    label: 'Hours Worked',
                    data: workedData,
                    backgroundColor: 'rgba(59,130,246,0.6)',
                    borderColor: '#3b82f6',
                    borderWidth: 1
                  },
                  {
                    label: 'Target Hours',
                    data: targetData,
                    backgroundColor: 'rgba(203,213,224,0.6)',
                    borderColor: '#94a3b8',
                    borderWidth: 1
                  }
                ]
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: { title: { display: true, text: 'Project' } },
                  y: { title: { display: true, text: 'Hours' }, beginAtZero: true }
                },
                plugins: {
                  legend: { display: true },
                  tooltip: { enabled: true }
                }
              }
            });
          }
        }

        // Download the current data to a JSON file. Uses the same filename
        // each time so the browser can overwrite older backups.
        function downloadData() {
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'timekeeper-offline-data.json';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        // Save the current data to the user-selected backup directory. If no directory
        // has been chosen yet, this function silently does nothing. When called,
        // it writes the entire data object to a file named `timekeeper-data.json` in
        // the chosen folder using the File System Access API.
        async function saveBackupToDir() {
          try {
            if (!backupDirHandle) {
              backupPermissionState = 'missing';
              disableAutoSyncWithWarning('Auto sync paused: select a backup folder to resume syncing.');
              return;
            }
            const permissionState = await getBackupPermissionState(backupDirHandle);
            backupPermissionState = permissionState;
            if (permissionState !== 'granted') {
              const message = permissionState === 'prompt'
                ? 'Auto sync paused: confirm access to your backup folder to resume syncing.'
                : 'Auto sync disabled: permission to the backup folder was revoked.';
              disableAutoSyncWithWarning(message);
              return;
            }
            const fileHandle = await backupDirHandle.getFileHandle('timekeeper-data.json', { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(JSON.stringify(data, null, 2));
            await writable.close();
            data.lastBackupAt = new Date().toISOString();
            localStorage.setItem('timekeeperDataPro', JSON.stringify(data));
            needsBackup = false;
            backupWarningMessage = '';
            updateAutoSyncStatus();
          } catch (err) {
            console.error('Saving backup failed:', err);
            backupWarningMessage = 'Auto backup failed. Check the backup folder and try again.';
            updateAutoSyncStatus();
          }
        }

        // Prompt the user to choose a backup directory using the File System Access API. When
        // the directory is selected, set it as the backupDirHandle and enable auto sync.
        async function chooseBackupDir(options = {}) {
          const { activateSync = false } = options;
          if (!window.showDirectoryPicker) {
            backupWarningMessage = 'Auto sync unavailable: your browser does not support choosing folders.';
            updateAutoSyncStatus();
            return false;
          }
          try {
            const dirHandle = await window.showDirectoryPicker();
            const permissionGranted = await ensureBackupPermissionWithPrompt(dirHandle);
            if (!permissionGranted) {
              backupWarningMessage = 'Permission to access the selected backup folder was not granted. Auto sync unchanged.';
              updateAutoSyncStatus();
              return false;
            }
            backupDirHandle = dirHandle;
            backupPermissionState = 'granted';
            await saveBackupDirHandle(dirHandle);
            data.backupDirName = dirHandle.name || null;
            saveData();
            if (activateSync) {
              autoSyncEnabled = true;
              localStorage.setItem('autoSyncEnabledPro', 'true');
              const toggle = document.getElementById('autoSyncToggle');
              if (toggle) toggle.checked = true;
            }
            backupWarningMessage = '';
            updateAutoSyncStatus();
            if (autoSyncEnabled || activateSync) {
              await saveBackupToDir();
            }
            return true;
          } catch (err) {
            console.error('Backup folder not selected:', err);
            backupWarningMessage = 'Backup folder not selected. Auto sync unchanged.';
            updateAutoSyncStatus();
            return false;
          }
        }

        // Periodically export data if there have been changes.
        // Runs every 10 minutes (600000 ms). Adjust interval as needed.
        setInterval(() => {
          // Only perform automatic backups when auto sync is enabled. When a backup directory
          // is selected, data will be written to the file; otherwise, nothing happens.
          if (autoSyncEnabled && needsBackup) {
            saveBackupToDir().catch(err => {
              console.error('Auto backup failed:', err);
            });
          }
        }, 600000);

        // Navigation
        const navList = document.getElementById('navList');
        navList.querySelectorAll('li').forEach(li => {
          li.addEventListener('click', () => {
            navList.querySelectorAll('li').forEach(item => item.classList.remove('active'));
            li.classList.add('active');
            const sectionId = li.getAttribute('data-section');
            document.querySelectorAll('.section').forEach(sec => {
              sec.style.display = 'none';
            });
            document.getElementById(sectionId).style.display = 'block';
            // update content if needed
            if (sectionId === 'dashboard') {
              updateDashboard();
            } else if (sectionId === 'projects') {
              updateProjectsPage();
            } else if (sectionId === 'entries') {
              updateEntriesTable();
            } else if (sectionId === 'timer') {
              updateTimerSection();
            } else if (sectionId === 'todo') {
              updateTodoSection();
            } else if (sectionId === 'grocery') {
              updateGrocerySection();
            } else if (sectionId === 'analytics') {
              updateAnalyticsSection();
            }
          });
        });

        // Helper functions for formatting
        function formatDateTime(dateStr) {
          const dt = new Date(dateStr);
          return isNaN(dt) ? '' : dt.toLocaleString();
        }
        function formatDate(dateStr) {
          const dt = new Date(dateStr);
          return isNaN(dt) ? '' : dt.toLocaleDateString();
        }

        function parseLocalDateString(value) {
          if (typeof value !== 'string') return null;
          const trimmed = value.trim();
          if (!trimmed) return null;
          // Support the persisted formats "YYYY-MM-DD" and ISO timestamps such as
          // "YYYY-MM-DDTHH:mm:ss.sssZ" by matching the leading date portion. This
          // keeps existing saves (which previously stored ISO strings) from being
          // treated as missing and inadvertently resetting the budget start date.
          const match = trimmed.match(/^(\d{4})-(\d{1,2})-(\d{1,2})/);
          if (match) {
            const year = Number(match[1]);
            const month = Number(match[2]);
            const day = Number(match[3]);
            const date = new Date(year, month - 1, day);
            if (date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day) {
              date.setHours(0, 0, 0, 0);
              return date;
            }
          }
          // Fall back to Date parsing for any other legacy formats, normalizing
          // the result to the local calendar day when valid.
          const fallback = new Date(trimmed);
          if (!isNaN(fallback)) {
            const date = new Date(fallback.getFullYear(), fallback.getMonth(), fallback.getDate());
            date.setHours(0, 0, 0, 0);
            return date;
          }
          return null;
        }

        function formatLocalDateString(date) {
          if (!(date instanceof Date) || isNaN(date)) return '';
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        }

        function clampUnitInterval(value) {
          if (!Number.isFinite(value)) return 0;
          return Math.min(1, Math.max(0, value));
        }
        function formatCurrency(num, decimals = 1) {
          // Format currency as Swedish Krona (kr). Allows rounding to positive or
          // negative decimal places. A negative decimal value rounds to tens,
          // hundreds, etc. For example, decimals = -1 rounds to the nearest 10,
          // decimals = -2 rounds to the nearest 100. When decimals >= 0, round
          // normally and include that many decimal places. When decimals < 0,
          // round to the specified magnitude and show no decimals. If num is
          // not finite, return an empty string.
          if (!isFinite(num)) return '';
          let rounded;
          if (decimals >= 0) {
            // Round to specified fractional places
            const factor = Math.pow(10, decimals);
            rounded = Math.round(num * factor) / factor;
            return rounded.toFixed(decimals) + ' kr';
          } else {
            // Round to tens, hundreds, etc.
            const factor = Math.pow(10, -decimals);
            rounded = Math.round(num / factor) * factor;
            return Math.round(rounded).toString() + ' kr';
          }
        }
        function formatRelativeTime(isoString) {
          if (!isoString) return '';
          const date = new Date(isoString);
          if (isNaN(date)) return '';
          const diffMs = Date.now() - date.getTime();
          if (diffMs < 0) return date.toLocaleString();
          const minutes = Math.floor(diffMs / 60000);
          if (minutes < 1) return 'just now';
          if (minutes < 60) return minutes + ' min' + (minutes === 1 ? '' : 's') + ' ago';
          const hours = Math.floor(minutes / 60);
          if (hours < 24) return hours + ' hour' + (hours === 1 ? '' : 's') + ' ago';
          const days = Math.floor(hours / 24);
          if (days < 30) return days + ' day' + (days === 1 ? '' : 's') + ' ago';
          const months = Math.floor(days / 30);
          if (months < 12) return months + ' month' + (months === 1 ? '' : 's') + ' ago';
          const years = Math.floor(months / 12);
          return years + ' year' + (years === 1 ? '' : 's') + ' ago';
        }
        function formatDuration(seconds) {
          const hrs = Math.floor(seconds / 3600);
          const mins = Math.floor((seconds % 3600) / 60);
          const secs = Math.floor(seconds % 60);
          const parts = [];
          if (hrs > 0) parts.push(hrs + 'h');
          if (mins > 0 || hrs > 0) parts.push(mins + 'm');
          parts.push(secs + 's');
          return parts.join(' ');
        }

        // Helper function: Count the number of working days (Mon-Fri) between two dates.
        // The start date is inclusive and the end date is exclusive. If start >= end, returns 0.
        function countWorkdays(startDate, endDate) {
          const start = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
          const end = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
          if (end <= start) return 0;
          let count = 0;
          let current = new Date(start);
          while (current < end) {
            const day = current.getDay();
            // 1-5 are Monday to Friday (0=Sunday, 6=Saturday)
            if (day >= 1 && day <= 5) count++;
            current.setDate(current.getDate() + 1);
          }
          return count;
        }

        // Compute statistics per project
        function computeProjectStats(project) {
          const now = new Date();
          const entries = data.entries.filter(e => e.projectId === project.id && !e.isRunning);
          const totalSeconds = entries.reduce((sum, e) => sum + (e.duration || 0), 0);
          const totalHours = totalSeconds / 3600;
          const remainingHours = project.budgetHours - totalHours;
          const created = new Date(project.createdAt);
          const deadline = new Date(project.deadline);
          const daysPassed = Math.max(1, Math.round((now - created) / (1000 * 60 * 60 * 24)));
          const daysLeft = Math.max(0, Math.round((deadline - now) / (1000 * 60 * 60 * 24)));
          const avgDailyBurn = totalHours / daysPassed;
          const daysToExhaust = avgDailyBurn > 0 ? remainingHours / avgDailyBurn : Infinity;
          // Determine a more descriptive status for the project based on budget consumption and schedule
          // Calculate expected used hours based on how far through the project we are
          const totalProjectDays = daysPassed + daysLeft;
          const expectedUsed = totalProjectDays > 0 ? project.budgetHours * (daysPassed / totalProjectDays) : totalHours;
          const totalExpectedToDate = expectedUsed;
          const totalScheduleDeficit = totalExpectedToDate - totalHours;
          let status = 'on-track';
          let statusColor = 'green';
          let reason = '';
          // If total hours already exceed expected usage at this point in the schedule, mark as over budget
          if (totalHours > expectedUsed) {
            status = 'over-budget';
            statusColor = 'red';
            reason = 'Projected to exceed budget before deadline.';
          // If days to exhaust at current burn rate is less than days left, the project will finish late (behind schedule)
          } else if (daysToExhaust < daysLeft) {
            status = 'behind-schedule';
            statusColor = 'red';
            reason = 'Not enough days left at current pace.';
          // If days to exhaust and days left are very close (within three days), label as tight schedule
          } else if (Math.abs(daysToExhaust - daysLeft) <= 3) {
            status = 'tight';
            statusColor = 'amber';
            reason = 'On track but very little margin.';
          } else {
            status = 'on-track';
            statusColor = 'green';
            reason = 'On track.';
          }
          // Weekly and monthly expected hours
          let weeklyExpected = 0;
          let monthlyExpected = 0;
          // Calculate expected (target) hours to date for this week and this month.
          // We base the daily budget on the total calendar days between project creation and deadline.
          // This yields a more realistic expected-to-date value than strictly using working days, which can
          // produce very small denominators when projects span long periods.
          const totalDays = Math.ceil((deadline - created) / (1000 * 60 * 60 * 24)) || 1;
          const dailyBudget = project.budgetHours / totalDays;
          // Determine the start of the current week (Monday) and the start of the current month
          const startOfWeek = new Date(now);
          const dow = startOfWeek.getDay();
          const diffToMonday = (dow + 6) % 7;
          startOfWeek.setDate(startOfWeek.getDate() - diffToMonday);
          const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
          // Compute calendar day counts relative to project creation date
          const daysTillNow = Math.max(0, (now - created) / (1000 * 60 * 60 * 24));
          const daysTillStartOfWeekCal = Math.max(0, (startOfWeek - created) / (1000 * 60 * 60 * 24));
          const daysTillStartOfMonthCal = Math.max(0, (startOfMonth - created) / (1000 * 60 * 60 * 24));
          // Include fractional day for weekly expected by using floating point difference (time-of-day) rather than rounded days.
          weeklyExpected = Math.max(0, dailyBudget * (daysTillNow - daysTillStartOfWeekCal));
          monthlyExpected = Math.max(0, dailyBudget * (daysTillNow - daysTillStartOfMonthCal));
          // Clamp expected values so they do not exceed the project's total budget hours
          if (weeklyExpected > project.budgetHours) weeklyExpected = project.budgetHours;
          if (monthlyExpected > project.budgetHours) monthlyExpected = project.budgetHours;
          // Weekly and last week hours
          // Determine the start of the current week (Monday 00:00). We calculate how many
          // days have passed since Monday and subtract that from today's date. This ensures
          // weekly statistics reset at the beginning of each week.
          const dayOfWeek = now.getDay();
          const diffToMondayWeek = (dayOfWeek + 6) % 7;
          const weekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - diffToMondayWeek);
          weekStart.setHours(0, 0, 0, 0);
          // Last week spans the 7 days prior to weekStart
          const lastWeekStart = new Date(weekStart);
          lastWeekStart.setDate(weekStart.getDate() - 7);
          const lastWeekEnd = new Date(weekStart);
          const weeklySeconds = entries
            .filter(e => new Date(e.startTime) >= weekStart)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const weeklyHours = weeklySeconds / 3600;
          const lastWeekSeconds = entries
            .filter(e => new Date(e.startTime) >= lastWeekStart && new Date(e.startTime) < lastWeekEnd)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const lastWeekHours = lastWeekSeconds / 3600;
          // Monthly hours and last month hours
          const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
          const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
          const monthlySeconds = entries.filter(e => new Date(e.startTime) >= monthStart)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const monthlyHours = monthlySeconds / 3600;
          const lastMonthSeconds = entries.filter(e => new Date(e.startTime) >= lastMonthStart && new Date(e.startTime) < lastMonthEnd)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const lastMonthHours = lastMonthSeconds / 3600;
          // Revenue
          const revenue = totalHours * project.hourlyRate;
          const weeklyRevenue = weeklyHours * project.hourlyRate;
          const lastWeekRevenue = lastWeekHours * project.hourlyRate;
          const monthlyRevenue = monthlyHours * project.hourlyRate;
          const lastMonthRevenue = lastMonthHours * project.hourlyRate;
          // Calculate dynamic weekly and monthly targets for this project. The dynamic targets
          // spread the remaining hours evenly across the remaining time. For the weekly target,
          // we divide the remaining hours by the number of calendar weeks left (rounded up).
          // For the monthly target, we divide the remaining hours by the number of calendar
          // months left. If there are no remaining days (past deadline), we treat the count as
          // at least one to avoid division by zero.
          const remaining = Math.max(0, remainingHours);
          // Compute the number of calendar weeks remaining until the project deadline. Previously this was
          // used to spread remaining hours evenly, but to align the weekly target with the monthly plan we
          // instead derive it from the monthly deficit and the number of working weeks left in the current
          // calendar month. We still keep the generic weeksLeft calculation for reference.
          const weeksLeft = Math.max(1, Math.ceil(daysLeft / 7));
          // Determine total months between project creation and deadline (inclusive) for constant monthly targets
          const startMonthIndex = created.getFullYear() * 12 + created.getMonth();
          const deadlineMonthIndex = deadline.getFullYear() * 12 + deadline.getMonth();
          const totalMonths = Math.max(1, (deadlineMonthIndex - startMonthIndex + 1));
          const monthTargetOriginal = project.budgetHours / totalMonths;
          // Determine number of full months before the current month (elapsed months) for carry‑over calculations
          const currentMonthIndex = now.getFullYear() * 12 + now.getMonth();
          const monthsElapsed = Math.max(0, currentMonthIndex - startMonthIndex);
          // Compute expected hours for all months prior to the current month
          const expectedBefore = monthTargetOriginal * monthsElapsed;
          // Compute actual hours for months prior to the current month
          const firstDayOfThisMonth = new Date(now.getFullYear(), now.getMonth(), 1);
          const secondsBeforeThisMonth = entries
            .filter(e => new Date(e.startTime) < firstDayOfThisMonth)
            .reduce((sum, e) => sum + (e.duration || 0), 0);
          const actualBefore = secondsBeforeThisMonth / 3600;
          // Adjust the monthly target for the current month based on surplus or deficit from previous months
          let monthlyTargetConst = monthTargetOriginal + (expectedBefore - actualBefore);
          // If the adjusted monthly target is negative, clamp to zero. This may occur if past months consumed
          // more than expected and the deficit eats into the current month.
          if (monthlyTargetConst < 0) monthlyTargetConst = 0;
          // Compute months left from current date to deadline. This is used for carry‑over logic but
          // not directly for weekly target calculations.
          const monthsLeft = Math.max(1, deadlineMonthIndex - currentMonthIndex + 1);
          // Determine how many working days remain in the current month (from now until the first of next month)
          const startNextMonthWork = new Date(now.getFullYear(), now.getMonth() + 1, 1);
          const workDaysLeftInMonth = countWorkdays(now, startNextMonthWork);
          // Convert remaining working days into remaining working weeks (5 working days per week). At least 1.
          const workingWeeksLeftInMonth = Math.max(1, Math.ceil(workDaysLeftInMonth / 5));
          // Compute remaining monthly hours (deficit or surplus). This is the hours still needed to meet the
          // adjusted monthly target. If negative, treat as zero (no deficit). This is used to set the weekly
          // target so that the remaining monthly hours are spread evenly over the remaining working weeks.
          const monthlyRemaining = Math.max(0, monthlyTargetConst - monthlyHours);
          // Derive the weekly target from the monthly remaining hours divided by the working weeks left. If
          // there is no monthly target (0), the weekly target will also be 0.
          const weeklyTargetConst = workingWeeksLeftInMonth > 0 ? monthlyRemaining / workingWeeksLeftInMonth : 0;
          return {
            totalHours,
            totalExpectedToDate,
            totalScheduleDeficit,
            remainingHours,
            usedPct: project.budgetHours > 0 ? (totalHours / project.budgetHours) * 100 : 0,
            daysLeft,
            daysPassed,
            status,
            statusColor,
            reason,
            weeklyExpected,
            monthlyExpected,
            weeklyHours,
            lastWeekHours,
            monthlyHours,
            lastMonthHours,
            revenue,
            weeklyRevenue,
            lastWeekRevenue,
            monthlyRevenue,
            lastMonthRevenue,
            weeklyTargetConst,
            monthlyTargetConst
          };
        }

        // Compute global statistics
        function computeGlobalStats() {
          const now = new Date();
          const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          const yesterdayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
          // Start of this week (Monday 00:00) – the weekly period resets on Mondays. We calculate
          // the date of Monday in the current week and use it to accumulate weekly hours
          // and revenue. If today is Monday, weekStart will be today; if today is Tuesday,
          // weekStart will be yesterday, and so on.
          const day = now.getDay();
          const diffToMonday = (day + 6) % 7;
          const weekStart = new Date(now.getFullYear(), now.getMonth(), now.getDate() - diffToMonday);
          weekStart.setHours(0, 0, 0, 0);
          // Define last week's date range for revenue calculation (the week before the current week).
          // We subtract 7 days from weekStart to get the start of the previous week and use weekStart
          // itself as the end of last week.
          const lastWeekStart = new Date(weekStart);
          lastWeekStart.setDate(weekStart.getDate() - 7);
          const lastWeekEnd = new Date(weekStart);
          const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
          const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
          const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
          let todaySeconds = 0;
          let yesterdaySeconds = 0;
          let weekSeconds = 0;
          // Track weekly seconds accrued before today so the daily target can be
          // calculated based on the week's remaining hours at the start of the day.
          let weekSecondsStartOfDay = 0;
          let monthSeconds = 0;
          let lastMonthSeconds = 0;
          let totalRevenue = 0;
          let monthlyRevenue = 0;
          let lastMonthRevenue = 0;
          // Revenue totals for today and this week (across all projects)
          let todayRevenue = 0;
          let yesterdayRevenue = 0;
          let weekRevenue = 0;
          let lastWeekRevenue = 0;
          // Dynamic weekly and monthly targets for all projects. We recalculate each project's
          // weekly and monthly targets based on remaining hours and remaining time until
          // deadline. The sum of these per‑project targets represents the number of hours
          // you should aim to work this week and this month across all projects.
          let weeklyTarget = 0;
          let monthTarget = 0;
          // We'll compute dailyTarget based on remaining monthly hours later
          let dailyTarget = 0;
          data.projects.forEach(project => {
            const sp = computeProjectStats(project);
            weeklyTarget += sp.weeklyTargetConst || 0;
            monthTarget += sp.monthlyTargetConst || 0;
          });
          // Daily target will be computed later once monthHours is known.
          data.entries.forEach(entry => {
            if (entry.isRunning || !entry.duration) return;
            const start = new Date(entry.startTime);
            const project = data.projects.find(p => p.id === entry.projectId);
            const hours = entry.duration / 3600;
            if (!project) return;
            if (start >= todayStart) {
              todaySeconds += entry.duration;
              todayRevenue += hours * project.hourlyRate;
            }
            if (start >= yesterdayStart && start < todayStart) {
              yesterdaySeconds += entry.duration;
              yesterdayRevenue += hours * project.hourlyRate;
            }
            if (start >= weekStart) {
              weekSeconds += entry.duration;
              weekRevenue += hours * project.hourlyRate;
              // Count weekly seconds before today separately for computing the daily target.
              if (start < todayStart) {
                weekSecondsStartOfDay += entry.duration;
              }
            }
            if (start >= monthStart) {
              monthSeconds += entry.duration;
              monthlyRevenue += hours * project.hourlyRate;
            } else if (start >= lastMonthStart && start < lastMonthEnd) {
              lastMonthSeconds += entry.duration;
              lastMonthRevenue += hours * project.hourlyRate;
            }
            totalRevenue += hours * project.hourlyRate;
            // Accumulate revenue for last week (previous 7 days before the current week)
            if (start >= lastWeekStart && start < lastWeekEnd) {
              lastWeekRevenue += hours * project.hourlyRate;
            }
          });
          const todayHours = todaySeconds / 3600;
          const yesterdayHours = yesterdaySeconds / 3600;
          const weekHours = weekSeconds / 3600;
          const monthHours = monthSeconds / 3600;
          const lastMonthHours = lastMonthSeconds / 3600;
          const weeklyProgress = weeklyTarget > 0 ? (weekHours / weeklyTarget) * 100 : 0;
          const revenueChange = lastMonthRevenue > 0 ? ((monthlyRevenue - lastMonthRevenue) / lastMonthRevenue) * 100 : null;
          const todayChange = yesterdayHours > 0 ? ((todayHours - yesterdayHours) / yesterdayHours) * 100 : null;
          const activeProjects = data.projects.length;
          const dueThisWeek = data.projects.filter(p => {
            const d = new Date(p.deadline);
            const diffDays = Math.round((d - now) / (1000 * 60 * 60 * 24));
            return diffDays >= 0 && diffDays <= 7;
          }).length;
          const monthProgress = monthTarget > 0 ? (monthHours / monthTarget) * 100 : 0;
          // Weekly revenue change relative to last week. lastWeekRevenue was
          // accumulated in the main entry loop above using the lastWeekStart
          // and lastWeekEnd constants defined earlier in this function.
          const weekRevenueChange = lastWeekRevenue > 0 ? ((weekRevenue - lastWeekRevenue) / lastWeekRevenue) * 100 : null;
          const todayRevenueChange = yesterdayRevenue > 0 ? ((todayRevenue - yesterdayRevenue) / yesterdayRevenue) * 100 : null;

          // --- Daily Target Calculation ---
          // We want the daily target to remain constant throughout a given day. To accomplish this,
          // we base it on the weekly target and hours remaining at the *start* of the day. The weekly
          // target itself changes as you work, since monthly remaining hours shrink. If we used the
          // current weekly target, the daily target would shrink during the day as you record more
          // hours, which is confusing. Instead, we compute a weekly target snapshot for the start
          // of the day using monthly remaining hours at the start of the day.
          const weekHoursStartOfDay = weekSecondsStartOfDay / 3600;
          // First accumulate monthly hours before today per project so we can derive each project's
          // monthly remaining hours at the start of the day. We'll reuse monthStart and todayStart
          // defined earlier. We'll build a lookup table keyed by projectId.
          const monthlySecondsStartOfDayByProj = {};
          data.entries.forEach(entry => {
            if (entry.isRunning || !entry.duration) return;
            const st = new Date(entry.startTime);
            if (st >= monthStart && st < todayStart) {
              monthlySecondsStartOfDayByProj[entry.projectId] = (monthlySecondsStartOfDayByProj[entry.projectId] || 0) + entry.duration;
            }
          });
          // Determine working days left in the current month and convert to working weeks (5 days per week). We
          // reuse the logic from computeProjectStats for consistency. We'll compute this once and use for all projects.
          const startNextMonthWork = new Date(now.getFullYear(), now.getMonth() + 1, 1);
          const workDaysLeftInMonthAll = countWorkdays(now, startNextMonthWork);
          const workingWeeksLeftInMonthAll = Math.max(1, Math.ceil(workDaysLeftInMonthAll / 5));
          // Compute a weekly target snapshot for the start of the day by summing per‑project
          // weekly targets calculated from monthly remaining hours *at the start of the day*.
          let weeklyTargetStartOfDay = 0;
          data.projects.forEach(project => {
            // Use computeProjectStats to get monthlyTargetConst which is independent of hours worked in this month.
            const sp = computeProjectStats(project);
            // Compute monthly hours for this project up to the start of today.
            const monthlyHoursSoFar = (monthlySecondsStartOfDayByProj[project.id] || 0) / 3600;
            // Monthly remaining hours at start of day
            const monthlyRemainingSoFar = Math.max(0, sp.monthlyTargetConst - monthlyHoursSoFar);
            // Derive the per‑project weekly target for the start of the day. Distribute remaining monthly hours
            // across the working weeks left in the current month.
            const wkTargetStart = workingWeeksLeftInMonthAll > 0 ? monthlyRemainingSoFar / workingWeeksLeftInMonthAll : 0;
            weeklyTargetStartOfDay += wkTargetStart;
          });
          // The weekly remaining hours at the start of the day is the difference between this snapshot
          // weekly target and the hours already worked this week before today.
          const weeklyRemainingStart = weeklyTargetStartOfDay - weekHoursStartOfDay;
          // Determine the start of next week (Monday at 00:00) by adding 7 days to the current weekStart.
          const startNextWeekDT = new Date(weekStart.getTime() + 7 * 24 * 60 * 60 * 1000);
          // Count working days remaining in this week (including today) by using todayStart. Using
          // todayStart ensures that partial days are counted as a full day for the target distribution.
          const workDaysLeftInWeekDT = countWorkdays(todayStart, startNextWeekDT);
          let computedDailyTarget = 0;
          if (weeklyRemainingStart > 0 && workDaysLeftInWeekDT > 0) {
            computedDailyTarget = weeklyRemainingStart / workDaysLeftInWeekDT;
          }
          dailyTarget = computedDailyTarget;
          return {
            todayHours,
            yesterdayHours,
            weekHours,
            weekTarget: weeklyTarget,
            weeklyProgress,
            monthHours,
            monthTarget,
            monthProgress,
            monthRevenue: monthlyRevenue,
            lastMonthRevenue,
            revenueChange,
            todayChange,
            // revenue today and this week
            todayRevenue,
            weekRevenue,
            todayRevenueChange,
            weekRevenueChange,
            activeProjects,
            dueThisWeek,
            totalRevenue,
            dailyTarget
          };
        }

        // Dashboard rendering
        function updateDashboard() {
          const stats = computeGlobalStats();
          // Precompute per-project stats once for use in cards and recommendations. This avoids
          // recalculating computeProjectStats multiple times during rendering.
          const perProjectStats = data.projects.map(p => {
            return { project: p, stats: computeProjectStats(p) };
          });
          // Determine the recommended project based on overall schedule deficit. Projects with the
          // largest positive deficit are most behind schedule; if all deficits are negative, choose
          // the project that is least ahead of schedule (closest to zero).
          let recommendedProjectEntry = null;
          let maxTotalDeficit = -Infinity;
          perProjectStats.forEach(item => {
            const deficitValue = Number.isFinite(item.stats.totalScheduleDeficit)
              ? item.stats.totalScheduleDeficit
              : 0;
            if (deficitValue > maxTotalDeficit) {
              maxTotalDeficit = deficitValue;
              recommendedProjectEntry = item;
            }
          });
          // Update global identifiers so other sections know which project is recommended
          currentRecommendedWeeklyId = recommendedProjectEntry ? recommendedProjectEntry.project.id : null;
          currentRecommendedMonthlyId = recommendedProjectEntry ? recommendedProjectEntry.project.id : null;
          // Calculate time progress for the current week and month. Instead of using only
          // whole working days, include the fraction of the day that has elapsed. For
          // weekly progress, Monday 00:00 marks the start and Friday 23:59 marks the
          // end (5 days). For monthly progress, the first day of the month marks
          // the start and the first day of the following month marks the end.
          const nowTime = new Date();
          // Define the start of today so we can compute today's hours for each project when building
          // the per‑project breakdown lists. We'll reuse todayStart in the card rendering below.
          const todayStart = new Date(nowTime.getFullYear(), nowTime.getMonth(), nowTime.getDate());
          // Weekly time progress: compute fraction of the 5-day work week that has elapsed.
          // Precompute start of week (Monday 00:00) outside the branch so it can be reused later.
          const dayOfWeek = nowTime.getDay();
          const diffToMonday = (dayOfWeek + 6) % 7;
          const startWeek = new Date(nowTime);
          startWeek.setDate(startWeek.getDate() - diffToMonday);
          startWeek.setHours(0, 0, 0, 0);
          let weeklyTimeProgress;
          if (dayOfWeek === 0 || dayOfWeek === 6) {
            weeklyTimeProgress = 100;
          } else {
            // Compute elapsed time since start of work week and scale over 5 working days
            const diffMs = nowTime - startWeek;
            const totalMs = 5 * 24 * 60 * 60 * 1000;
            weeklyTimeProgress = Math.min((diffMs / totalMs) * 100, 100);
          }
          // Monthly time progress: compute fraction of working days elapsed in the current month. We count
          // only Monday–Friday as working days. Use countWorkdays() to determine the total number of
          // working days in the month and how many have elapsed so far. Weekends contribute nothing.
          const startMonth = new Date(nowTime.getFullYear(), nowTime.getMonth(), 1);
          const startNextMonth = new Date(nowTime.getFullYear(), nowTime.getMonth() + 1, 1);
          const workDaysTotalMonth = countWorkdays(startMonth, startNextMonth);
          const workDaysElapsedMonth = countWorkdays(startMonth, nowTime);
          let monthlyTimeProgress = workDaysTotalMonth > 0 ? (workDaysElapsedMonth / workDaysTotalMonth) * 100 : 0;

          // For daily target and per‑project recommendations, we want a snapshot of
          // monthly remaining hours at the start of the day. We'll build a lookup
          // table of monthly seconds per project up to the start of today. This
          // replicates logic in computeGlobalStats for daily target but per project.
          const monthlySecondsStartOfDayByProj = {};
          data.entries.forEach(entry => {
            if (entry.isRunning || !entry.duration) return;
            const st = new Date(entry.startTime);
            // Only include entries that started before today and are within the current month
            if (st >= startMonth && st < todayStart) {
              monthlySecondsStartOfDayByProj[entry.projectId] = (monthlySecondsStartOfDayByProj[entry.projectId] || 0) + entry.duration;
            }
          });
          // Determine the number of working weeks left in the current month. We reuse the
          // same calculation as computeProjectStats: count working days from now to the
          // first day of next month, then convert to weeks of 5 working days each.
          const workDaysLeftInMonthForAll = countWorkdays(nowTime, startNextMonth);
          const workingWeeksLeftInMonthForAll = Math.max(1, Math.ceil(workDaysLeftInMonthForAll / 5));
          if (monthlyTimeProgress > 100) monthlyTimeProgress = 100;
          // Precompute how many working days remain in the current month and current week. The value
          // for the month is used for monthly recommendations elsewhere; the weekly value is used
          // for calculating the recommended daily hours per project. If the result is zero, all
          // remaining work is effectively overdue.
          const workDaysLeftInMonth = countWorkdays(nowTime, startNextMonth);
          // Start of next week (Monday at 00:00) for computing remaining workdays this week
          const startNextWeek = new Date(startWeek.getTime() + 7 * 24 * 60 * 60 * 1000);
          const workDaysLeftInWeek = countWorkdays(nowTime, startNextWeek);

          // Determine schedule status for weekly and monthly progress by comparing hours progress
          // to time progress. If the hours progress (worked/target) exceeds time progress, the user is ahead.
          const weekHoursProgress = stats.weekTarget > 0 ? (stats.weekHours / stats.weekTarget) * 100 : 0;
          const monthHoursProgress = stats.monthTarget > 0 ? (stats.monthHours / stats.monthTarget) * 100 : 0;
          const weekScheduleDiff = weekHoursProgress - weeklyTimeProgress;
          const monthScheduleDiff = monthHoursProgress - monthlyTimeProgress;
          const weekScheduleLabel = weekScheduleDiff > 5 ? 'Ahead of schedule' : (weekScheduleDiff < -5 ? 'Behind schedule' : 'On schedule');
          const monthScheduleLabel = monthScheduleDiff > 5 ? 'Ahead of schedule' : (monthScheduleDiff < -5 ? 'Behind schedule' : 'On schedule');

          // Stats cards data; integrate recommendations and revenue into relevant cards. Cards with
          // progress also include timeProgress and scheduleLabel for additional context.
          // Build the dashboard cards. We merge revenue into the relevant cards rather than
          // using a separate Revenue card. A multi progress bar visualises both how far
          // through the period we are (expected progress) and how much of the target has
          // been worked. The expected progress (timeProgress) will be rendered as a dark
          // overlay and the actual hours progress as the blue overlay. No textual
          // schedule label is displayed; instead the bar visualises whether you are ahead
          // or behind schedule.
          // Build the dashboard cards. Each card includes a value, progress bar(s), and labels.  
          // For the weekly and monthly cards we include both the percentage of target worked and the percentage of the period elapsed.  
          const cards = [
            {
              title: "Today's Hours",
              // Show today's hours against the daily target
              value: stats.todayHours.toFixed(1) + ' / ' + (stats.dailyTarget ? stats.dailyTarget.toFixed(1) : '0') + 'h',
              // Remove change label and comparison to yesterday per user request
              icon: '⏱',
              // Revenue for today shown on this card
              revenue: stats.todayRevenue || 0
            },
            {
              title: 'This Week',
              value: stats.weekHours.toFixed(1) + ' / ' + (stats.weekTarget ? stats.weekTarget.toFixed(1) : '0') + 'h',
              progress: stats.weeklyProgress,
              // Expected progress based on working days in the week
              timeProgress: weeklyTimeProgress,
              icon: '📅',
              // Progress label expresses hours progress relative to target and time progress relative to the week
              progressLabel: (stats.weeklyProgress || 0).toFixed(1) + '% of weekly target in ' + weeklyTimeProgress.toFixed(1) + '% of the week',
              // Schedule label indicates whether the user is ahead, behind, or on schedule this week
              scheduleLabel: weekScheduleLabel,
              // Show revenue earned this week on the same card
              revenue: stats.weekRevenue || 0
            },
            {
              title: 'This Month',
              value: stats.monthHours.toFixed(1) + ' / ' + (stats.monthTarget ? stats.monthTarget.toFixed(1) : '0') + 'h',
              progress: stats.monthProgress,
              // Expected progress based on working days in the month
              timeProgress: monthlyTimeProgress,
              icon: '🗓',
              progressLabel: (stats.monthProgress || 0).toFixed(1) + '% of monthly target in ' + monthlyTimeProgress.toFixed(1) + '% of the month',
              scheduleLabel: monthScheduleLabel,
              // Integrate monthly revenue into this card
              revenue: stats.monthRevenue || 0
            }
          ]; // Active Projects card removed per user request
          const statsGrid = document.getElementById('statsGrid');
          statsGrid.innerHTML = '';
          cards.forEach(card => {
            const div = document.createElement('div');
            div.className = 'stat-card';
            // icon
            const iconDiv = document.createElement('div');
            iconDiv.className = 'stat-icon';
            iconDiv.textContent = card.icon;
            div.appendChild(iconDiv);
            // title
            const titleDiv = document.createElement('div');
            titleDiv.className = 'stat-title';
            titleDiv.textContent = card.title;
            div.appendChild(titleDiv);
            // value
            const valueDiv = document.createElement('div');
            valueDiv.className = 'stat-value';
            valueDiv.textContent = card.value;
            div.appendChild(valueDiv);
            // progress or change
            if (card.progress !== undefined) {
              // Use a multi progress bar if timeProgress is provided, otherwise fallback to a single bar.
              if (card.timeProgress !== undefined) {
                // Create a container for two stacked progress bars: one for expected progress (black) and one for actual hours (blue).
                const barContainer = document.createElement('div');
                barContainer.style.display = 'flex';
                barContainer.style.flexDirection = 'column';
                barContainer.style.gap = '0.2rem';
                // Actual hours worked bar (blue) shown on top
                const hoursBar = document.createElement('div');
                hoursBar.className = 'progress-bar';
                const hoursFill = document.createElement('div');
                hoursFill.className = 'fill';
                hoursFill.style.width = Math.min(100, card.progress).toFixed(1) + '%';
                hoursBar.appendChild(hoursFill);
                barContainer.appendChild(hoursBar);
                // Expected progress bar (black) shown beneath
                const expectedBar = document.createElement('div');
                expectedBar.className = 'progress-bar';
                const expectedFill = document.createElement('div');
                expectedFill.className = 'fill';
                // Override background color to black for expected progress
                expectedFill.style.backgroundColor = '#000000';
                expectedFill.style.width = Math.min(100, card.timeProgress).toFixed(1) + '%';
                expectedBar.appendChild(expectedFill);
                barContainer.appendChild(expectedBar);
                div.appendChild(barContainer);
              } else {
                const progressBar = document.createElement('div');
                progressBar.className = 'progress-bar';
                const fill = document.createElement('div');
                fill.className = 'fill';
                fill.style.width = Math.min(100, card.progress).toFixed(1) + '%';
                progressBar.appendChild(fill);
                div.appendChild(progressBar);
              }
              // Label describing work progress relative to target and time progress
              const pLabel = document.createElement('div');
              pLabel.className = 'stat-change';
              pLabel.textContent = card.progressLabel || '';
              pLabel.style.color = '#475569';
              div.appendChild(pLabel);
              // If the card contains a schedule label (ahead/behind/on), add a second line with colour coding
              if (card.scheduleLabel) {
                const sched = document.createElement('div');
                sched.className = 'stat-change';
                sched.textContent = card.scheduleLabel;
                // Colour code the schedule: green for ahead, red for behind, amber for on schedule
                const text = card.scheduleLabel.toLowerCase();
                if (text.includes('ahead')) sched.style.color = '#15803d';
                else if (text.includes('behind')) sched.style.color = '#b91c1c';
                else sched.style.color = '#92400e';
                div.appendChild(sched);
              }
            } else {
              // Change or change label for cards without progress
              const changeDiv = document.createElement('div');
              changeDiv.className = 'stat-change';
              if (card.change === null || card.change === undefined) {
                changeDiv.textContent = card.changeLabel || '';
                changeDiv.style.color = '#475569';
              } else {
                const change = card.change;
                const prefix = change >= 0 ? '+' : '';
                changeDiv.textContent = prefix + change.toFixed(0) + '% ' + card.changeLabel;
                changeDiv.classList.add(change >= 0 ? 'positive' : 'negative');
              }
              div.appendChild(changeDiv);
            }
            // Append revenue information if provided on the card
            if (card.revenue !== undefined) {
              const revenueDiv = document.createElement('div');
              revenueDiv.className = 'stat-change';
              // Round revenue to the nearest 10 (use decimals = -1) for dashboard display
              revenueDiv.textContent = 'Revenue: ' + formatCurrency(card.revenue, -1);
              revenueDiv.style.color = '#475569';
              div.appendChild(revenueDiv);
            }
            // Append per‑project breakdowns underneath each card. For Today, display today's hours
            // against the recommended daily hours for each project. For Week and Month, display
            // actual versus target hours and colour code based on whether the project is ahead
            // (green) or behind (red) relative to the expected progress so far.
            if (card.title === "Today's Hours" || card.title === 'This Week' || card.title === 'This Month') {
              const list = document.createElement('div');
              list.style.marginTop = '0.5rem';
              perProjectStats.forEach(item => {
                const row = document.createElement('div');
                row.style.fontSize = '0.75rem';
                // Determine today, weekly and monthly metrics
                // Compute today's hours for this project
                let projectTodaySeconds = 0;
                data.entries.forEach(entry => {
                  if (!entry.isRunning && entry.projectId === item.project.id) {
                    const s = new Date(entry.startTime);
                    if (s >= todayStart && s < new Date(todayStart.getTime() + 24 * 60 * 60 * 1000)) {
                      projectTodaySeconds += entry.duration || 0;
                    }
                  }
                });
                const projectTodayHours = projectTodaySeconds / 3600;
                // Calculate recommended daily hours based on remaining weekly target at the start of today
                // and the number of working days left in the week. We compute the hours worked for this
                // project before today and subtract them from the weekly target so the daily target stays
                // constant throughout the day. Clamp negative values to zero.
                let projectWeekSecondsStartOfDay = 0;
                data.entries.forEach(e => {
                  if (!e.isRunning && e.projectId === item.project.id) {
                    const s = new Date(e.startTime);
                    if (s >= startWeek && s < todayStart) {
                      projectWeekSecondsStartOfDay += e.duration || 0;
                    }
                  }
                });
                const projectWeekHoursStart = projectWeekSecondsStartOfDay / 3600;
                // Compute this project's weekly target snapshot at the start of the day. We base this on
                // monthly remaining hours at the start of the day and spread them evenly across the
                // working weeks left in the current month. This ensures the daily recommendation
                // remains constant throughout the day. If monthly remaining is zero or negative,
                // the target becomes zero. If there are no working weeks left, treat as zero.
                const monthlyTargetConst = item.stats.monthlyTargetConst || 0;
                const monthlyHoursSoFar = (monthlySecondsStartOfDayByProj[item.project.id] || 0) / 3600;
                const monthlyRemainingStart = Math.max(0, monthlyTargetConst - monthlyHoursSoFar);
                const weeklyTargetStart = workingWeeksLeftInMonthForAll > 0 ? monthlyRemainingStart / workingWeeksLeftInMonthForAll : 0;
                const remainingWeekly = Math.max(0, weeklyTargetStart - projectWeekHoursStart);
                const projectDailyTarget = workDaysLeftInWeek > 0 ? (remainingWeekly / workDaysLeftInWeek) : 0;
                // For weekly and monthly expected to date, compute expected hours based on time progress
                const expectedWeekSoFar = item.stats.weeklyTargetConst * (weeklyTimeProgress / 100);
                const expectedMonthSoFar = item.stats.monthlyTargetConst * (monthlyTimeProgress / 100);
                if (card.title === "Today's Hours") {
                  // For daily: show hours worked and daily target, colour green if on or ahead, else red
                  row.textContent = `${item.project.name}: ${projectTodayHours.toFixed(1)} / ${projectDailyTarget.toFixed(1)}h`;
                  row.style.color = projectTodayHours >= projectDailyTarget ? '#15803d' : '#b91c1c';
                } else if (card.title === 'This Week') {
                  row.textContent = `${item.project.name}: ${item.stats.weeklyHours.toFixed(1)} / ${item.stats.weeklyTargetConst.toFixed(1)}h`;
                  // Colour code: green if actual hours exceed expected progress so far, red otherwise
                  const onTrack = item.stats.weeklyHours >= expectedWeekSoFar - 0.01; // small tolerance
                  row.style.color = onTrack ? '#15803d' : '#b91c1c';
                } else {
                  // Month
                  row.textContent = `${item.project.name}: ${item.stats.monthlyHours.toFixed(1)} / ${item.stats.monthlyTargetConst.toFixed(1)}h`;
                  const onTrack = item.stats.monthlyHours >= expectedMonthSoFar - 0.01;
                  row.style.color = onTrack ? '#15803d' : '#b91c1c';
                }
                list.appendChild(row);
              });
              div.appendChild(list);
            }
            statsGrid.appendChild(div);
          });
          // Project status overview and detailed breakdown
          renderProjectOverview();
          renderDetailedBreakdown();
          // Render daily hours heatmap and update burndown chart
          renderHeatmap();
          updateBurndownSelect();
          // Previously there was a separate Recommendations card here. It has been removed in favor of integrating suggestions directly into other sections.

          // Prepare data for weekly and monthly scatter charts
          const weeklyDatasets = [];
          const monthlyDatasets = [];
          // Track the maximum expected/actual values to draw an ideal x=y line
          let maxWeeklyVal = 0;
          let maxMonthlyVal = 0;
          data.projects.forEach(project => {
            const statsP = computeProjectStats(project);
            const color = project.color || '#3b82f6';
            weeklyDatasets.push({
              label: project.name,
              data: [{ x: statsP.weeklyExpected, y: statsP.weeklyHours }],
              // Use project color for point appearance
              pointBackgroundColor: color,
              pointBorderColor: color,
              backgroundColor: color,
              borderColor: color,
              pointRadius: 5,
              pointHoverRadius: 7,
              showLine: false
            });
            monthlyDatasets.push({
              label: project.name,
              data: [{ x: statsP.monthlyExpected, y: statsP.monthlyHours }],
              // Use project color for point appearance
              pointBackgroundColor: color,
              pointBorderColor: color,
              backgroundColor: color,
              borderColor: color,
              pointRadius: 5,
              pointHoverRadius: 7,
              showLine: false
            });
            // Update max values for diagonal line
            maxWeeklyVal = Math.max(maxWeeklyVal, statsP.weeklyExpected, statsP.weeklyHours);
            maxMonthlyVal = Math.max(maxMonthlyVal, statsP.monthlyExpected, statsP.monthlyHours);
          });
          // Add diagonal x=y guide line datasets to both charts
          if (weeklyDatasets.length > 0) {
            weeklyDatasets.unshift({
              label: 'Ideal (x=y)',
              data: [
                { x: 0, y: 0 },
                { x: maxWeeklyVal, y: maxWeeklyVal }
              ],
              borderColor: '#94a3b8',
              borderDash: [5, 5],
              showLine: true,
              fill: false,
              pointRadius: 0
            });
          }
          if (monthlyDatasets.length > 0) {
            monthlyDatasets.unshift({
              label: 'Ideal (x=y)',
              data: [
                { x: 0, y: 0 },
                { x: maxMonthlyVal, y: maxMonthlyVal }
              ],
              borderColor: '#94a3b8',
              borderDash: [5, 5],
              showLine: true,
              fill: false,
              pointRadius: 0
            });
          }
          // Weekly scatter chart
          const weeklyCanvas = document.getElementById('weeklyScatter');
          if (weeklyCanvas) {
            if (!weeklyScatterChart) {
              const ctx = weeklyCanvas.getContext('2d');
              weeklyScatterChart = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: weeklyDatasets },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: { display: true, position: 'bottom', labels: { boxWidth: 12 } },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          const label = context.dataset.label || '';
                          const xVal = context.parsed.x;
                          const yVal = context.parsed.y;
                          return label + ': Expected ' + xVal.toFixed(1) + 'h, Actual ' + yVal.toFixed(1) + 'h';
                        }
                      }
                    },
                    title: { display: false }
                  },
                  scales: {
                    x: { title: { display: true, text: 'Expected Hours' }, beginAtZero: true },
                    y: { title: { display: true, text: 'Actual Hours' }, beginAtZero: true }
                  }
                }
              });
            } else {
              weeklyScatterChart.data.datasets = weeklyDatasets;
              weeklyScatterChart.update();
            }
          }
          // Monthly scatter chart
          const monthlyCanvas = document.getElementById('monthlyScatter');
          if (monthlyCanvas) {
            if (!monthlyScatterChart) {
              const ctx2 = monthlyCanvas.getContext('2d');
              monthlyScatterChart = new Chart(ctx2, {
                type: 'scatter',
                data: { datasets: monthlyDatasets },
                options: {
                  responsive: true,
                  maintainAspectRatio: false,
                  plugins: {
                    legend: { display: true, position: 'bottom', labels: { boxWidth: 12 } },
                    tooltip: {
                      callbacks: {
                        label: function(context) {
                          const label = context.dataset.label || '';
                          const xVal = context.parsed.x;
                          const yVal = context.parsed.y;
                          return label + ': Expected ' + xVal.toFixed(1) + 'h, Actual ' + yVal.toFixed(1) + 'h';
                        }
                      }
                    },
                    title: { display: false }
                  },
                  scales: {
                    x: { title: { display: true, text: 'Expected Hours' }, beginAtZero: true },
                    y: { title: { display: true, text: 'Actual Hours' }, beginAtZero: true }
                  }
                }
              });
            } else {
              monthlyScatterChart.data.datasets = monthlyDatasets;
              monthlyScatterChart.update();
            }
          }
        }

        // Render project overview list
        function renderProjectOverview() {
          const container = document.getElementById('projectOverview');
          container.innerHTML = '';
          if (data.projects.length === 0) return;
          const wrapper = document.createElement('div');
          wrapper.className = 'project-list';
          const header = document.createElement('div');
          header.className = 'project-list-header';
          header.textContent = 'Project Status Overview';
          wrapper.appendChild(header);
          data.projects.forEach(project => {
            const stats = computeProjectStats(project);
            const item = document.createElement('div');
            item.className = 'project-item';
            // info section
            const info = document.createElement('div');
            info.className = 'project-info';
            const dot = document.createElement('div');
            dot.className = 'dot';
            dot.style.backgroundColor = project.color || '#3b82f6';
            info.appendChild(dot);
            const nameDiv = document.createElement('div');
            nameDiv.style.fontWeight = '600';
            nameDiv.style.fontSize = '0.9rem';
            nameDiv.textContent = project.name;
            // Add a star marker only for the monthly recommended project
            if (project.id === currentRecommendedMonthlyId) {
              const starM = document.createElement('span');
              starM.textContent = '★';
              starM.style.color = '#f97316';
              starM.style.marginLeft = '0.25rem';
              starM.title = 'Recommended this month';
              nameDiv.appendChild(starM);
            }
            info.appendChild(nameDiv);
            const hoursDiv = document.createElement('div');
            hoursDiv.style.fontSize = '0.8rem';
            hoursDiv.style.color = '#64748b';
            hoursDiv.textContent = stats.totalHours.toFixed(1) + 'h / ' + project.budgetHours.toFixed(1) + 'h';
            info.appendChild(hoursDiv);
            item.appendChild(info);
            // progress bar container showing expected progress (black) and hours worked (blue) as two stacked bars
            const progressContainer = document.createElement('div');
            progressContainer.style.flex = '1';
            progressContainer.style.margin = '0 1rem';
            progressContainer.style.display = 'flex';
            progressContainer.style.flexDirection = 'column';
            progressContainer.style.gap = '0.2rem';
            // Calculate expected progress through the project (days passed / total days)
            const totalProjectDaysProg = stats.daysPassed + stats.daysLeft;
            const timeProg = totalProjectDaysProg > 0 ? (stats.daysPassed / totalProjectDaysProg) * 100 : 0;
            const usedProg = stats.usedPct;
            // Hours worked progress bar (blue) shown on top
            const hoursBar = document.createElement('div');
            hoursBar.className = 'progress-bar';
            const hoursFill = document.createElement('div');
            hoursFill.className = 'fill';
            hoursFill.style.width = Math.min(100, usedProg).toFixed(1) + '%';
            hoursBar.appendChild(hoursFill);
            progressContainer.appendChild(hoursBar);
            // Expected progress bar (black) shown beneath
            const expectedBar = document.createElement('div');
            expectedBar.className = 'progress-bar';
            const expectedFill = document.createElement('div');
            expectedFill.className = 'fill';
            expectedFill.style.backgroundColor = '#000000';
            expectedFill.style.width = Math.min(100, timeProg).toFixed(1) + '%';
            expectedBar.appendChild(expectedFill);
            progressContainer.appendChild(expectedBar);
            // Determine schedule status for this project by comparing used percent to time progress
            const scheduleDiffProj = usedProg - timeProg;
            let scheduleTextProj;
            if (scheduleDiffProj > 5) scheduleTextProj = 'Ahead of schedule';
            else if (scheduleDiffProj < -5) scheduleTextProj = 'Behind schedule';
            else scheduleTextProj = 'On schedule';
            // Create a small label below the bars to indicate schedule status
            const schedDivProj = document.createElement('div');
            schedDivProj.style.fontSize = '0.7rem';
            schedDivProj.style.marginTop = '0.25rem';
            // Colour code: green ahead, red behind, amber for on schedule
            if (scheduleDiffProj > 5) schedDivProj.style.color = '#15803d';
            else if (scheduleDiffProj < -5) schedDivProj.style.color = '#b91c1c';
            else schedDivProj.style.color = '#92400e';
            schedDivProj.textContent = scheduleTextProj;
            progressContainer.appendChild(schedDivProj);
            item.appendChild(progressContainer);
            // Add schedule text comment after bars
            // Note: status badge with descriptive text and tooltip will still be appended below
            // status badge with descriptive text and tooltip
            const status = document.createElement('span');
            status.className = 'status-badge ' + (stats.statusColor || 'green');
            // Determine human-friendly label
            let statusLabel;
            if (stats.status === 'over-budget') statusLabel = 'Over Budget';
            else if (stats.status === 'behind-schedule') statusLabel = 'Behind Schedule';
            else if (stats.status === 'tight') statusLabel = 'Tight';
            else statusLabel = 'On Track';
            status.textContent = statusLabel;
            // Tooltip explaining the reason
            if (stats.reason) {
              status.title = stats.reason;
            }
            item.appendChild(status);
            wrapper.appendChild(item);
          });
          container.appendChild(wrapper);
        }

        // Render detailed project breakdown table
        function renderDetailedBreakdown() {
          const container = document.getElementById('detailedBreakdown');
          container.innerHTML = '';
          if (data.projects.length === 0) return;
          const card = document.createElement('div');
          card.className = 'card';
          const heading = document.createElement('h3');
          heading.textContent = 'Detailed Project Breakdown';
          heading.style.margin = '0 0 0.5rem 0';
          heading.style.fontSize = '1.1rem';
          heading.style.fontWeight = '600';
          card.appendChild(heading);
          const table = document.createElement('table');
          // Add responsive-table class for mobile-friendly styling
          table.classList.add('responsive-table');
          const thead = document.createElement('thead');
          thead.innerHTML = '<tr><th>Project</th><th>Client</th><th>Hours</th><th>Budget</th><th>Status</th><th>This Week</th><th>Last Week</th><th>This Month</th><th>Revenue</th></tr>';
          table.appendChild(thead);
          const tbody = document.createElement('tbody');
          data.projects.forEach(project => {
            const stats = computeProjectStats(project);
            const isRecommendedWeekly = (project.id === currentRecommendedWeeklyId);
            const isRecommendedMonthly = (project.id === currentRecommendedMonthlyId);
            const tr = document.createElement('tr');
            // Determine human-friendly label and color for status
            let statusLabel;
            if (stats.status === 'over-budget') statusLabel = 'Over Budget';
            else if (stats.status === 'behind-schedule') statusLabel = 'Behind Schedule';
            else if (stats.status === 'tight') statusLabel = 'Tight';
            else statusLabel = 'On Track';
            tr.innerHTML = `
              <td data-label="Project">${project.name}</td>
              <td data-label="Client">${project.client || '-'}</td>
              <td data-label="Hours">${stats.totalHours.toFixed(1)}h</td>
              <td data-label="Budget">${project.budgetHours.toFixed(1)}h</td>
              <td data-label="Status"><span class="status-badge ${stats.statusColor}"${stats.reason ? ` title="${stats.reason}"` : ''}>${statusLabel}</span></td>
              <td data-label="This Week">${stats.weeklyHours.toFixed(1)} / ${stats.weeklyTargetConst.toFixed(1)}h (target)</td>
              <td data-label="Last Week">${stats.lastWeekHours.toFixed(1)}h</td>
              <td data-label="This Month">${stats.monthlyHours.toFixed(1)} / ${stats.monthlyTargetConst.toFixed(1)}h${isRecommendedMonthly ? ' (Recommended)' : ''} (target)</td>
              <td data-label="Revenue">${formatCurrency(stats.revenue)}</td>
            `;
            tbody.appendChild(tr);
          });
          table.appendChild(tbody);
          // Wrap table in a scroll container to improve mobile usability
          const wrapper = document.createElement('div');
          wrapper.style.overflowX = 'auto';
          wrapper.appendChild(table);
          card.appendChild(wrapper);
          container.appendChild(card);
        }

        // Render a heatmap of hours per day for the current month. Each cell's color intensity
        // corresponds to the number of hours worked on that day. Darker colors represent more
        // hours. The heatmap table is created dynamically within the #heatmap div.
        function renderHeatmap() {
          const heatmapDiv = document.getElementById('heatmap');
          if (!heatmapDiv) return;
          heatmapDiv.innerHTML = '';
          const now = new Date();
          const year = now.getFullYear();
          const month = now.getMonth();
          const firstDay = new Date(year, month, 1);
          const daysInMonth = new Date(year, month + 1, 0).getDate();
          // Accumulate hours for each day of this month
          const dailyHours = {};
          data.entries.forEach(entry => {
            if (!entry.duration) return;
            if (entry.isRunning) return;
            const dt = new Date(entry.startTime);
            if (dt.getFullYear() === year && dt.getMonth() === month) {
              const day = dt.getDate();
              dailyHours[day] = (dailyHours[day] || 0) + (entry.duration / 3600);
            }
          });
          // Determine the maximum hours to scale colors
          let maxHours = 0;
          Object.values(dailyHours).forEach(val => {
            if (val > maxHours) maxHours = val;
          });
          // Define function to interpolate between two colors based on a factor (0 to 1)
          function interpolateColor(color1, color2, factor) {
            const c1 = parseInt(color1.slice(1), 16);
            const c2 = parseInt(color2.slice(1), 16);
            const r1 = (c1 >> 16) & 0xff;
            const g1 = (c1 >> 8) & 0xff;
            const b1 = c1 & 0xff;
            const r2 = (c2 >> 16) & 0xff;
            const g2 = (c2 >> 8) & 0xff;
            const b2 = c2 & 0xff;
            const r = Math.round(r1 + (r2 - r1) * factor);
            const g = Math.round(g1 + (g2 - g1) * factor);
            const b = Math.round(b1 + (b2 - b1) * factor);
            const hex = (r << 16) | (g << 8) | b;
            return '#' + hex.toString(16).padStart(6, '0');
          }
          // Colors for low and high values
          const lowColor = '#e0e7ff';
          const highColor = '#1e40af';
          // Create table element
          const table = document.createElement('table');
          table.style.borderCollapse = 'collapse';
          table.style.width = '100%';
          const headerRow = document.createElement('tr');
          const daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
          daysOfWeek.forEach(dow => {
            const th = document.createElement('th');
            th.textContent = dow;
            th.style.fontSize = '0.8rem';
            th.style.padding = '0.25rem';
            headerRow.appendChild(th);
          });
          table.appendChild(headerRow);
          // Determine how many blank cells before the first day (Monday=0) adjusting for Sunday=6
          // In this implementation, Monday is first column; getDay() returns 0 for Sunday so convert
          let startWeekday = firstDay.getDay();
          startWeekday = (startWeekday + 6) % 7; // convert so Monday=0, Sunday=6
          let currentDay = 1;
          // Build rows until all days placed
          while (currentDay <= daysInMonth) {
            const row = document.createElement('tr');
            for (let i = 0; i < 7; i++) {
              const cell = document.createElement('td');
              cell.style.width = '14.28%';
              cell.style.height = '2rem';
              cell.style.border = '1px solid #f1f5f9';
              cell.style.textAlign = 'center';
              cell.style.fontSize = '0.75rem';
              if ((currentDay === 1 && i < startWeekday) || currentDay > daysInMonth) {
                // empty cell
                cell.textContent = '';
                cell.style.backgroundColor = '#f8fafc';
              } else {
                const hours = dailyHours[currentDay] || 0;
                // compute color intensity
                let color;
                if (hours <= 0 || maxHours === 0) {
                  color = '#f8fafc';
                } else {
                  const factor = Math.min(hours / maxHours, 1);
                  color = interpolateColor(lowColor, highColor, factor);
                }
                cell.style.backgroundColor = color;
                cell.textContent = currentDay;
                if (hours > 0) {
                  const hoursSpan = document.createElement('div');
                  hoursSpan.textContent = hours.toFixed(1) + 'h';
                  hoursSpan.style.fontSize = '0.6rem';
                  hoursSpan.style.color = '#0f172a';
                  cell.appendChild(hoursSpan);
                }
                currentDay++;
              }
              row.appendChild(cell);
            }
            table.appendChild(row);
          }
          heatmapDiv.appendChild(table);
        }

        // Populate the burndown project selector and render the initial burndown chart
        function updateBurndownSelect() {
          const select = document.getElementById('burndownProjectSelect');
          if (!select) return;
          // Prevent multiple event listeners by cloning without listeners
          const newSelect = select.cloneNode(false);
          select.parentNode.replaceChild(newSelect, select);
          data.projects.forEach(project => {
            const opt = document.createElement('option');
            opt.value = project.id;
            opt.textContent = project.name;
            newSelect.appendChild(opt);
          });
          newSelect.addEventListener('change', (e) => {
            renderBurndownChart(e.target.value);
          });
          // Render initial chart for first project (if any)
          if (data.projects.length > 0) {
            const firstId = data.projects[0].id;
            newSelect.value = firstId;
            renderBurndownChart(firstId);
          }
        }

        // Render the burndown chart for a given project ID. This charts cumulative hours worked
        // against the expected cumulative hours (linear budget burn) from project start to deadline.
        function renderBurndownChart(projectId) {
          const canvas = document.getElementById('burndownChart');
          if (!canvas || !Chart) return;
          const ctx = canvas.getContext('2d');
          // Destroy existing chart if present
          if (window.burndownChart) {
            try {
              window.burndownChart.destroy();
            } catch (err) {}
          }
          const project = data.projects.find(p => String(p.id) === String(projectId));
          if (!project) return;
          // Build date range from project start to today (or deadline, whichever is earlier)
          const startDate = new Date(project.createdAt);
          const today = new Date();
          const endDate = today < new Date(project.deadline) ? today : new Date(project.deadline);
          const days = [];
          for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
            // copy date to avoid reference issues
            days.push(new Date(d.getFullYear(), d.getMonth(), d.getDate()));
          }
          // Build labels and actual cumulative hours
          const labels = [];
          const actual = [];
          let cumulativeSeconds = 0;
          days.forEach(day => {
            labels.push(day.toISOString().slice(5, 10)); // 'MM-DD'
            // Sum durations for entries up to this day (inclusive)
            const dayEntries = data.entries.filter(e => {
              return e.projectId === projectId && !e.isRunning && new Date(e.startTime) <= day;
            });
            cumulativeSeconds = dayEntries.reduce((sum, e) => sum + (e.duration || 0), 0);
            actual.push((cumulativeSeconds / 3600));
          });
          // Expected cumulative line: linear interpolation from 0 to budget over total days until deadline
          const totalProjectDays = (new Date(project.deadline) - startDate) / (1000 * 60 * 60 * 24);
          const expected = [];
          days.forEach(day => {
            const diff = (day - startDate) / (1000 * 60 * 60 * 24);
            const ratio = totalProjectDays > 0 ? Math.min(diff / totalProjectDays, 1) : 0;
            expected.push(project.budgetHours * ratio);
          });
          // Create chart
          window.burndownChart = new Chart(ctx, {
            type: 'line',
            data: {
              labels: labels,
              datasets: [
                {
                  label: 'Expected',
                  data: expected,
                  borderColor: '#64748b',
                  backgroundColor: '#64748b',
                  borderWidth: 2,
                  fill: false
                },
                {
                  label: 'Actual',
                  data: actual,
                  borderColor: project.color || '#3b82f6',
                  backgroundColor: project.color || '#3b82f6',
                  borderWidth: 2,
                  fill: false
                }
              ]
            },
            options: {
              responsive: true,
              plugins: {
                legend: {
                  display: true,
                  position: 'bottom'
                }
              },
              scales: {
                y: {
                  beginAtZero: true,
                  title: {
                    display: true,
                    text: 'Hours'
                  }
                },
                x: {
                  title: {
                    display: true,
                    text: 'Date'
                  }
                }
              }
            }
          });
        }

        // Projects page rendering
        function updateProjectsPage() {
          updateProjectSelects();
          renderProjectsPageList();
        }
        function renderProjectsPageList() {
          const container = document.getElementById('projectsPageList');
          container.innerHTML = '';
          if (data.projects.length === 0) {
            const p = document.createElement('p');
            p.textContent = 'No projects yet.';
            container.appendChild(p);
            return;
          }
          data.projects.forEach(project => {
            const stats = computeProjectStats(project);
            // Determine if this project is the recommended one for this week or month
            const isRecommendedWeekly = (project.id === currentRecommendedWeeklyId);
            const isRecommendedMonthly = (project.id === currentRecommendedMonthlyId);
            // Determine a human-friendly status label and color
            let statusLabel;
            if (stats.status === 'over-budget') statusLabel = 'Over Budget';
            else if (stats.status === 'behind-schedule') statusLabel = 'Behind Schedule';
            else if (stats.status === 'tight') statusLabel = 'Tight';
            else statusLabel = 'On Track';
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `
              <h3 style="margin:0 0 0.5rem 0; font-size:1.1rem; font-weight:600;">${project.name}</h3>
              <p style="margin:0 0 0.25rem 0;"><strong>Client:</strong> ${project.client || '-'}</p>
              <p style="margin:0 0 0.25rem 0;"><strong>Budget:</strong> ${project.budgetHours.toFixed(1)}h @ ${formatCurrency(project.hourlyRate)}</p>
              <div style="margin:0.5rem 0;">
                <!-- Dual progress bars showing actual hours vs expected timeline progress -->
                <div style="display:flex; flex-direction:column; gap:0.2rem; margin-bottom:0.25rem;">
                  <!-- Actual hours consumed (blue) -->
                  <div class="progress-bar"><div class="fill" style="width:${Math.min(100, stats.usedPct).toFixed(1)}%;"></div></div>
                  <!-- Expected progress based on time elapsed relative to deadline (black) -->
                  <div class="progress-bar"><div class="fill" style="width:${((stats.daysPassed + stats.daysLeft) > 0 ? (stats.daysPassed / (stats.daysPassed + stats.daysLeft)) * 100 : 0).toFixed(1)}%; background-color:#000000;"></div></div>
                </div>
                <small>${stats.totalHours.toFixed(1)}h used (${stats.usedPct.toFixed(1)}%) &bullet; Expected ${(stats.daysPassed + stats.daysLeft) > 0 ? (stats.daysPassed / (stats.daysPassed + stats.daysLeft) * 100).toFixed(1) : '0'}%</small>
              </div>
              <div style="margin:0.5rem 0;">
                <div class="progress-bar" style="margin-bottom:0.25rem;"><div class="fill" style="width:${stats.weeklyTargetConst ? (stats.weeklyHours / stats.weeklyTargetConst * 100) : 0}%"></div></div>
                <small>This week: ${stats.weeklyHours.toFixed(1)} / ${stats.weeklyTargetConst.toFixed(1)}h (target)</small>
              </div>
              <div style="margin:0.5rem 0;">
                <div class="progress-bar" style="margin-bottom:0.25rem;"><div class="fill" style="width:${stats.monthlyTargetConst ? (stats.monthlyHours / stats.monthlyTargetConst * 100) : 0}%"></div></div>
                <small>This month: ${stats.monthlyHours.toFixed(1)} / ${stats.monthlyTargetConst.toFixed(1)}h${isRecommendedMonthly ? ' (Recommended)' : ''} (target)</small>
              </div>
              <p style="margin:0.25rem 0;"><strong>Deadline:</strong> ${formatDate(project.deadline)}</p>
              <p style="margin:0.25rem 0;"><strong>Status:</strong> <span class="status-badge ${stats.statusColor || 'green'}"${stats.reason ? ` title="${stats.reason}"` : ''}>${statusLabel}</span></p>
              <div style="display:flex; gap:0.5rem; margin-top:0.5rem;">
                <button class="btn secondary edit-btn" data-id="${project.id}">Edit</button>
                <button class="btn danger delete-btn" data-id="${project.id}">Delete</button>
              </div>
            `;
            // Edit button handler
            const editBtn = card.querySelector('.edit-btn');
            editBtn.addEventListener('click', () => {
              // Prompt the user for new project details
              const newName = prompt('Project Name:', project.name);
              if (!newName) return;
              const newClient = prompt('Client (optional):', project.client || '');
              const newBudgetStr = prompt('Budget Hours:', project.budgetHours.toFixed(1));
              const newBudget = parseFloat(newBudgetStr);
              if (isNaN(newBudget)) return;
              const newRateStr = prompt('Hourly Rate:', project.hourlyRate.toFixed(2));
              const newRate = parseFloat(newRateStr);
              if (isNaN(newRate)) return;
              const newDeadline = prompt('Deadline (YYYY-MM-DD):', project.deadline);
              if (!newDeadline) return;
              // Prompt for rounding preference (minutes) and update roundingMinutes
              const newRoundingStr = prompt('Rounding (minutes – 0 for none, 5, 10, 15):', project.roundingMinutes != null ? project.roundingMinutes.toString() : '0');
              const newRoundingInt = parseInt(newRoundingStr, 10);
              // If the user cancels or enters invalid number, leave rounding unchanged
              if (!isNaN(newRoundingInt)) {
                project.roundingMinutes = newRoundingInt;
              }
              // Update project fields
              project.name = newName.trim();
              project.client = newClient ? newClient.trim() : null;
              project.budgetHours = newBudget;
              project.hourlyRate = newRate;
              project.deadline = newDeadline;
              saveData();
              updateProjectsPage();
              updateProjectSelects();
              updateDashboard();
            });
            // Delete button handler
            const deleteBtn = card.querySelector('.delete-btn');
            deleteBtn.addEventListener('click', () => {
              if (confirm('Delete this project and its entries?')) {
                data.projects = data.projects.filter(p => p.id !== project.id);
                data.entries = data.entries.filter(e => e.projectId !== project.id);
                saveData();
                updateProjectsPage();
                updateDashboard();
              }
            });
            container.appendChild(card);
          });
        }

        // Create new project
        document.getElementById('projectFormPro').addEventListener('submit', (e) => {
          e.preventDefault();
          const name = document.getElementById('projectNamePro').value.trim();
          const client = document.getElementById('projectClientPro').value.trim();
          const budget = parseFloat(document.getElementById('projectBudgetPro').value);
          const rate = parseFloat(document.getElementById('projectRatePro').value);
          const deadline = document.getElementById('projectDeadlinePro').value;
          if (!name || !deadline) return;
          const newProject = {
            id: uuid(),
            name,
            client: client || null,
            budgetHours: budget,
            hourlyRate: rate,
            deadline,
            createdAt: new Date().toISOString(),
            color: getUniqueColor(),
            isActive: true,
            // Store rounding preference for this project; roundingMinutes is the interval in minutes (0 means no rounding)
            roundingMinutes: parseInt(document.getElementById('projectRoundingPro').value, 10) || 0
          };
          data.projects.push(newProject);
          saveData();
          e.target.reset();
          updateProjectsPage();
          updateProjectSelects();
          updateDashboard();
        });

        // Color generator for project dots. Ensures uniqueness by selecting an unused color when possible.
        function getRandomColor() {
          const palette = ['#2563eb', '#dc2626', '#10b981', '#8b5cf6', '#f59e0b', '#ec4899'];
          return palette[Math.floor(Math.random() * palette.length)];
        }

        function getUniqueColor() {
          const palette = ['#2563eb', '#dc2626', '#10b981', '#8b5cf6', '#f59e0b', '#ec4899'];
          // Collect colors already used by existing projects
          const used = new Set(data.projects.map(p => p.color).filter(c => c));
          // Find a color not used yet
          for (const col of palette) {
            if (!used.has(col)) {
              return col;
            }
          }
          // If all colors are used, return a random one
          return palette[Math.floor(Math.random() * palette.length)];
        }

        // Timer section functions (reuse from previous implementation but adjust IDs)
        function getRunningEntries() {
          // Return an array of all entries that are currently running
          return data.entries.filter(e => e.isRunning);
        }
        function updateTimerSection() {
          const runningEntries = getRunningEntries();
          const runningDiv = document.getElementById('runningTimerPro');
          const startDiv = document.getElementById('startTimerPro');
          // Clear any previous interval that updated timers
          clearInterval(timerInterval);
          if (runningEntries.length > 0) {
            // Show the running timers section
            runningDiv.style.display = '';
            // Keep the start form visible to allow starting additional timers
            startDiv.style.display = '';
            // Clear and rebuild the running timers list
            runningDiv.innerHTML = '';
            // Heading for running timers
            const heading = document.createElement('h3');
            heading.textContent = 'Running Timers';
            heading.style.margin = '0 0 0.5rem 0';
            heading.style.fontSize = '1.1rem';
            heading.style.fontWeight = '600';
            runningDiv.appendChild(heading);
            // Display total earnings for all running timers
            const totalEarnedP = document.createElement('p');
            totalEarnedP.innerHTML = '<strong>Total Earned:</strong> <span id="runningTotalEarned"></span>';
            totalEarnedP.style.marginBottom = '0.5rem';
            runningDiv.appendChild(totalEarnedP);
            // Add a "Stop All Timers" button to allow stopping all timers at once
            const stopAllBtn = document.createElement('button');
            stopAllBtn.className = 'btn danger';
            stopAllBtn.textContent = 'Stop All Timers';
            stopAllBtn.style.marginBottom = '0.75rem';
            stopAllBtn.addEventListener('click', () => {
              stopAllTimers();
            });
            runningDiv.appendChild(stopAllBtn);
            // Render each running entry
            runningEntries.forEach(entry => {
              const project = data.projects.find(p => p.id === entry.projectId);
              const row = document.createElement('div');
              row.style.marginBottom = '0.75rem';
              // Project name
              const nameP = document.createElement('p');
              nameP.innerHTML = '<strong>Project:</strong> ' + (project ? project.name : '');
              row.appendChild(nameP);
              // Started time
              const startP = document.createElement('p');
              startP.innerHTML = '<strong>Started:</strong> ' + formatDateTime(entry.startTime);
              row.appendChild(startP);
              // Elapsed time
              const elapsedP = document.createElement('p');
              elapsedP.innerHTML = '<strong>Elapsed:</strong> ';
              const elapsedSpan = document.createElement('span');
              elapsedSpan.id = 'runningElapsed-' + entry.id;
              elapsedSpan.textContent = '';
              elapsedP.appendChild(elapsedSpan);
              row.appendChild(elapsedP);
              // Factor display (e.g. 100%, 75%)
              const factorP = document.createElement('p');
              factorP.innerHTML = '<strong>Factor:</strong> ';
              const factorSpan = document.createElement('span');
              factorSpan.id = 'runningFactor-' + entry.id;
              factorSpan.textContent = '';
              factorP.appendChild(factorSpan);
              row.appendChild(factorP);
              // Factor override selector. Allows the user to override the concurrency factor
              const overrideP = document.createElement('p');
              overrideP.innerHTML = '<strong>Override:</strong> ';
              const factorSelect = document.createElement('select');
              factorSelect.style.marginLeft = '0.25rem';
              // Default option for automatic concurrency (no override)
              const optDef = document.createElement('option');
              optDef.value = '';
              optDef.textContent = 'Auto';
              factorSelect.appendChild(optDef);
              // Predefined override options
              [
                ['1', '100%'],
                ['0.75', '75%'],
                ['0.5', '50%'],
                ['0.25', '25%']
              ].forEach(([val, label]) => {
                const opt = document.createElement('option');
                opt.value = val;
                opt.textContent = label;
                factorSelect.appendChild(opt);
              });
              // Set current selection based on manualFactor
              if (entry.manualFactor) {
                factorSelect.value = String(entry.manualFactor);
              } else {
                factorSelect.value = '';
              }
              factorSelect.addEventListener('change', () => {
                const v = factorSelect.value;
                // Before changing the factor, accumulate time elapsed since last update
                const now = new Date();
                const lastUpdate = entry.lastUpdateTime ? new Date(entry.lastUpdateTime) : new Date(entry.startTime);
                const elapsedSec = (now - lastUpdate) / 1000;
                // Use current factor (manual override or concurrency) to update effective seconds
                const currentFactor = entry.factor || computeConcurrencyFactor(getRunningEntries().length);
                entry.effectiveSeconds = (entry.effectiveSeconds || 0) + elapsedSec * currentFactor;
                // Update last update timestamp to now
                entry.lastUpdateTime = now.toISOString();
                // Apply new override or restore automatic factor
                if (!v) {
                  // Remove override: restore concurrency factor based on current running count
                  entry.manualFactor = null;
                  const count = getRunningEntries().length;
                  entry.factor = computeConcurrencyFactor(count);
                } else {
                  const fVal = parseFloat(v);
                  entry.manualFactor = fVal;
                  entry.factor = fVal;
                }
                saveData();
                // Refresh the timer section to apply the new factor
                updateTimerSection();
                // Recompute focus blocker activation in case total factor changed
                updateFocusBlocker();
              });
              overrideP.appendChild(factorSelect);
              row.appendChild(overrideP);
              // Earned display
              const earnP = document.createElement('p');
              earnP.innerHTML = '<strong>Earned:</strong> ';
              const earnSpan = document.createElement('span');
              earnSpan.id = 'runningEarned-' + entry.id;
              earnSpan.textContent = '';
              earnP.appendChild(earnSpan);
              row.appendChild(earnP);
              // Nudge controls: allow the user to adjust elapsed time in 5 minute increments
              const nudgeDiv = document.createElement('div');
              nudgeDiv.style.display = 'flex';
              nudgeDiv.style.gap = '0.25rem';
              // Minus 5 minutes button
              const minusBtn = document.createElement('button');
              minusBtn.className = 'btn secondary';
              minusBtn.textContent = '-5m';
              minusBtn.style.padding = '0.25rem 0.5rem';
              minusBtn.style.fontSize = '0.75rem';
              minusBtn.addEventListener('click', () => {
                // Compute elapsed time since last update and update effective seconds first
                const now = new Date();
                const lastUpdate = entry.lastUpdateTime ? new Date(entry.lastUpdateTime) : new Date(entry.startTime);
                const elapsedSec = (now - lastUpdate) / 1000;
                // Use current factor (manual override or concurrency) to update effective seconds
                const currentFactor = entry.manualFactor != null ? entry.manualFactor : (entry.factor || computeConcurrencyFactor(getRunningEntries().length));
                entry.effectiveSeconds = (entry.effectiveSeconds || 0) + elapsedSec * currentFactor;
                entry.lastUpdateTime = now.toISOString();
                // Subtract 5 minutes of actual time from effectiveSeconds taking into account factor
                const delta = 300 * currentFactor;
                entry.effectiveSeconds = Math.max(0, (entry.effectiveSeconds || 0) - delta);
                saveData();
                updateTimerSection();
                provideHaptic('beep');
              });
              nudgeDiv.appendChild(minusBtn);
              // Plus 5 minutes button
              const plusBtn = document.createElement('button');
              plusBtn.className = 'btn secondary';
              plusBtn.textContent = '+5m';
              plusBtn.style.padding = '0.25rem 0.5rem';
              plusBtn.style.fontSize = '0.75rem';
              plusBtn.addEventListener('click', () => {
                // Compute elapsed time since last update and update effective seconds first
                const now = new Date();
                const lastUpdate = entry.lastUpdateTime ? new Date(entry.lastUpdateTime) : new Date(entry.startTime);
                const elapsedSec = (now - lastUpdate) / 1000;
                const currentFactor = entry.manualFactor != null ? entry.manualFactor : (entry.factor || computeConcurrencyFactor(getRunningEntries().length));
                entry.effectiveSeconds = (entry.effectiveSeconds || 0) + elapsedSec * currentFactor;
                entry.lastUpdateTime = now.toISOString();
                // Add 5 minutes of actual time to effectiveSeconds, scaled by factor
                const delta = 300 * currentFactor;
                entry.effectiveSeconds = (entry.effectiveSeconds || 0) + delta;
                saveData();
                updateTimerSection();
                provideHaptic('beep');
              });
              nudgeDiv.appendChild(plusBtn);
              row.appendChild(nudgeDiv);
              // Stop button
              const stopBtn = document.createElement('button');
              stopBtn.className = 'btn danger';
              stopBtn.textContent = 'Stop';
              stopBtn.addEventListener('click', () => {
                stopSingleTimer(entry.id);
              });
              row.appendChild(stopBtn);
              runningDiv.appendChild(row);
            });
            // Start an interval that updates all running timers every second
            const tick = () => {
              const now = new Date();
              let totalEarned = 0;
              runningEntries.forEach(entry => {
                // Compute effective elapsed time: accumulate effectiveSeconds plus time since last update times current factor
                const last = entry.lastUpdateTime ? new Date(entry.lastUpdateTime) : new Date(entry.startTime);
                const prev = entry.effectiveSeconds || 0;
                const factor = entry.factor || computeConcurrencyFactor(runningEntries.length);
                const extra = (now - last) / 1000 * factor;
                const effective = prev + extra;
                // Update elapsed display
                const elapsedSpan = document.getElementById('runningElapsed-' + entry.id);
                if (elapsedSpan) elapsedSpan.textContent = formatDuration(Math.floor(effective));
                // Update factor display as percentage
                const factorSpan = document.getElementById('runningFactor-' + entry.id);
                if (factorSpan) factorSpan.textContent = Math.round(factor * 100) + '%';
                // Compute earned amount for this entry based on the project hourly rate
                const project = data.projects.find(p => p.id === entry.projectId);
                let earned = 0;
                if (project) {
                  earned = (effective / 3600) * (project.hourlyRate || 0);
                }
                const earnSpan = document.getElementById('runningEarned-' + entry.id);
                if (earnSpan) earnSpan.textContent = formatCurrency(earned, 0);
                totalEarned += earned;
              });
              // Update total earned across all running timers
              const totalSpan = document.getElementById('runningTotalEarned');
              if (totalSpan) totalSpan.textContent = formatCurrency(totalEarned, 0);
            };
            tick();
            timerInterval = setInterval(tick, 1000);
          } else {
            // No running entries: hide running timer section and show start form
            runningDiv.style.display = 'none';
            runningDiv.innerHTML = '';
            startDiv.style.display = '';
          }
          // update project selects
          updateProjectSelects();
        }

        // Stop a single running timer by id
        function stopSingleTimer(entryId) {
          const toStop = data.entries.find(e => e.id === entryId && e.isRunning);
          // Provide tactile feedback when stopping a timer
          provideHaptic('long');
          if (!toStop) return;
          const now = new Date();
          // Gather all running entries including the one to stop
          const runningEntries = getRunningEntries();
          const n = runningEntries.length;
          // First update effective seconds for all running entries using their current factor
          runningEntries.forEach(e => {
            const last = e.lastUpdateTime ? new Date(e.lastUpdateTime) : new Date(e.startTime);
            const elapsedSec = (now - last) / 1000;
            const prevFactor = e.factor || computeConcurrencyFactor(n);
            e.effectiveSeconds = (e.effectiveSeconds || 0) + elapsedSec * prevFactor;
            e.lastUpdateTime = now.toISOString();
          });
          // Finalize the stopped entry
          const finalSeconds = toStop.effectiveSeconds || 0;
          toStop.endTime = now.toISOString();
          toStop.duration = Math.floor(finalSeconds);
          toStop.isRunning = false;
          // Cleanup weighted fields (optional)
          delete toStop.effectiveSeconds;
          delete toStop.lastUpdateTime;
          delete toStop.factor;
          // Compute new concurrency factor for remaining running timers after removal
          const remaining = runningEntries.filter(e => e.id !== entryId);
          const newCount = remaining.length;
          const newFactor = computeConcurrencyFactor(newCount);
          // Update remaining running entries: assign new factor only if no manual override
          remaining.forEach(e => {
            if (!e.manualFactor) {
              e.factor = newFactor;
            }
            e.lastUpdateTime = now.toISOString();
          });
          // Persist and refresh
          saveData();
          updateTimerSection();
          updateDashboard();
          updateEntriesTable();
          // Do not immediately save backup here; periodic auto‑sync will handle exporting
          // Recompute focus blocker activation after stopping this timer. If the total
          // factor has dropped below or equal to 50%, the blocker will be disabled.
          updateFocusBlocker();
        }
        let timerInterval = null;
        // Chart instances for weekly and monthly scatter plots
        let weeklyScatterChart = null;
        let monthlyScatterChart = null;
        document.getElementById('startTimerBtnPro').addEventListener('click', () => {
          const projectId = document.getElementById('timerProjectPro').value;
          // Hours already spent when starting the timer (pre-filled time)
          const initialHours = parseFloat(document.getElementById('timerInitialPro').value) || 0;
          if (!projectId) return;
          // Check if there's already a running timer for this project
          const runningEntries = getRunningEntries();
          // Prevent starting multiple timers for the same project. Compare string representations of IDs to avoid mismatches.
          if (runningEntries.some(e => String(e.projectId) === String(projectId))) {
            alert('A timer is already running for this project. You cannot start another timer for the same project.');
            return;
          }
          // No immediate focus start here; activation of focus mode will be handled
          // by updateFocusBlocker() based on the total factor of running timers.

          // Provide tactile feedback when starting a timer
          provideHaptic('long');
          const now = new Date();
          // Determine override factor selected by the user (if any)
          const overrideVal = document.getElementById('startFactorPro').value;
          // Compute the new concurrency count including the new entry
          const newConcurrencyCount = runningEntries.length + 1;
          // Compute the concurrency factor that would apply if no override is used
          const autoFactor = computeConcurrencyFactor(newConcurrencyCount);
          // Update all existing running entries: accumulate effective seconds and set new factor
          runningEntries.forEach(e => {
            const last = e.lastUpdateTime ? new Date(e.lastUpdateTime) : new Date(e.startTime);
            const elapsedSec = (now - last) / 1000;
            const prevFactor = e.factor || computeConcurrencyFactor(runningEntries.length);
            e.effectiveSeconds = (e.effectiveSeconds || 0) + elapsedSec * prevFactor;
            e.lastUpdateTime = now.toISOString();
            // For timers without manual override, assign the new concurrency factor
            if (!e.manualFactor) {
              e.factor = autoFactor;
            }
          });
          // Create new entry for the selected project
          const realStart = new Date(now.getTime() - initialHours * 3600 * 1000);
          // Determine the factor for the new entry: manual override or auto
          let newEntryFactor;
          let newEntryManual = null;
          if (overrideVal) {
            newEntryFactor = parseFloat(overrideVal);
            newEntryManual = newEntryFactor;
          } else {
            newEntryFactor = autoFactor;
            newEntryManual = null;
          }
          const newEntry = {
            id: uuid(),
            projectId,
            description: '',
            startTime: realStart.toISOString(),
            endTime: null,
            duration: null,
            isRunning: true,
            createdAt: now.toISOString(),
            effectiveSeconds: initialHours * 3600,
            lastUpdateTime: now.toISOString(),
            factor: newEntryFactor,
            manualFactor: newEntryManual
          };
          data.entries.push(newEntry);
          // Reset initial input and focus factor selection
          document.getElementById('timerInitialPro').value = '';
          document.getElementById('startFactorPro').value = '';
          saveData();
          // Update UI and timers
          updateProjectSelects();
          updateTimerSection();
          updateDashboard();
          // After adding the new entry, update the focus blocker based on the new total factor
          updateFocusBlocker();
        });
        document.getElementById('stopTimerBtnPro').addEventListener('click', () => {
          stopAllTimers();
        });

        // Stop all running timers at once, updating their weighted durations consistently
        function stopAllTimers() {
          const runningList = getRunningEntries();
          if (runningList.length === 0) return;
          const now = new Date();
          const n = runningList.length;
          // Update effective seconds for all entries using their current factors
          runningList.forEach(e => {
            const last = e.lastUpdateTime ? new Date(e.lastUpdateTime) : new Date(e.startTime);
            const elapsedSec = (now - last) / 1000;
            const prevFactor = e.factor || computeConcurrencyFactor(n);
            e.effectiveSeconds = (e.effectiveSeconds || 0) + elapsedSec * prevFactor;
            e.lastUpdateTime = now.toISOString();
          });
          // Finalize each entry: set duration, endTime, isRunning
          runningList.forEach(e => {
            // Compute raw duration in seconds
            let rawDuration = Math.floor(e.effectiveSeconds || 0);
            // Apply rounding based on project rounding preference
            const projR = data.projects.find(p => String(p.id) === String(e.projectId));
            if (projR && projR.roundingMinutes && projR.roundingMinutes > 0) {
              const rounding = projR.roundingMinutes;
              const minutes = rawDuration / 60;
              const roundedMinutes = Math.round(minutes / rounding) * rounding;
              rawDuration = Math.floor(roundedMinutes * 60);
            }
            e.duration = rawDuration;
            e.endTime = now.toISOString();
            e.isRunning = false;
            delete e.effectiveSeconds;
            delete e.lastUpdateTime;
            delete e.factor;
          });
          saveData();
          updateTimerSection();
          updateDashboard();
          updateEntriesTable();
          // Do not immediately save backup here; periodic auto‑sync will handle exporting
          // After stopping all timers, recompute focus blocker activation based on total factor
          updateFocusBlocker();
        }

        // Update project selects for timer and manual forms
        function updateProjectSelects() {
          const timerSelect = document.getElementById('timerProjectPro');
          const manualSelect = document.getElementById('manualProjectPro');
          timerSelect.innerHTML = '';
          manualSelect.innerHTML = '';
          if (data.projects.length === 0) {
            const opt = document.createElement('option');
            opt.value = '';
            opt.textContent = '-- no projects --';
            timerSelect.appendChild(opt);
            manualSelect.appendChild(opt.cloneNode(true));
            document.getElementById('startTimerBtnPro').disabled = true;
            return;
          }
          // Sort projects based on monthly budget urgency rather than alphabetically. We compute the
          // deficit between the dynamic monthly target and the hours worked so far this month. Projects
          // with larger positive deficits (i.e., those most behind on their monthly target) are shown
          // first. Negative deficits (projects ahead of their monthly target) will appear later. If two
          // projects have the same deficit, preserve original order. After sorting, if there is a
          // recommended monthly project, move it to the top regardless of deficit.
          const sortedProjects = data.projects.slice().sort((a, b) => {
            let defA = 0; let defB = 0;
            try {
              const sa = computeProjectStats(a);
              const sb = computeProjectStats(b);
              defA = (sa.monthlyTargetConst || 0) - (sa.monthlyHours || 0);
              defB = (sb.monthlyTargetConst || 0) - (sb.monthlyHours || 0);
            } catch (err) {
              return 0;
            }
            if (defB > defA) return 1;
            if (defB < defA) return -1;
            return 0;
          });
          // If there is a recommended monthly project, ensure it appears at the top
          if (currentRecommendedMonthlyId) {
            const idx = sortedProjects.findIndex(p => p.id === currentRecommendedMonthlyId);
            if (idx > 0) {
              const [recProj] = sortedProjects.splice(idx, 1);
              sortedProjects.unshift(recProj);
            }
          }
          sortedProjects.forEach(project => {
            // First option for timer select with possible recommendation hint
            const o1 = document.createElement('option');
            o1.value = project.id;
            let label = project.name;
            // If this project is the monthly recommended project, append a hint about how many hours are needed this month
            if (project.id === currentRecommendedMonthlyId) {
              const sp = computeProjectStats(project);
              let monthlyNeeded = (sp.monthlyTargetConst || 0) - (sp.monthlyHours || 0);
              if (monthlyNeeded < 0) monthlyNeeded = 0;
              label += ' (Recommended, needs ~' + monthlyNeeded.toFixed(1) + 'h this month)';
            }
            o1.textContent = label;
            timerSelect.appendChild(o1);
            // Second option for manual entry select (no recommendation hint)
            const o2 = document.createElement('option');
            o2.value = project.id;
            o2.textContent = project.name;
            manualSelect.appendChild(o2);
          });
          // Disable timer options for projects that already have a running timer
          const runningProjects = getRunningEntries().map(e => e.projectId);
          timerSelect.querySelectorAll('option').forEach(opt => {
            const shouldDisable = runningProjects.some(id => String(id) === String(opt.value));
            opt.disabled = shouldDisable;
          });
          document.getElementById('startTimerBtnPro').disabled = false;
        }
        // Manual entry add/cancel
        document.getElementById('addManualEntryBtnPro').addEventListener('click', () => {
          document.getElementById('manualEntryFormPro').classList.remove('hidden');
        });
        document.getElementById('cancelManualBtnPro').addEventListener('click', () => {
          document.getElementById('manualEntryFormPro').classList.add('hidden');
          document.getElementById('manualFormPro').reset();
        });
        document.getElementById('manualFormPro').addEventListener('submit', (e) => {
          e.preventDefault();
          const projectId = document.getElementById('manualProjectPro').value;
          const description = document.getElementById('manualDescriptionPro').value.trim();
          const hoursVal = parseFloat(document.getElementById('manualHoursPro').value);
          if (!projectId || isNaN(hoursVal) || hoursVal <= 0) return;
          const now = new Date();
          // Apply rounding based on project preferences. If the project specifies a rounding interval (minutes),
          // we round the hours to the nearest interval before converting to seconds.
          let adjustedHours = hoursVal;
          const projForRound = data.projects.find(p => String(p.id) === String(projectId));
          if (projForRound && projForRound.roundingMinutes && projForRound.roundingMinutes > 0) {
            const rounding = projForRound.roundingMinutes;
            const minutesVal = hoursVal * 60;
            const roundedMinutes = Math.round(minutesVal / rounding) * rounding;
            adjustedHours = roundedMinutes / 60;
          }
          const durationSeconds = Math.floor(adjustedHours * 3600);
          // start time is computed as end time minus duration
          const startTime = new Date(now.getTime() - durationSeconds * 1000);
          const newEntry = {
            id: uuid(),
            projectId,
            description,
            startTime: startTime.toISOString(),
            endTime: now.toISOString(),
            duration: durationSeconds,
            isRunning: false,
            createdAt: now.toISOString()
          };
          data.entries.push(newEntry);
          saveData();
          e.target.reset();
          document.getElementById('manualEntryFormPro').classList.add('hidden');
          updateEntriesTable();
          updateDashboard();
          updateProjectsPage();
        });

        // Toggle between showing all entries and only recent entries (last 30 days). When
        // showing only recent entries, the button text reads "Show All". When
        // showing all entries, it reads "Show Recent". Clicking the button
        // toggles the view and re-renders the entries table.
        const toggleEntriesBtn = document.getElementById('toggleEntriesViewBtn');
        if (toggleEntriesBtn) {
          toggleEntriesBtn.addEventListener('click', () => {
            showAllEntries = !showAllEntries;
            toggleEntriesBtn.textContent = showAllEntries ? 'Show Recent' : 'Show All';
            updateEntriesTable();
          });
        }

        // Nudge buttons for manual entry: adjust hours by ±5 minutes
        const minusBtn = document.getElementById('manualMinus5Btn');
        const plusBtn = document.getElementById('manualPlus5Btn');
        if (minusBtn && plusBtn) {
          minusBtn.addEventListener('click', () => {
            // Provide a short beep when nudging entry time
            provideHaptic('beep');
            const hoursInput = document.getElementById('manualHoursPro');
            let current = parseFloat(hoursInput.value) || 0;
            current -= (5 / 60);
            if (current < 0) current = 0;
            hoursInput.value = current.toFixed(2);
          });
          plusBtn.addEventListener('click', () => {
            provideHaptic('beep');
            const hoursInput = document.getElementById('manualHoursPro');
            let current = parseFloat(hoursInput.value) || 0;
            current += (5 / 60);
            hoursInput.value = current.toFixed(2);
          });
        }

        // Delete entry
        function deleteEntry(id) {
          data.entries = data.entries.filter(e => e.id !== id);
          saveData();
          updateEntriesTable();
          updateDashboard();
          updateProjectsPage();
        }

        // Entries table
        function updateEntriesTable() {
          const tbody = document.getElementById('entriesTableBodyPro');
          tbody.innerHTML = '';
          if (data.entries.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 7;
            td.textContent = 'No entries yet.';
            td.style.textAlign = 'center';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
          }
          // Decide which entries to show. If showAllEntries is false, only include entries
          // whose start or end times are within the past 30 days. Otherwise include all.
          let entriesToShow = data.entries;
          if (!showAllEntries) {
            const cutoff = new Date();
            // Set cutoff to 30 days ago
            cutoff.setDate(cutoff.getDate() - 30);
            entriesToShow = data.entries.filter(e => {
              const startDate = new Date(e.startTime);
              const endDate = e.endTime ? new Date(e.endTime) : startDate;
              return startDate >= cutoff || endDate >= cutoff;
            });
          }
          // sort by start time desc
          const sorted = [...entriesToShow].sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
          sorted.forEach(entry => {
            const tr = document.createElement('tr');
            const project = data.projects.find(p => p.id === entry.projectId);
            const hours = entry.duration ? entry.duration / 3600 : 0;
            const total = project ? hours * project.hourlyRate : 0;
            tr.innerHTML = `
              <td>${project ? project.name : ''}</td>
              <td>${entry.description || ''}</td>
              <td>${formatDateTime(entry.startTime)}</td>
              <td>${entry.endTime ? formatDateTime(entry.endTime) : (entry.isRunning ? '—' : '')}</td>
              <td>${entry.duration ? formatDuration(entry.duration) : (entry.isRunning ? 'Running…' : '')}</td>
              <td>${formatCurrency(total)}</td>
              <td></td>
            `;
            // Action cell: add nudge and snap controls plus delete button
            const actionsTd = tr.lastElementChild;
            // −5m button
            const minusBtn = document.createElement('button');
            minusBtn.className = 'btn secondary';
            minusBtn.style.padding = '0.25rem 0.5rem';
            minusBtn.style.fontSize = '0.7rem';
            minusBtn.textContent = '−5m';
            minusBtn.addEventListener('click', () => {
              // Provide quick beep feedback
              provideHaptic('beep');
              // Subtract 5 minutes (300 seconds) from the entry duration
              let newDur = (entry.duration || 0) - 300;
              if (newDur < 0) newDur = 0;
              entry.duration = newDur;
              // Update endTime based on new duration
              const start = new Date(entry.startTime);
              entry.endTime = new Date(start.getTime() + newDur * 1000).toISOString();
              saveData();
              updateEntriesTable();
              updateDashboard();
              updateProjectsPage();
              updateTimerSection();
            });
            actionsTd.appendChild(minusBtn);
            // +5m button
            const plusBtn = document.createElement('button');
            plusBtn.className = 'btn secondary';
            plusBtn.style.padding = '0.25rem 0.5rem';
            plusBtn.style.fontSize = '0.7rem';
            plusBtn.style.marginLeft = '0.25rem';
            plusBtn.textContent = '+5m';
            plusBtn.addEventListener('click', () => {
              provideHaptic('beep');
              // Add 5 minutes to the duration
              let newDur = (entry.duration || 0) + 300;
              entry.duration = newDur;
              const start = new Date(entry.startTime);
              entry.endTime = new Date(start.getTime() + newDur * 1000).toISOString();
              saveData();
              updateEntriesTable();
              updateDashboard();
              updateProjectsPage();
              updateTimerSection();
            });
            actionsTd.appendChild(plusBtn);
            // Snap selector: choose nearest minutes (5,10,15)
            const snapSelect = document.createElement('select');
            snapSelect.style.marginLeft = '0.25rem';
            snapSelect.style.padding = '0.25rem';
            snapSelect.style.fontSize = '0.7rem';
            snapSelect.style.border = '1px solid #cbd5e1';
            snapSelect.style.borderRadius = '0.375rem';
            // Placeholder option
            const placeholderOption = document.createElement('option');
            placeholderOption.value = '';
            placeholderOption.textContent = 'Snap';
            snapSelect.appendChild(placeholderOption);
            [5,10,15].forEach(mins => {
              const opt = document.createElement('option');
              opt.value = String(mins);
              opt.textContent = mins + 'm';
              snapSelect.appendChild(opt);
            });
            snapSelect.addEventListener('change', () => {
              const val = parseInt(snapSelect.value);
              if (!isNaN(val) && val > 0) {
                const minutes = (entry.duration || 0) / 60;
                const snappedMinutes = Math.round(minutes / val) * val;
                entry.duration = Math.max(0, Math.floor(snappedMinutes * 60));
                const start = new Date(entry.startTime);
                entry.endTime = new Date(start.getTime() + entry.duration * 1000).toISOString();
                saveData();
                updateEntriesTable();
                updateDashboard();
                updateProjectsPage();
                updateTimerSection();
              }
              // reset to placeholder
              snapSelect.value = '';
            });
            actionsTd.appendChild(snapSelect);
            // Delete button
            const delBtn = document.createElement('button');
            delBtn.className = 'btn danger';
            delBtn.style.padding = '0.25rem 0.5rem';
            delBtn.style.fontSize = '0.7rem';
            delBtn.style.marginLeft = '0.25rem';
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', () => {
              if (confirm('Delete this entry?')) deleteEntry(entry.id);
            });
            actionsTd.appendChild(delBtn);
            tbody.appendChild(tr);
          });
        }

        // Export / Import
        document.getElementById('exportBtnPro').addEventListener('click', () => {
          // Use shared downloadData function for exports
          downloadData();
        });
        document.getElementById('importInputPro').addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          const text = await file.text();
          try {
            const imported = JSON.parse(text);
            if (!Array.isArray(imported.projects) || !Array.isArray(imported.entries)) {
              alert('Invalid data format');
              return;
            }
            data = imported;
            // Remove any transient timer fields (effectiveSeconds, lastUpdateTime, factor) from imported entries
            data.entries.forEach(entry => {
              delete entry.effectiveSeconds;
              delete entry.lastUpdateTime;
              delete entry.factor;
            });
            // Assign colors to projects without color and ensure uniqueness
            let colorChanged = false;
            data.projects.forEach(p => {
              if (!p.color) {
                p.color = getUniqueColor();
                colorChanged = true;
              }
            });
            if (colorChanged) {
              saveData();
            } else {
              // Save imported data even if colors did not change
              saveData();
            }
            // Refresh UI
            updateDashboard();
            updateProjectsPage();
            updateEntriesTable();
            updateTimerSection();
            alert('Data imported successfully');
          } catch (err) {
            alert('Failed to import: ' + err.message);
          }
        });

        // Initial render
        updateProjectSelects();
        updateEntriesTable();
        updateProjectsPage();
        updateDashboard();
        updateTimerSection();
        // Programmatically activate the Timer tab on first load. This ensures the Timer
        // section is displayed instead of the Dashboard when the page is opened. We
        // simulate a click on the Timer navigation item which will trigger the
        // navigation handler to set the active class and hide/show sections.
        const timerNavItem = document.querySelector('#navList li[data-section="timer"]');
        if (timerNavItem) {
          timerNavItem.click();
        }

        // Initialize auto sync toggle and status message
        const autoSyncToggle = document.getElementById('autoSyncToggle');
        const autoSyncStatusElem = document.getElementById('autoSyncStatus');
        const autoSyncWarningElem = document.getElementById('autoSyncWarning');
        const lastBackupStatusElem = document.getElementById('lastBackupStatus');
        function syncAutoSyncToggleUI() {
          if (!autoSyncToggle) return;
          const shouldCheck = autoSyncEnabled && backupPermissionState === 'granted' && !!backupDirHandle;
          if (autoSyncToggle.checked !== shouldCheck) {
            autoSyncToggle.checked = shouldCheck;
          }
        }
        function updateAutoSyncStatus() {
          if (!autoSyncStatusElem) return;
          syncAutoSyncToggleUI();
          const hasHandle = !!backupDirHandle;
          const backupName = hasHandle ? (backupDirHandle.name || data.backupDirName || '') : (data && data.backupDirName) || '';
          const folderUsable = hasHandle && backupPermissionState === 'granted';
          if (autoSyncEnabled && folderUsable) {
            autoSyncStatusElem.textContent = backupName
              ? `Auto sync is ON – syncing to “${backupName}”.`
              : 'Auto sync is ON – syncing to your backup folder.';
          } else if (autoSyncEnabled && hasHandle && backupPermissionState !== 'granted') {
            autoSyncStatusElem.textContent = backupName
              ? `Auto sync is ON but access to “${backupName}” must be re-authorized.`
              : 'Auto sync is ON but access to the backup folder must be re-authorized.';
          } else if (autoSyncEnabled) {
            autoSyncStatusElem.textContent = 'Auto sync is ON but no backup folder is available.';
          } else if (!autoSyncEnabled && folderUsable) {
            autoSyncStatusElem.textContent = backupName
              ? `Auto sync is OFF – backup folder “${backupName}” is ready.`
              : 'Auto sync is OFF – backup folder is ready.';
          } else if (!autoSyncEnabled && hasHandle) {
            autoSyncStatusElem.textContent = backupName
              ? `Auto sync is OFF – allow access to “${backupName}” to resume.`
              : 'Auto sync is OFF – allow access to the backup folder to resume.';
          } else {
            autoSyncStatusElem.textContent = 'Auto sync is OFF. No backup folder selected.';
          }
          if (autoSyncWarningElem) {
            let warning = backupWarningMessage;
            if (!warning) {
              if (!hasHandle) {
                warning = 'Select a backup folder to keep automatic backups running.';
              } else if (backupPermissionState === 'prompt') {
                warning = backupName
                  ? `Grant TimeKeeper access to “${backupName}” to keep automatic backups running.`
                  : 'Grant TimeKeeper access to your backup folder to keep automatic backups running.';
              }
            }
            if (warning) {
              autoSyncWarningElem.textContent = warning;
              autoSyncWarningElem.style.display = 'block';
            } else {
              autoSyncWarningElem.textContent = '';
              autoSyncWarningElem.style.display = 'none';
            }
          }
          if (lastBackupStatusElem) {
            if (data && data.lastBackupAt) {
              const relative = formatRelativeTime(data.lastBackupAt);
              const backupDate = new Date(data.lastBackupAt);
              if (!isNaN(backupDate)) {
                lastBackupStatusElem.textContent = `Last backup: ${relative}`;
                lastBackupStatusElem.title = backupDate.toLocaleString();
                lastBackupStatusElem.style.display = 'block';
              } else {
                lastBackupStatusElem.textContent = '';
                lastBackupStatusElem.style.display = 'none';
              }
            } else if (autoSyncEnabled && folderUsable) {
              lastBackupStatusElem.textContent = 'Last backup: pending…';
              lastBackupStatusElem.title = '';
              lastBackupStatusElem.style.display = 'block';
            } else {
              lastBackupStatusElem.textContent = '';
              lastBackupStatusElem.style.display = 'none';
            }
          }
        }
        if (autoSyncToggle) {
          updateAutoSyncStatus();
          autoSyncToggle.addEventListener('change', async () => {
            if (autoSyncToggle.checked) {
              let ensured = true;
              if (!backupDirHandle) {
                ensured = await chooseBackupDir();
              } else {
                ensured = await ensureBackupPermissionWithPrompt(backupDirHandle);
              }
              if (!ensured || !backupDirHandle) {
                disableAutoSyncWithWarning('Permission to the backup folder is required to enable auto sync.');
                return;
              }
              autoSyncEnabled = true;
              localStorage.setItem('autoSyncEnabledPro', 'true');
              backupWarningMessage = '';
              updateAutoSyncStatus();
              await saveBackupToDir();
            } else {
              disableAutoSyncWithWarning('Auto sync is OFF. Remember to back up manually.');
            }
          });
        } else {
          updateAutoSyncStatus();
        }

        // Set Backup Folder button: prompts the user to pick a directory for backups. When
        // auto sync is enabled and no directory is selected, clicking this button
        // will call chooseBackupDir(). If auto sync is disabled, this button remains
        // functional to allow the user to preselect a folder before enabling auto sync.
        const chooseBtn = document.getElementById('chooseBackupDirBtn');
        const fsAccessSupported = !!window.showDirectoryPicker;
        if (!fsAccessSupported) {
          if (autoSyncToggle) {
            autoSyncToggle.disabled = true;
            autoSyncToggle.title = 'Auto sync requires a browser that supports folder access.';
          }
          if (chooseBtn) {
            chooseBtn.disabled = true;
            chooseBtn.title = 'Auto sync requires a browser that supports folder access.';
          }
          backupWarningMessage = 'Auto sync unavailable: your browser does not support choosing folders.';
          updateAutoSyncStatus();
        }
        if (chooseBtn) {
          chooseBtn.addEventListener('click', () => {
            chooseBackupDir({ activateSync: true });
          });
        }
      })();
    </script>
  </body>
</html>